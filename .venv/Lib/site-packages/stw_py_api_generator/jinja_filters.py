"""Фильтры для jinja движка."""
from typing import List

from stw_py_api_generator import naming
from stw_py_api_generator.build_python_code.types.manipulation import unwrap
from stw_py_api_generator.legacy.stw_yaml_gen import TypeWrapper
from stw_py_api_generator.python_classes.generic import MethodArgument, PythonModule


def method_args_filter(arguments: List[MethodArgument]) -> str:
    """Вывод в шаблон аргументов метода."""
    if not arguments:
        return ''
    txt_items = [
        f'{argument.argument_name}: {argument.argument_type_hint}'
        for argument in arguments
    ]
    return '{items}'.format(
        items=', '.join(txt_items),
    )


def method_args_filter_without_hints(arguments: List[MethodArgument]) -> str:
    """Вывод в шаблон аргументов метода."""
    if not arguments:
        return '**kwargs'
    txt_items = [
        f'{argument.argument_name}'
        for argument in arguments
    ]
    txt_items.append('**kwargs')
    return ', '.join(txt_items)


def method_args_names(arguments: List[MethodArgument]) -> str:
    """Вывод через запятую всех аргументов метода."""
    if not arguments:
        return ''
    txt_items = [argument.argument_name for argument in arguments]
    return ', '.join(txt_items)


def separated_enumerated_items(items_list: List[str]) -> str:
    """Вывод элементов массива через запятую с пробелом."""
    return ', '.join(items_list)


def call_method_args_filter(arguments: List[MethodArgument]) -> str:
    """Вывод аргументов метода в виде x=x, y=y. Для вызова метода."""
    if not arguments:
        return ''
    args = [
        f'{argument.argument_name}={argument.argument_name},'
        for argument in arguments
    ]
    return ' '.join(args)


def return_type_annotation(arguments: List[str]) -> str:
    """Массив типов - в список X | Y | Z."""
    types = return_types_names(arguments)
    return f'Union[{types}]'


def return_types_imports_filter(type_list: List[TypeWrapper], packet_name):
    """Вернуть импорты типов."""
    ans = []
    for wrapped_type_one in type_list:
        type_one = unwrap(wrapped_type_one)
        if type_one.kind == 'system':
            # для "встроенных" типов не нужны import-ы
            continue
        lower_name = naming.upper_to_snake(type_one.name.name)
        module_name = type_one.name.module
        type_name = type_one.name.name
        import_str = f'from {packet_name}.types.{module_name}.{lower_name}_type import {type_name}'  # noqa: WPS221
        ans.append(import_str)
    return '\r    '.join(ans)


def return_types_names(type_list: List[TypeWrapper]):
    """Вернуть имена типов."""
    return ', '.join([
        unwrap(type_one).name.name for type_one in type_list
    ])


def sc_local_name(full_class_name: str) -> str:
    """Локальный импорт класса из полного пути."""
    words = full_class_name.split('.')
    return words[-2]


def sc_class_name(full_class_name: str) -> str:
    """Имя для self-class из полного имени класса."""
    return full_class_name.split('.')[-1]


def module_local_name(module: PythonModule) -> str:
    """Имя для локального импорта модуля."""
    words = module.full_name.split('.')
    return words[-1]


def module_self_class_name(module: PythonModule) -> str:
    """Имя self-класса для модуля."""
    local_name = module_local_name(module)
    return naming.snake_to_upper(local_name)


def method_argument_value(argument: MethodArgument) -> str:
    """Значение аргумента при присвоении (выполнение метода)."""
    if argument.is_enum:
        return f'{argument.argument_name}.name'
    return argument.argument_name


def have_item(some_iterable, target) -> bool:
    """Проверка на то, что some_iterable содержит target."""
    return target in some_iterable


def upper_first_letter(text: str) -> str:
    """Первая буква становится большой."""
    if not text:
        return text
    first = text[0].upper()
    everything_else = text[1:]
    return f'{first}{everything_else}'
