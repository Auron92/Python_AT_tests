"""Генерация кода и запись в файлы."""
import os
from typing import List

from jinja2.filters import FILTERS

from stw_py_api_generator import jinja_filters, naming
from stw_py_api_generator.custom_types import ModuleRegistry
from stw_py_api_generator.general import encoding
from stw_py_api_generator.jinja_renders import rendering
from stw_py_api_generator.python_classes.cfg import CfgPythonClass, CfgRootPythonClass
from stw_py_api_generator.python_classes.cmds import CommandSenderClass
from stw_py_api_generator.python_classes.device import SyncDevicePythonClass
from stw_py_api_generator.python_classes.events import EventsPythonClass, EventsRootPythonClass
from stw_py_api_generator.python_classes.generic import PythonClass, PythonModule, TypePythonClass
from stw_py_api_generator.python_classes.tms import TmsPythonClass, TmsRootPythonClass, TmTypePythonClass
from stw_py_api_generator.python_classes.types.array_python_class import ArrayPythonClass
from stw_py_api_generator.python_classes.types.bits_python_class import BitsPythonClass
from stw_py_api_generator.python_classes.types.enum_python_class import EnumPythonClass
from stw_py_api_generator.python_classes.types.not_implemented_python_class import NotImplementedPythonClass
from stw_py_api_generator.python_classes.types.optional_python_class import OptionalPythonClass
from stw_py_api_generator.python_classes.types.string_python_class import StringPythonClass
from stw_py_api_generator.python_classes.types.synonym_python_class import SynonymPythonClass
from stw_py_api_generator.python_classes.types.variant_python_class import VariantPythonClass
from stw_py_api_generator.python_classes.types.vector_python_class import VectorPythonClass

FILTERS.update(
    {
        'method_args_filter': jinja_filters.method_args_filter,
        'method_args_filter_without_hints': jinja_filters.method_args_filter_without_hints,
        'method_args_names': jinja_filters.method_args_names,
        'call_method_args_filter': jinja_filters.call_method_args_filter,
        'sc_local_name': jinja_filters.sc_local_name,
        'sc_class_name': jinja_filters.sc_class_name,
        'module_local_name': jinja_filters.module_local_name,
        'module_self_class_name': jinja_filters.module_self_class_name,
        'method_argument_value': jinja_filters.method_argument_value,
        'return_type_annotation': jinja_filters.return_type_annotation,
        'have_item': jinja_filters.have_item,
        'upper_first_letter': jinja_filters.upper_first_letter,
        'snake_to_upper': naming.snake_to_upper,
        'return_types_imports_filter': jinja_filters.return_types_imports_filter,
        'return_types_names': jinja_filters.return_types_names,
        'separated_enumerated_items': jinja_filters.separated_enumerated_items,
    },
)


def write_init_file(
    path: os.path,
    registry: ModuleRegistry,
    module: PythonModule,
    class_file_names: List[str],
    class_names: List[str],
) -> None:
    """Создание __init__.py файла для модуля."""
    file_content = rendering.render_init_file(
        registry, module, class_file_names, class_names,
    )
    init_path = os.path.join(path, '__init__.py')

    with open(init_path, 'wt', encoding=encoding) as init_file:
        init_file.write(file_content)


def write_py_files(
    module: PythonModule,
    path: os.path,
    classes: List[PythonClass],
    class_file_names: List[str],
) -> None:
    """Создание файлов, содержащих описание классов."""
    for some_class, py_file_name in zip(classes, class_file_names):
        py_path = os.path.join(path, py_file_name)
        with open(py_path, 'wt', encoding=encoding) as py_file:
            packet = module if module.parent is None else module.packet
            rendered = rendering.render_class(packet, some_class)
            py_file.write(rendered)


def write_self_class(folder: os.path, module: PythonModule) -> None:
    """Создание файла с именем модуля. И запись туда класса.

    Например, для модуля core.can будет создан файл can.py с классом Can.
    """
    file_path = os.path.join(folder, f'{module.name}.py')
    file_content = rendering.render_class(module.self_class)
    with open(file_path, 'wt', encoding=encoding) as class_file:
        class_file.write(file_content)


def write_module_files(
    path: os.path,
    registry: ModuleRegistry,
    module: PythonModule,
) -> None:
    """Запись __init__.py файла в path с контентом от module."""
    all_classes = module.classes
    if module.self_class is not None:
        all_classes.append(module.self_class)
    class_file_names = [
        naming.class_filename(py_class) for py_class in all_classes
    ]
    class_names = [
        naming.last_word(python_class.name)
        for python_class in all_classes
    ]
    # создание и наполнение __init__.py файлов
    write_init_file(path, registry, module, class_file_names, class_names)
    write_py_files(module, path, module.classes, class_file_names)


def write_class_file(
    python_class: PythonClass, file_path: str, root: PythonModule,
) -> None:
    """Создание файла с содержанием класса, описанного в python_class."""
    render_map = [
        (SyncDevicePythonClass, rendering.render_device_class_sync),
        (CommandSenderClass, rendering.render_command_sender_class),
        (TmsRootPythonClass, rendering.render_tms_root_class),
        (TmsPythonClass, rendering.render_tms_class),
        (EventsRootPythonClass, rendering.render_events_root_class),
        (EventsPythonClass, rendering.render_events_class),
        (CfgRootPythonClass, rendering.render_cfg_root_class),
        (CfgPythonClass, rendering.render_cfg_class),
        (TmTypePythonClass, rendering.render_tm_type_class),
        (SynonymPythonClass, rendering.render_synonym_class),
        (BitsPythonClass, rendering.render_bits_class),
        (ArrayPythonClass, rendering.render_array_class),
        (EnumPythonClass, rendering.render_enum_class),
        (StringPythonClass, rendering.render_string_class),
        (TypePythonClass, rendering.render_types_type_class),
        (OptionalPythonClass, rendering.render_optional_class),
        (VectorPythonClass, rendering.render_vector_class),
        (VariantPythonClass, rendering.render_variant_class),
        (NotImplementedPythonClass, rendering.render_nimpl_class),
    ]
    render = None
    for key_class, render_class in render_map:
        if isinstance(python_class, key_class):
            render = render_class
            break
    if render is None:
        python_class_type = type(python_class)
        raise ValueError(f'no render for class: {python_class_type}')

    with open(file_path, 'w', encoding=encoding) as class_file:
        jinja_content = render(python_class, root)
        class_file.write(jinja_content)
