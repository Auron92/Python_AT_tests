# -*- coding: utf-8 -*-
import argparse
import copy
import hashlib
import logging
import math
import os
import textwrap
from collections import OrderedDict

import oyaml as yaml
import zpaq

from stw_py_api_generator.general import calculate_msg_id, encoding
from stw_py_api_generator.jinja_renders.template_utils import denormalize_name
from stw_py_api_generator.legacy.stw_helpers import CustomLoader, check_message_ids
from stw_py_api_generator.legacy.stw_types import MsgKind
from stw_py_api_generator.parsing.normalising import norm_type_name


def indent(text):
    return textwrap.indent(text, '    ')


def repStubModule():
    """Yaml repstub."""
    return """
    name: repstub
    info: Ошибки обмена
    types:
      - name: Ok
        kind: enum
        base: uint8_t
        values:
        - {name: Ok, value: 0,  info: Ok }
      - name: Error
        kind: enum
        base: uint8_t
        values:
        - {name: CmdParamTooMany,             value: 0,  info: много параметров для команды }
        - {name: CmdNotEnoughData,            value: 1,  info: недостаточно параметров для команды}
        - {name: CmdBadArg,                   value: 2,  info: некорректные параметры команды }
        - {name: TmUnknown,                   value: 3,  info: неизвестное тм-сообщение }
        - {name: NotImplemented,              value: 4,  info: не реализовано }
        - {name: NotEnoughMemory,             value: 5,  info: недостаточно памяти }
        - {name: NonEmptyOnShort,             value: 6,  info: некорректная склейка бубен-сообщения }
        - {name: BadFirst,                    value: 7,  info: некорректная первая часть длинного сообщения}
        - {name: EmptyOnFirst,                value: 8,  info: присутствует начало сообщения на фоне нового}
        - {name: MsgTooBig,                   value: 9,  info: слишкомдлинное сообщение}
        - {name: MiddleOnEmpty,               value: 10, info: присутствует середина сообщения на фоне нового}
        - {name: MiddleOnShortOrLast,         value: 11, info: присутствует середина сообщения на фоне короткого}
        - {name: MiddleExceedsSize,           value: 12, info: недостаточно памяти для склейки сообщения }
        - {name: LastOnEmpty,                 value: 13, info: пришел конец а сообщения нет}
        - {name: LastOnShort,                 value: 14, info: пришел конец а там короткое }
        - {name: BadLastSize,                 value: 15, info: некорректный размер последнего куска}
        - {name: BadCrc,                      value: 16, info: некорректное crc }
        - {name: BadSizeInBuf,                value: 17, info: некорректный размер в буфере}
        - {name: BadSizeInBuf2,               value: 18, info: некорректный размер в буфере2}
        - {name: ShortOrFirstOnMiddleOrLast,  value: 19, info: присутствует начало сообщения на фоне нового }
        - {name: MiddleOrLastOnEmpty,         value: 20, info: пришла середина или конец а начала нет }
        - {name: MiddleOnReady,               value: 21, info: пригла середина на фоне готового сообщения }
        - {name: PreviousItemIsCorrupted,     value: 22, info: предыдущее сообщение испорчено}
        - {name: CmdBadContext,               value: 23, info: неверный контекст исполнения команды }
    """


class ExceptionYmlDef(BaseException):
    def __init__(self, obj, text):
        print(text)


class Zipper:
    def _chunks(self, l, n):
        """Yield successive n-sized chunks from l."""
        for i in range(0, len(l), n):
            yield l[i:i + n]

    def _stringifyBytes(self, bs):
        s = ''
        for i in list(self._chunks(bs, 16)):
            s += '    ' + ', '.join('0x{:02X}'.format(a) for a in i)
            s += ',\n'
        return s

    def __init__(self, yaml):
        self.data = zpaq.compress(yaml)
        self.dataHex = self._stringifyBytes(self.data)

        hash = hashlib.sha3_512()
        hash.update(self.data)
        self.hash = hash.digest()
        self.name = self.hash[:12]
        self.nameStr = self.name.hex()
        self.nameHex = self._stringifyBytes(self.name)


class Size:
    def __init__(self, size):
        if size is not None:
            self._sizeBits = size
            self._fixedSize = True
        else:
            self._sizeBits = 0
            self._fixedSize = False

    def isFixed(self):
        return self._fixedSize

    def bytes(self):
        assert self._sizeBits % 8 == 0
        return math.ceil(self._sizeBits / 8)

    def bits(self):
        assert self._fixedSize
        return self._sizeBits

    def __add__(self, other):
        if isinstance(other, Size):
            self._sizeBits += other._sizeBits
            self._fixedSize = self._fixedSize and other._fixedSize
        elif isinstance(other, int):
            self._sizeBits += other
        else:
            self._sizeBits += other
            self._fixedSize = False
        return self

    def __iadd__(self, other):
        return self.__add__(other)

    def __mul__(self, other):
        assert (self._fixedSize)
        return Size(self._sizeBits * other)

    def __imul__(self, other):
        return self.__mul__(other)

    def __eq__(self, other):
        return self.__dict__ == other.__dict__


class Child:
    def __init__(self, name, type, offset, isTerminal):
        self.name = name
        self.offset = copy.copy(offset)
        self.type = type
        self.isTerminal = isTerminal


class TypeKind:
    unknown = 'unknown'
    system = 'system'
    synonym = 'synonym'
    bits = 'bits'
    struct = 'struct'
    enum = 'enum'
    array = 'array'
    vector = 'vector'
    variant = 'variant'
    optional = 'optional'
    string = 'string'


class Name:
    def __init__(self, name: str, module: str):
        if '.' not in name:
            self.module = module
            self.name = name
            self.alias = self.name
            return
        parts = name.split('.')
        self.name = parts[-1]
        self.module = '.'.join(parts[:-1])
        self.alias = self.name

    def fullName(self):
        if self.module is None:
            return self.name
        return '.'.join([self.module, self.name])

    def __str__(self):
        return f'{self.module}->{self.name}'


class TypeWrapper:
    def __init__(self, type):
        assert (not isinstance(type, TypeWrapper))
        self.type = type

    def __getattr__(self, attr):
        try:
            orig_attr = getattr(self.type, attr)
        except AttributeError as exc:
            raise AttributeError(
                f'type "{self.type}" has no attribute "{attr}"',
            )
        if callable(orig_attr):
            def hooked(*args, **kwargs):
                result = orig_attr(*args, **kwargs)
                # prevent wrapped_class from becoming unwrapped
                # if result == self.type: #TODO: как правильно?
                #    return self
                return result

            return hooked

        return orig_attr

    def __str__(self):
        return f'{self.type.name}'


class Type:
    def __init__(self, kind: TypeKind, name: Name, ignore=False):
        self.origin_name = name
        self.name = norm_type_name(name)
        self.kind = kind
        self.ignore = ignore

    @staticmethod
    def factory(t, module, alltypes):
        kind = t['kind']
        name = Name(t['name'], module)
        type = None

        if _is_custom_str_type(t):
            type = TypeString(t, name)
        elif kind == TypeKind.struct:
            type = TypeStruct(t, name, alltypes)
        elif kind == TypeKind.enum:
            type = TypeEnum(t, name, alltypes)
        elif kind == TypeKind.bits:
            type = TypeBits(t, name, alltypes)
        elif kind == TypeKind.synonym:
            type = TypeSynonym(t, name, alltypes)
        elif kind == TypeKind.array:
            type = TypeArray(t, name, alltypes)
        elif kind == TypeKind.vector:
            type = TypeVector(t, name, alltypes)
        elif kind == TypeKind.variant:
            type = TypeVariant(t, name, alltypes)
        elif kind == TypeKind.optional:
            type = TypeOptional(t, name, alltypes)
        else:
            assert False
        return type

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def fullName(self):
        return self.name.fullName()

    def size(self):
        raise NotImplementedError()

    def getChildren(self, name, offset, withNonTerminal):
        return [Child(name, self, offset, True)]

    def getYaml(self):
        y = dumpToYaml(self, 'kind', 'info', 'note', 'remark', 'min', 'max', 'unit')
        y.update({'name': self.name.fullName()})
        if self.ignore:
            y.update({'ignore': True})
        return y


def getDataForYaml(x):
    r = False
    try:
        r = x.__getattribute__('getYaml')
    except:
        pass

    if r:
        return x.getYaml()
    else:
        return x


def dumpToYaml(x, *fields):
    values = {}
    for f in fields:
        if not hasattr(x, f):
            continue
        attr = x.__getattribute__(f)
        if attr is None:
            continue

        if isinstance(attr, list):  # если массив
            tmp = []
            for i in attr:
                tmp.append(getDataForYaml(i))

            if len(tmp) > 0:
                values.update({f: tmp})
        else:
            values.update({f: getDataForYaml(attr)})

    return values


class TypeUnknown(Type):
    def __init__(self, name: Name):
        super().__init__(TypeKind.unknown, name)

    def getYaml(self):
        raise NotImplementedError()


class TypeSystem(Type):
    def __init__(self, name: Name, size: int):
        self._size = Size(size)
        super().__init__(TypeKind.system, name, True)

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def size(self):
        return self._size

    def getYaml(self):
        raise NotImplementedError()


class TypeSynonym(Type):
    def __init__(self, type: dict, name: Name, alltypes):
        # встроенные базовые типа (например, float) хранятся под другими именами
        right_name = norm_type_name(type['base'])
        self.base = alltypes.get(Name(right_name, None))
        self.info = type.get('info', None)
        self.unit = type.get('unit', None)
        super().__init__(TypeKind.synonym, name, 'ignore' in type)

    def getChildren(self, name, offset, withNonTerminal):
        return self.base.getChildren(name, offset, withNonTerminal)

    def size(self):
        return self.base.size()

    def getYaml(self):
        y = super().getYaml()
        y.update({'base': self.base.fullName()})
        return y


class TypeString(Type):

    def __init__(self, type: dict, name: Name):
        self.info = type.get('info', None)
        self.size = type.get('count', None)
        self.base_kind = type['kind']
        super().__init__(TypeKind.string, name)

    def size(self):
        return self.size()

    def getYaml(self):
        y = super().getYaml()
        return y


def _is_custom_str_type(yaml):
    return yaml['kind'] in (TypeKind.array, TypeKind.vector) and yaml['base'] == 'char'


class BitField:
    def __init__(self, field: dict, alltypes):
        self.name = field['name']
        size = field['size']
        self.type = alltypes.get(Name('__u' + str(size), None))
        self.values = None
        values = field.get('values')
        self.info = field.get('info', None)
        self.min = field.get('min', None)
        self.max = field.get('max', None)
        self.unit = field.get('unit', None)
        if values:
            self.values = alltypes.get(Name(values, None))

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def getYaml(self):
        y = dumpToYaml(self, 'name', 'min', 'max', 'info', 'unit')
        if getattr(self, 'values', None):
            y.update({'values': self.values.fullName()})
        y.update({'size': self.type.size().bits()})
        return y


class TypeBits(Type):
    def __init__(self, type: dict, name: Name, alltypes):
        self.fields = []
        size = Size(0)
        self.info = type.get('info', None)
        self.unit = type.get('unit', None)
        self.base = alltypes.get(Name(type['base'], None))
        for f in type['fields']:
            sf = BitField(f, alltypes)
            self.fields.append(sf)
            size += sf.type.size()
        size = self.base.size()  # TODO кажется тут ошибка в случае, если сумма полей превышает базоавый тип
        assert (size.bits() >= math.ceil(size.bits() / 8) * 8)
        assert len(self.fields) > 0
        self._size = size
        super().__init__(TypeKind.bits, name, 'ignore' in type)

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def size(self):
        return self._size

    def getChildren(self, name, offset, withNonTerminal):
        children = []
        if withNonTerminal:
            children = [Child(name, self, offset, False)]
        for i in self.fields:
            children += i.type.getChildren(name + '.' + i.name, offset, withNonTerminal)
            offset += i.type.size()
        return children

    def getYaml(self):
        y = super().getYaml()
        y.update(dumpToYaml(self, 'fields'))
        y.update({'base': self.base.type.fullName()})
        return y


class StructField:
    def __init__(self, field: dict, module: str, alltypes):
        self.name = field['name']
        type_name = norm_type_name(field['type'])
        type_module = None if alltypes.is_builtin(type_name) else module
        self.type = alltypes.get(Name(type_name, type_module))
        self.info = field.get('info')
        self.unit = field.get('unit', None)

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def getYaml(self):
        y = dumpToYaml(self, 'name', 'info', 'type', 'min', 'max', 'unit')
        y.update({'type': self.type.fullName()})
        return y


class TypeStruct(Type):
    def __init__(self, type: dict, name: Name, alltypes):
        self.fields = []
        self.info = type.get('info', None)
        self.unit = type.get('unit', None)
        for f in type.get('fields', []):
            sf = StructField(f, name.module, alltypes)
            self.fields.append(sf)
        super().__init__(TypeKind.struct, name, 'ignore' in type)

    def size(self):
        if hasattr(self, '_size'):
            return self._size

        self._size = Size(0)
        for f in self.fields:
            self._size += f.type.size()
        return self._size

    def getChildren(self, name, offset, withNonTerminal):
        children = []
        if withNonTerminal:
            children = [Child(name, self, copy.copy(offset), False)]
        for i in self.fields:
            children += i.type.getChildren(name + '.' + i.name, copy.copy(offset), withNonTerminal)
            offset += i.type.size()
        return children

    def getYaml(self):
        y = super().getYaml()
        y.update(dumpToYaml(self, 'info', 'fields'))
        return y


class TypeArray(Type):
    def __init__(self, type: dict, name: Name, alltypes):
        self.count = type['count']
        base_type_name = norm_type_name(type['base'])
        type_module = None if alltypes.is_builtin(base_type_name) else name.module
        self.base = alltypes.get(Name(base_type_name, type_module))
        self.info = type.get('info', None)
        self.unit = type.get('unit', None)
        super().__init__(TypeKind.array, name, 'ignore' in type)

    def size(self):
        if hasattr(self, '_size'):
            return self._size
        self._size = self.base.size() * self.count
        return self._size

    def getChildren(self, name, offset, withNonTerminal):
        children = []
        if withNonTerminal:
            children = [Child(name, self, copy.copy(offset), False)]
        for i in range(self.count):
            children += self.base.type.getChildren(name + '[{}]'.format(str(i)), copy.copy(offset), withNonTerminal)
            offset += self.base.type.size()
        return children

    def getYaml(self):
        y = super().getYaml()
        y.update(dumpToYaml(self, 'info', 'count'))
        y.update({'base': self.base.fullName()})
        return y


class EnumField:
    def __init__(self, field):
        must_be = ('name', 'value', 'info')
        if not all([name in field for name in must_be]):
            raise ValueError(f'Enum field must contains: {must_be}')
        self.name = field['name']
        self.value = field[
            'value']  # TODO добавить проверку на корректность значения (знаковое целое число в диапазоне  базового типа)
        self.info = field['info']
        self.unit = field.get('unit', None)

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def getYaml(self):
        return dumpToYaml(self, 'name', 'value', 'info', 'note')


class TypeEnum(Type):
    def __init__(self, type: dict, name: Name, alltypes):
        self.values = []
        if 'base' not in type:
            raise ValueError('enum must have base property')
        self.base = alltypes.get(Name(type['base'], None))
        self.unit = type.get('unit', None)
        self.info = type.get('info', None)
        assert type['values'] is not None  # С не допускает пустых енумов
        minValue = type['values'][0]['value']
        maxValue = type['values'][0]['value']
        values = set()

        for f in type['values']:
            field = EnumField(f)
            self.values.append(field)
            minValue = min(minValue, field.value)
            maxValue = max(maxValue, field.value)

            if field.value not in values:
                values.add(field.value)
            else:
                raise Exception('duplicate enum values found in {}: 0x{:08x}'.format(type['name'], field.value))

        self.min = minValue  # TODO: если поместить в предка, то будут выводиться в yaml, но значение рассчитываемое и требуется только для генераторов исходников(?)
        self.max = maxValue
        super().__init__(TypeKind.enum, name, 'ignore' in type)

    def size(self):
        return self.base.size()

    def getYaml(self):
        y = super().getYaml()
        y.update(dumpToYaml(self, 'info', 'values'))
        y.update({'base': self.base.fullName()})
        return y


class TypeOptional(Type):
    def __init__(self, type: dict, name: Name, alltypes):
        self.values = []
        base_type_name = norm_type_name(type['base'])
        type_module = None if alltypes.is_builtin(base_type_name) else name.module
        self.base = alltypes.get(Name(base_type_name, type_module))
        self.unit = type.get('unit', None)
        self.info = type.get('info', None)
        super().__init__(TypeKind.optional, name, 'ignore' in type)

    def size(self):
        return Size(None)

    def getYaml(self):
        y = super().getYaml()
        y.update(dumpToYaml(self, 'info', 'values'))
        y.update({'base': self.base.fullName()})
        return y


class TypeVector(Type):
    REQUIRED_FIELDS = ('base', 'count')

    def __init__(self, type: dict, name: Name, alltypes):
        self.validate_required_fields(type)

        self.base = alltypes.get(Name(type['base'], name.module))
        self.count = type['count']
        self.info = type.get('info', None)
        self.unit = type.get('unit', None)
        super().__init__(TypeKind.vector, name)

    def validate_required_fields(self, type):
        required_fields_str = ', '.join(self.REQUIRED_FIELDS)

        for field in self.REQUIRED_FIELDS:
            if field not in type:
                error_message = f"Vector must have fields: {required_fields_str}. But field '{field}' not found."
                raise ValueError(error_message)

    def size(self):
        return Size(None)

    def getYaml(self):
        y = super().getYaml()
        return y


class TypeVariant(Type):
    def __init__(self, type: dict, name: Name, alltypes):
        self.info = type.get('info', None)
        self.unit = type.get('unit', None)
        self.fields = []
        for f in type['fields']:
            sf = alltypes.get(Name(f, name.module))
            self.fields.append(sf)
        super().__init__(TypeKind.variant, name, 'ignore' in type)

    def size(self):
        return Size(None)

    def getYaml(self):
        y = super().getYaml()
        return y


class CmdTmParam:
    def __init__(self, param, module, alltypes):
        self.type = alltypes.get(Name(param['type'], module))
        assert self.type is not None
        self.name = param['name']
        self.info = param.get('info', None)
        self.note = param.get('note', None)
        self.remark = param.get('remark', None)
        self.unit = param.get('unit', None)

    def getYaml(self):
        y = dumpToYaml(self, 'name', 'info', 'min', 'max', 'unit')
        y.update({'type': self.type.name.fullName()})
        return y

    def __str__(self):
        return f'{self.name}: {self.type}'


def firstUp(s):
    return s[0].upper() + s[1:]


def firstDown(s):
    return s[0].lower() + s[1:]


def remove_params_dublicates(items):
    """Очистка от дубликатов."""
    clear_dct = {}
    for item in items:
        clear_dct[item.name] = item

    return list(clear_dct.values())

class CmdTm:
    def __init__(self, module: str, item: dict, alltypes, kind: MsgKind):
        name = item['name']
        self.module = module
        self.name = firstDown(name)
        self.kind = kind
        self.params = []
        self.info = item.get('info', None)
        self.note = item.get('note', None)
        self.remark = item.get('remark', None)
        self.rep = None
        self.crc32 = calculate_msg_id(self.fullName())
        self.msg_id = item.get('msg_id', None)
        self.req_id = item.get('req_id', None)
        self.rep_id = item.get('rep_id', None)

        full_name = f'{module}.{name}'
        check_message_ids(kind, full_name, self.msg_id, self.req_id, self.rep_id)

        if kind == MsgKind.cmd:
            rep = item.get('rep')
            # rep может вернуть как один объект, так и массив.
            # приводим в любом случае к массиву
            rep = _rep_to_array(rep)

            if rep is None:
                self.rep = None
                self.rep_id = None
            else:
                self.rep = []
                for rep_element in rep:
                    norm_name = norm_type_name(rep_element)
                    # добавлять тип нужно только если он не является "стандартным"
                    if not alltypes.is_builtin(norm_name):
                        self.rep.append(alltypes.get(Name(rep_element, module)))
                    else:
                        # мы не знаем, почему раньше не добавляли стандартные типы к rep
                        # поэтому будем логировать инциденты, что бы постараться понять
                        type_name = norm_type_name(rep_element)
                        logging.info(f'Стандартный тип {rep_element} добавлен к rep как {type_name}.')
                        self.rep.append(alltypes.get(Name(type_name, None)))

        if kind == MsgKind.event and item.get('event', None):
            if isinstance(item['event'], dict):
                event_type_name = item['event']['name']
            else:
                event_type_name = item['event']
            param = CmdTmParam({'name': 'event', 'type': event_type_name}, self.module, alltypes)
            self.params.append(param)

        for p in item.get('params', []):
            norm_param = p.copy()
            norm_param['type'] = norm_type_name(norm_param['type'])
            param = CmdTmParam(norm_param, self.module, alltypes)
            self.params.append(param)

        self.params = remove_params_dublicates(self.params)

    def size(self):
        if hasattr(self, '_size'):
            return self._size
        self._size = Size(0)
        for i in self.params:
            self._size += i.type.size()
        return self._size

    def getParams(self, withNonTerminal):
        offset = Size(0)
        children = []
        for i in self.params:
            children += i.type.getChildren(i.name, copy.copy(offset), withNonTerminal)
            offset += i.type.size()
        return children

    def getYaml(self):
        y = dumpToYaml(self, 'name', 'info', 'msg_id', 'info', 'remark', 'params', 'event')
        if self.rep:
            y.update({'rep': [x.name.fullName() for x in self.rep]})
        return y

    def fullName(self):
        return self.module + '.' + denormalize_name(self.name)


class Types:
    def addBaseTypes(self):
        self.add(TypeSystem(Name('bool_type', None), 8))
        self.add(TypeSystem(Name('str_type', None), 8))

        self.add(TypeSystem(Name('char', None), 8))
        self.add(TypeSystem(Name('uint8_t', None), 8))
        self.add(TypeSystem(Name('uint16_t', None), 16))
        self.add(TypeSystem(Name('uint32_t', None), 32))
        self.add(TypeSystem(Name('uint64_t', None), 64))
        self.add(TypeSystem(Name('int8_t', None), 8))
        self.add(TypeSystem(Name('int16_t', None), 16))
        self.add(TypeSystem(Name('int32_t', None), 32))
        self.add(TypeSystem(Name('int64_t', None), 64))
        self.add(TypeSystem(Name('varint16_t', None), 16))
        self.add(TypeSystem(Name('varint32_t', None), 32))
        self.add(TypeSystem(Name('varint64_t', None), 64))
        self.add(TypeSystem(Name('varuint16_t', None), 16))
        self.add(TypeSystem(Name('varuint32_t', None), 32))
        self.add(TypeSystem(Name('varuint64_t', None), 64))
        self.add(TypeSystem(Name('float_type', None), 32))
        self.add(TypeSystem(Name('double', None), 64))
        self.add(TypeSystem(Name('string', None), 8))

        self.add(TypeSystem(Name('ui8', None), 8))
        self.add(TypeSystem(Name('ui16', None), 16))
        self.add(TypeSystem(Name('ui32', None), 32))
        self.add(TypeSystem(Name('ui64', None), 64))
        self.add(TypeSystem(Name('u8', None), 8))
        self.add(TypeSystem(Name('u16', None), 16))
        self.add(TypeSystem(Name('u32', None), 32))
        self.add(TypeSystem(Name('u64', None), 64))
        self.add(TypeSystem(Name('i8', None), 8))
        self.add(TypeSystem(Name('i16', None), 16))
        self.add(TypeSystem(Name('i32', None), 32))
        self.add(TypeSystem(Name('i64', None), 64))
        self.add(TypeSystem(Name('f32', None), 32))
        self.add(TypeSystem(Name('f64', None), 64))

        self.add(TypeSystem(Name('__u1', None), 1))
        self.add(TypeSystem(Name('__u2', None), 2))
        self.add(TypeSystem(Name('__u3', None), 3))
        self.add(TypeSystem(Name('__u4', None), 4))
        self.add(TypeSystem(Name('__u5', None), 5))
        self.add(TypeSystem(Name('__u6', None), 6))
        self.add(TypeSystem(Name('__u7', None), 7))
        self.add(TypeSystem(Name('__u8', None), 8))
        self.add(TypeSystem(Name('__u9', None), 9))
        self.add(TypeSystem(Name('__u10', None), 10))
        self.add(TypeSystem(Name('__u11', None), 11))
        self.add(TypeSystem(Name('__u12', None), 12))
        self.add(TypeSystem(Name('__u13', None), 13))
        self.add(TypeSystem(Name('__u14', None), 14))
        self.add(TypeSystem(Name('__u15', None), 15))
        self.add(TypeSystem(Name('__u16', None), 16))
        self.add(TypeSystem(Name('__u17', None), 17))
        self.add(TypeSystem(Name('__u18', None), 18))
        self.add(TypeSystem(Name('__u19', None), 19))
        self.add(TypeSystem(Name('__u20', None), 20))
        self.add(TypeSystem(Name('__u21', None), 21))
        self.add(TypeSystem(Name('__u22', None), 22))
        self.add(TypeSystem(Name('__u23', None), 23))
        self.add(TypeSystem(Name('__u24', None), 24))
        self.add(TypeSystem(Name('__u25', None), 25))
        self.add(TypeSystem(Name('__u26', None), 26))
        self.add(TypeSystem(Name('__u27', None), 27))
        self.add(TypeSystem(Name('__u28', None), 28))
        self.add(TypeSystem(Name('__u29', None), 29))
        self.add(TypeSystem(Name('__u30', None), 30))
        self.add(TypeSystem(Name('__u31', None), 31))
        self.add(TypeSystem(Name('__u32', None), 32))

        self.add(TypeVector({'base': 'uint8_t', 'count': 8}, Name('bytes', None), self))

        # размер нулевой, потому что нет "произвольного" размера в дизайне
        self.add(TypeSystem(Name('bytes_type', None), 0))

    def __init__(self):
        self.types = OrderedDict()

    def is_builtin(self, type_name):
        """Проверка того, что тип числится как встроеный.

        Для встроенных типов не нужны импорты.
        Они всегда импортируются через * в начале файла.
        """
        from_storage = self.types.get(type_name)
        if from_storage is None:
            return False
        return from_storage.name.module is None

    def add(self, type):
        t = self.types.get(type.fullName(), None)
        if t is None:
            if isinstance(type, TypeWrapper):
                t = type
            else:
                t = TypeWrapper(type)
            self.types[type.fullName()] = t
        elif t.kind == TypeKind.unknown:
            t.type = type
        else:
            assert False

        return t

    def get(self, name):
        x = 1
        if name.name in self.types:
            t = self.types.get(name.name)
            return t

        fullName = name.fullName()
        if fullName in self.types:
            return self.types.get(fullName)
        return self.add(TypeUnknown(name))

    def values(self):
        return self.types.values()

    def resolve(self):
        for i in self.types.values():
            if i.kind != TypeKind.unknown:
                continue
            raise ValueError('type not found: ' + i.type.name.fullName())

    def getYaml(self):
        y = []
        for i in self.types.values():
            data = i.getYaml()
            assert (data)
            y.append(i.getYaml())
        return y


class Module:
    """Python объект, повторяющий структуру модуля в yml"""

    def __init__(self, yaml, module, alltypes: Types):
        self._raw_config = yaml
        self.name = yaml['name'].lower()
        if 'info' in yaml:
            self.info = yaml['info']
        else:
            logging.warning("module %s does'not contains 'info'" % module)
        self.remark = yaml.get('remark', None)
        self.comment = yaml.get('comment', None)
        self.imports = yaml.get('import', [])
        self.includes = yaml.get('includes', [])
        if module[-1] != self.name:
            raise ValueError('wrong module name')
        self.name = '.'.join(module)
        self.path = '/'.join(module)
        self.cppname = '::'.join(module)
        self.uname = '_'.join(module)
        self.cmds = []
        self.tms = []
        self.events = []
        self.cfg = []
        self.types = Types()

        if 'import' in yaml:
            # TODO print deprecated
            self.imports = yaml['import']

        if isinstance(self.imports, str):
            self.imports = [self.imports]

        if 'types' in yaml and yaml['types'] is not None:
            for t in yaml['types']:
                # t содержит строки из yml файла. Ключевые слова в названии
                # типов нужно нормализовать
                norm_name = norm_type_name(t['name'])
                if not self.types.is_builtin(norm_name):
                    # "встроенные типы не нужно добавлять
                    new_type = Type.factory(t, self.name, alltypes)
                    assert (new_type.name.module is not None)
                    alltypes.add(self.types.add(new_type))
                self.types.resolve()

    def load(self, alltypes: Types):
        raw_config = self._raw_config

        if cmds := raw_config.get('cmds'):
            for item in cmds:
                self.cmds.append(CmdTm(self.name, item, alltypes, MsgKind.cmd))

        if tms := raw_config.get('tms'):
            for item in tms:
                self.tms.append(CmdTm(self.name, item, alltypes, MsgKind.tm))

        if events := raw_config.get('events'):
            for item in events:
                self.events.append(CmdTm(self.name, item, alltypes, MsgKind.event))

        if cfg := raw_config.get('cfg'):
            for item in cfg:
                self.cfg.append(CmdTm(self.name, item, alltypes, MsgKind.cfg))

    def hasEvents(self):
        return len(self.events) != 0

    def hasTms(self):
        return len(self.tms) != 0

    def hasCmds(self):
        return len(self.cmds) != 0

    def getImportYaml(self):
        y = dumpToYaml(self, 'name', 'types')
        imports = []
        for i in self.imports:
            imports.append(i.name)
        if imports:
            y.update({'import': imports})
        return y

    def getYaml(self):
        y = dumpToYaml(self, 'name', 'info', 'remark', 'comment', 'includes', 'cmds', 'tms', 'events', 'types')
        imports = []
        for i in self.imports:
            imports.append(i.name)
        if imports:
            y.update({'import': imports})
        return y

    def resolve(self, modules):
        imports = []
        for i in self.imports:
            el = [x for x in modules if x.name == i][0]
            assert el is not None
            imports.append(el)
        self.imports = imports

    def __str__(self):
        return f'{self.name}'

    def __repr__(self):
        return f'{self.name}'


class DuplicateMsgId:
    def __init__(self, msgid, first, second):
        self.msgid = msgid
        self.first = first
        self.second = second

    def __repr__(self):
        return '0x{:08x}: {}, {}'.format(self.msgid, self.first, self.second)


class DuplicateStoreId:
    def __init__(self, storeid, first, second):
        self.storeid = storeid
        self.first = first
        self.second = second

    def __repr__(self):
        return '0x{:08x}: {}, {}'.format(self.crc32, self.first, self.second)


class Device:
    def __init__(self, yaml, alltypes, modules):
        self.name = yaml['name'].lower()
        self.info = yaml['info']
        self.alltypes = alltypes
        self.modules = []

        # repstub как опциональная зависимость. Хорошо бы переделать.
        repstub_exists = False
        for i in yaml['modules']:
            if isinstance(i, dict):
                i = i['name']
            m = None
            for j in modules:
                if j.path == i:
                    m = j
            if m is not None:
                if getattr(m, 'name', '') == 'repstub':
                    repstub_exists = True
                self.modules.append(m)

        duplicates = self.findDuplcateMsgIds()
        if duplicates:
            print('duplicate msg_ids found:')
            for i in duplicates:
                print(i)
            raise Exception(duplicates)

        duplicates = self.findDuplcateStoreIds()
        if duplicates:
            print('duplicate store_ids found:')
            for i in duplicates:
                print(i)
            raise Exception(duplicates)

    def findDuplcateMsgIds(self):
        ids = {}
        ret = []
        for m in self.modules:
            for i in m.cmds + m.tms + m.events:
                found = ids.get(i.msg_id)
                if found:
                    ret.append(DuplicateMsgId(i.msg_id, found, i.fullName()))
                ids[i.msg_id] = i.fullName()
        return ret

    def findDuplcateStoreIds(self):
        ids = {}
        ret = []
        for m in self.modules:
            for i in m.cfg:  # TODO полное имя должно быть глобально уникальным! + m.cmds + m.tms + m.events
                found = ids.get(i.crc32)
                if found:
                    ret.append(DuplicateStoreId(i.crc32, found, i.fullName()))
                ids[i.crc32] = i.fullName()
        return ret

    def _getMaxDataSize(self, items):
        size = 0
        for i in items:
            size = max(size, i.size().bytes())
        return size

    def _getTotalDataSize(self, items):
        size = 0
        for i in items:
            size += i.size().bytes()
        return size

    def _getMaxCanMsgSize(self, items):
        size = 0
        for i in items:
            size = max(size, i.can_msg_size)
        return size

    def _getImports(self, module):
        imports = {}
        for i in module.imports:
            if i not in imports:
                imports[i.name] = i
                imports.update(self._getImports(i))
        return imports

    def getYamlData(self):
        if hasattr(self, 'yamldata'):
            return self.yamldata

        imports = {}
        for i in self.modules:
            imports[i.name] = i
            imports.update(self._getImports(i))

        for i in self.modules:
            imports.pop(i.name)

        y = dumpToYaml(self, 'name', 'info', 'remark', 'comment', 'modules')
        for k, v in imports.items():
            y['modules'].append(v.getImportYaml())

        self.yamldata = yaml.dump(y, None, Dumper=yaml.Dumper, encoding=encoding, allow_unicode=True,
                                  default_flow_style=False)
        return self.yamldata

    def getZipData(self):  # FIXME: эта функция по идее не нужна
        if hasattr(self, 'zipdata'):
            return self.zipdata
        self.zipdata = Zipper(self.getYamlData())
        return self.zipdata


def is_ascii(s):
    return all(ord(c) < 128 for c in s)


def validate_ascii(d):
    if d is not None and not isinstance(d, (int, float, str)):
        if 'name' in d:
            asci = is_ascii(d['name'])
            if not asci:
                raise Exception("name is not ascii %s %s" % (d, d['name']))
        if isinstance(d, dict):
            for k, v in d.items():
                validate_ascii(v)
        elif isinstance(d, list):
            for l in d:
                validate_ascii(l)
        else:
            print(type(d))


class YamlTreeParser:
    def __init__(self, filePath, modulesDir):
        self.alltypes = Types()
        self.alltypes.addBaseTypes()  # TODO: полное описание устройство должн описывать все необходимые типы, чтобы не требовалась доп.информация для парсинга?
        self.modules = []
        self.devices = []

        ym = yaml.load(repStubModule(), Loader=CustomLoader)
        self.modules.append(Module(ym, [ym['name']], self.alltypes))

        f = open(os.path.join(filePath), mode="r", encoding=encoding)
        y = yaml.load(f.read(), Loader=CustomLoader)
        for i in y['modules']:
            fm = open(os.path.join(modulesDir, i['name'] + '.yml'), mode="r", encoding=encoding)
            ym = yaml.load(fm.read(), Loader=CustomLoader)
            validate_ascii(ym)
            # TODO подставлять неймспейс из пути
            name = i['name'].replace('\\', '/').split('/')
            self.modules.append(Module(ym, name, self.alltypes))
        self.alltypes.resolve()

        for i in self.modules:
            i.resolve(self.modules)

        for i in y['devices']:
            self.devices.append(Device(i, self.alltypes, self.modules))



def str2bool(v):
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')


def _rep_to_array(rep):
    """Принимает один объект или массив.

    Из объекта делает массив, а с массивом - не делает ничего.
    """
    if isinstance(rep, list):
        return rep
    return [rep]


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("input_filename")
    parser.add_argument("modules_dir")
    parser.add_argument("output_dir")
    parser.add_argument("--cpp", type=str2bool, nargs='?', const=True, default=False, help="generate cpp files")
    parser.add_argument("--extras", type=str2bool, nargs='?', const=True, default=False, help="extra tests")
    parser.add_argument("--pyGen", type=str2bool, nargs='?', const=True, default=False, help="generate python scripts")
    parser.add_argument("--docGen", type=str2bool, nargs='?', const=True, default=False, help="generate documentation")
    args = parser.parse_args()

    parser = YamlTreeParser(args.input_filename, args.modules_dir)
    outdir = args.output_dir
    parser.generateSources(outdir, args)
    if args.extras:
        import stw_extras as extras

        extras.testParser(parser)
        extras.checkOffsets(parser)
    if args.pyGen:
        import stw_python_gen as pyGen

        pyGen.generateScripts(parser, outdir=outdir + '//py-stw')
    if args.docGen:
        import stw_doc_gen as docGen

        docGen.generateDocumentation(parser, outdir=outdir + '//doc-stw')
