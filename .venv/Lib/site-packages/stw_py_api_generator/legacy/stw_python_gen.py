import itertools
import logging
import os
from pathlib import Path
from typing import List

from stw_py_api_generator.build_python_code.builder import build
from stw_py_api_generator.general import encoding
from stw_py_api_generator.legacy.stw_yaml_gen import firstDown, firstUp

identationToken = '    '

intLike = [
    'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t',
    'int8_t',  'int16_t',  'int32_t',  'int64_t',
    'ui8',     'ui16',     'ui32',     'ui64',
    'u8',      'u16',      'u32',      'u64',
    'i8',      'i16',      'i32',      'i64',
    '__u1',    '__u2',     '__u3',     '__u4',
    '__u5',    '__u6',     '__u7',     '__u8',
    '__u9',    '__u10',    '__u11',    '__u12',
    '__u13',   '__u14',    '__u15',    '__u16',
    '__u17',   '__u18',    '__u19',    '__u20',
    '__u21',   '__u22',    '__u23',    '__u24',
    '__u25',   '__u26',    '__u27',    '__u28',
    '__u29',   '__u30',    '__u31',    '__u32'
    ]

floatLike = [
    'float', 'double', 'f32', 'f64'
]
otherLike = [
    'bool', 'bytes'
]

clike = ['bits', 'enum', 'struct', 'array', 'synonym']

logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)

try:
    import coloredlogs

    coloredlogs.DEFAULT_LOG_FORMAT = '%(asctime)s - %(levelname)s - %(message)s'
    coloredlogs.install(level='INFO', logger=logging.getLogger())
except ImportError:
    logging.warning("run 'pip install coloredlogs' to see more accurate error log")


def getBaseType(typeName):
    if typeName in intLike:
        return 'int'
    if typeName in floatLike:
        return 'float'
    return typeName


def firstUpAbsoluteName(absoluteName):
    splittedStr = absoluteName.split('.')
    for i, className in enumerate(splittedStr):
        splittedStr[i] = firstUp(className)
    return '.'.join(splittedStr)


def transcribeArgsList(args, deviceName):
    arglist = []
    for arg in args:
        argName = arg.name
        argType = arg.type.kind
        if argType in clike:
            argType = '\'{}.{}.{}\''.format(deviceName, firstUpAbsoluteName(arg.type.name.module), arg.type.name.name)
        elif argType == 'synonym':
            argType = getBaseType(arg.type.base.name.name)
        elif argType == 'system':
            argType = getBaseType(arg.type.name.name)
        arglist.append({
            'name': argName,
            'type': argType
        })
    return arglist


class ClassHeading:
    def __init__(self, name, level, parent=''):
        self.name = name
        self.indentLevel = level
        self.parent = parent

    def finalize(self):
        parentString = ''
        if self.parent:
            parentString = '({})'.format(self.parent)
        levelString = identationToken * self.indentLevel
        startnewlines = '\n\n' if self.indentLevel == 0 else ''
        return '{}{}class {}{}:'.format(startnewlines, levelString, self.name, parentString)


class FuncHeading:
    def __init__(self, name, level, args=[]):
        self.name = name
        self.indentLevel = level
        self.args = args

    def finalize(self):
        argString = ''
        predef = ''
        typesknown = False
        if self.args:
            if isinstance(self.args[0], dict):
                typesknown = True
                new_args = []
                for arg in self.args:
                    new_args.append('{}: {}'.format(arg['name'], arg['type']))
                self.args = new_args
            argString = ', ' + ', '.join(self.args)
        argString = 'self' + argString
        levelString = identationToken * self.indentLevel
        if self.name == '__init__' and typesknown:
            predef = '\n'.join(map(lambda x: levelString+x, self.args))+'\n\n'
        return '{}{}def {}({}):'.format(predef, levelString, self.name, argString)


class EnumFieldDummy:
    def __init__(self, name, value):
        self.name = name
        self.value = value


class SynonymHeading:
    def __init__(self, name, level, synonymTo):
        self.name = name
        self.indentLevel = level
        self.synonymTo = synonymTo

    def finalize(self):
        levelString = identationToken * self.indentLevel
        return '{}{} = NewType("{}", {})'.format(levelString, self.name, self.name, self.synonymTo)


class Device:
    def __init__(self, name: str, outdir: str):
        self.name = name
        self.outdir = Path(outdir)
        self.imports = []
        self.script = dict()
        self.script['level'] = 0
        self.script['heading'] = ClassHeading(name, level=0, parent='JSONHelper').finalize()
        self.script['deviceBody'] = ''
        self.script['components'] = {}

    def save(self):
        filename = self.outdir / "{}.py".format(self.name)
        with open(filename, 'w', encoding=encoding) as f:
            f.write("# -*- coding: utf-8 -*-\n")
            f.write(self.glue())
            f.close()
            logging.info('Generated: {}'.format(filename))

    def addImport(self, from_: str, imports: List[str]):
        stmt = 'from {} import {}'.format(from_, ', '.join(imports))
        if stmt in self.imports:
            return
        self.imports.append(stmt)

    def addInstance(self, absoluteName, name, currentLevel=1):
        instanceName = absoluteName + '_instance'
        self.script['components'][instanceName] = {}
        self.script['components'][instanceName]['level'] = currentLevel
        self.script['components'][instanceName]['heading'] = '{}{} = {}()'.format(identationToken * (currentLevel),
                                                                                  firstDown(name), firstUp(name))
        self.script['components'][instanceName]['messages'] = {}
        self.script['components'][instanceName]['types'] = {}

    def addComponent(self, name, currentLevel=1):
        currentName = name.split('.')[currentLevel - 1]
        absoluteName = '.'.join(name.split('.')[:currentLevel])
        classAbsoluteName = '{}.{}'.format(self.name, firstUpAbsoluteName(absoluteName))
        if not (absoluteName in self.script['components'].keys()):
            self.script['components'][absoluteName] = {}
            self.script['components'][absoluteName]['level'] = currentLevel
            self.script['components'][absoluteName]['heading'] = ClassHeading(firstUp(currentName), level=currentLevel,
                                                                              parent='JSONHelper').finalize()
            self.script['components'][absoluteName]['componentBody'] = ''
            self.script['components'][absoluteName]['messages'] = {}
            self.script['components'][absoluteName]['types'] = {}
            self.script['components'][absoluteName]['directChildren'] = []
        if currentLevel < len(name.split('.')):
            childName = name.split('.')[currentLevel]
            childAbsoluteName = '.'.join(name.split('.')[:currentLevel + 1])
            childClassAbsoluteName = '{}.{}'.format(self.name, firstUpAbsoluteName(childAbsoluteName))
            if not ([childName, childClassAbsoluteName] in self.script['components'][absoluteName]['directChildren']):
                self.script['components'][absoluteName]['directChildren'].append([childName, childClassAbsoluteName])
            self.addComponent(name, currentLevel + 1)

    def addMsgIds(self, msgKindName, componentName, msgList):
        if len(msgList) == 0:
            return
        currentLevel = self.script['components'][componentName]['level'] + 1
        self.script['components'][componentName][msgKindName] = {}
        self.script['components'][componentName][msgKindName]['heading'] = ClassHeading(firstUp(msgKindName),
                                                                                        level=currentLevel,
                                                                                        parent='Enum').finalize()
        self.script['components'][componentName][msgKindName]['typeBody'] = self.addTypeEnumBody(currentLevel, msgList)

    def generateComponentInitData(self, name, level, children=[]):
        componentInitData = '{}super({}, self).__init__(device_id, ste)\n'.format(identationToken * (level + 1), name)
        for childrenTuple in children:
            componentInitData += '{}self.{}: {} = {}(device_id, ste)\n'.format(identationToken * (level + 1), childrenTuple[0],
                                                                              childrenTuple[1], childrenTuple[1])
        return componentInitData

    def addComponentInit(self, classAbsoluteName, level, args, children=[]):
        currentLevel = level + 1
        componentInit = FuncHeading('__init__', level=currentLevel, args=args).finalize() + '\n'
        componentInit += self.generateComponentInitData(classAbsoluteName, currentLevel, children)
        return componentInit

    # addType(module.name, type.name.name, args=type.values, typeParent='Enum')
    def addType(self, componentName, name, args=[], typeParent='', synonymTO=''):
        currentLevel = self.script['components'][componentName]['level'] + 1
        self.script['components'][componentName]['types'][name] = {}
        self.script['components'][componentName]['types'][name]['level'] = currentLevel
        if synonymTO != '':
            synonymBase = getBaseType(synonymTO)
            self.script['components'][componentName]['types'][name]['heading'] = SynonymHeading(name, currentLevel,
                                                                                                synonymBase).finalize()
            self.script['components'][componentName]['types'][name]['typeBody'] = ''
            return
        if typeParent == 'Enum':
            self.script['components'][componentName]['types'][name]['heading'] = ClassHeading(name, level=currentLevel,
                                                                                              parent=typeParent).finalize()
            self.script['components'][componentName]['types'][name]['typeBody'] = self.addTypeEnumBody(currentLevel,
                                                                                                       args)
        elif typeParent == 'StructLike':
            self.script['components'][componentName]['types'][name]['heading'] = ClassHeading(
                name, level=currentLevel,
            ).finalize()
            args = transcribeArgsList(args, self.name)
            self.script['components'][componentName]['types'][name]['typeBody'] = self.addTypeInit(currentLevel, args)
        else:
            self.script['components'][componentName]['types'][name]['heading'] = ClassHeading(name, level=currentLevel,
                                                                                              parent=typeParent).finalize()
            self.script['components'][componentName]['types'][name]['typeBody'] = self.addTypeInit(currentLevel, args)

    def generateTypeInitData(self, level, args):
        if args:
            typeInitData = ''
            for arg in args:
                typeInitData += '{}self.{} = {}\n'.format(identationToken * (level + 1), arg['name'], arg['name'])
            return typeInitData
        return '{}pass\n'.format(identationToken * (level + 1))

    def addTypeInit(self, level, args):
        currentLevel = level + 1
        typeInit = FuncHeading('__init__', level=currentLevel, args=args).finalize() + '\n'
        typeInit += self.generateTypeInitData(currentLevel, args)
        return typeInit

    def addTypeEnumBody(self, level, args):
        typeEnumBody = ''
        tabLevel = identationToken * (level + 1)
        FORBIDDEN_MAP = {
            "True": "true",
            "False": "false",
            "in": "in_",
            "None": "None_",
        }
        for arg in args:
            fieldName = arg.name
            if fieldName in FORBIDDEN_MAP:
                fieldName = FORBIDDEN_MAP[fieldName]
            typeEnumBody += '{}{} = {}\n'.format(tabLevel, fieldName, str(arg.value))
        return typeEnumBody

    def cnupper(self, class_name):
        # c = cn.split('.')
        # b=[]
        # for _c in c:
        #     b.append(_c[0].upper()+_c[1:])

        # Вариант исполнения
        words = class_name.split('.')
        capitalized_words = [word.capitalize() for word in words]
        return '.'.join(capitalized_words)

    def addMessage(self, componentName, name, args=[], msg_id=None, msg=None):
        raise DeprecationWarning('addMessage is deprecated')

    def generateMessageData(self, level,reptype, data=None, info=None):
        if data is None:
            indent = identationToken * (level + 1)
            if info:
                info = f'''{indent}"""{info}"""\n'''
            else:
                info = ''
            return f'{info}{indent}return self.makejson(rep_type={reptype})\n'
            # return '{}pass'.format(identationToken*(level+1))

    def addComponentInits(self):
        deviceDirectChildren = []
        for absoluteName in self.script['components'].keys():
            classAbsoluteName = '{}.{}'.format(self.name, firstUpAbsoluteName(absoluteName))
            '{self_name}.{abs_name}'.format(
                self_name=self.name,
                abs_name=firstUpAbsoluteName(absoluteName),
            )
            currentLevel = self.script['components'][absoluteName]['level']
            if currentLevel == 1:
                deviceDirectChildren.append([absoluteName, classAbsoluteName])
            self.script['components'][absoluteName]['componentBody'] = self.addComponentInit(
                classAbsoluteName,
                currentLevel,
                args=['device_id', 'ste'],
                children=self.script['components'][absoluteName]['directChildren'])
        self.script['deviceBody'] = self.addComponentInit(self.name, 0, args=['device_id', 'ste'],
                                                          children=deviceDirectChildren)

    def glue(self):
        endline = '\n'
        scriptData = ''
        self.addComponentInits()
        scriptData += endline.join(self.imports)
        scriptData += endline
        scriptData += self.script['heading'] + endline
        scriptData += self.script['deviceBody'] + endline
        for componentName in sorted(self.script['components'].keys()):
            scriptData += self.script['components'][componentName]['heading'] + endline
            scriptData += self.script['components'][componentName]['componentBody'] + endline
            enumList = ['cmdMsgIds', 'tmMsgIds', 'eventMsgIds']
            for enum in enumList:
                if enum in self.script['components'][componentName].keys():
                    scriptData += self.script['components'][componentName][enum]['heading'] + endline
                    scriptData += self.script['components'][componentName][enum]['typeBody'] + endline
            for typeName in self.script['components'][componentName]['types'].keys():
                scriptData += self.script['components'][componentName]['types'][typeName]['heading'] + endline
                scriptData += self.script['components'][componentName]['types'][typeName]['typeBody'] + endline
            for funcName in self.script['components'][componentName]['messages'].keys():
                scriptData += self.script['components'][componentName]['messages'][funcName]['heading'] + endline
                scriptData += self.script['components'][componentName]['messages'][funcName]['messageBody'] + endline
        return scriptData


def unwrapImports(module):
    listOfImports = []
    if module.imports:
        for importedModule in module.imports:
            listOfImports.append(importedModule)
            listOfImports.extend(unwrapImports(importedModule))
    return listOfImports


def createFullModuleList(importedModules, originalModules):
    fullModuleList = []
    for importedModule in importedModules:
        if importedModule in originalModules:
            continue
        if importedModule in fullModuleList:
            continue
        fullModuleList.append([importedModule, False])
    for originalModule in originalModules:
        fullModuleList.append([originalModule, True])
    return fullModuleList


def ensureDirExists(path):
    if os.path.exists(path):
        return
    os.makedirs(path)


def generateScripts(parser, outdir, source_info, **kwargs):
    return build(parser, outdir, source_info, **kwargs)
