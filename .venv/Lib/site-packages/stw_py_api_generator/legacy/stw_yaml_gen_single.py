import hashlib
import io
import os
import pathlib
import re
from enum import Enum
from functools import cmp_to_key
from importlib.metadata import version

import oyaml
import pkg_resources
import typer
import zpaq
from loguru import logger

from stw_py_api_generator import __file__ as module_file_path
from stw_py_api_generator.config import pipy_registry, versioning
from stw_py_api_generator.general import encoding, now_split_str, now_str
from stw_py_api_generator.legacy import stw_python_gen
from stw_py_api_generator.legacy.stw_helpers import CustomLoader
from stw_py_api_generator.legacy.stw_yaml_gen import Device, Module, Types, YamlTreeParser
from stw_py_api_generator.naming import upper_to_snake
# noinspection PyMissingConstructor
from stw_py_api_generator.parsing.normalising import normalize_device_file

module_path = os.path.dirname(module_file_path)
builder_dir = os.path.join(module_path, 'packet_builder')


class DeviceSingle(Device):
    def __init__(self, yamlobj, alltypes, modules):
        self.name = yamlobj['name'].lower()
        self.info = yamlobj['info']
        self.alltypes = alltypes
        self.modules = []

        for i in yamlobj['modules']:
            m = None
            for j in modules:
                if j.path == i['name']:
                    m = j
            assert m is not None
            self.modules.append(m)


def process_info(data: dict, target: str = '"', new_symbol: str = '*'):
    """Замена символа на нужный."""
    info = data.get('info', None)
    if info is not None:
        data['info'] = info.replace(target, new_symbol)


def normalize_modules(yaml_content: dict):
    """Нормализация типов и команд."""
    for module in yaml_content.get('modules', []):
        for cmd in module.get('cmds', []):
            for param in cmd.get('params', []):
                param_name = param['name']
                param_type = param['type'].split('.')[-1]
                if param_name == param_type:
                    param['name'] = upper_to_snake(param_name)
    return yaml_content


# noinspection PyMissingConstructor
def normlize_docstring(yaml_content: dict) -> dict:
    """Нормализация комментариев."""
    process_info(yaml_content)
    for module in yaml_content.get('modules', []):
        process_info(module)

        for cmd in module.get('cmds', []):
            process_info(cmd)

            for param in cmd.get('params', []):
                process_info(param)

        for key in ('tms', 'events', 'types'):
            for item in module.get(key, []):
                process_info(item)

    return yaml_content


class YamlTreeParserSingle(YamlTreeParser):

    @staticmethod
    def _cmp(a, b):
        if 'import' not in a and 'import' not in b:
            return 0
        if 'import' not in a and 'import' in b:
            return -1
        if 'import' in a and 'import' not in b:
            return 1
        if 'import' in a and 'import' in b:
            if b['name'] in a['import']:
                return 1
            elif a['name'] in b['import']:
                return -1
            else:
                return len(a['import']) - len(b['import'])

    def __init__(self, yamlfileobject):
        self.alltypes = Types()
        self.alltypes.addBaseTypes()
        self.modules = []
        self.devices = []

        raw_file_content = yamlfileobject.read()
        file_content = normalize_device_file(raw_file_content)
        ym = oyaml.load(file_content, Loader=CustomLoader)
        ym = normalize_modules(ym)
        ym = normlize_docstring(ym)

        sorted_list = sorted(ym["modules"], key=cmp_to_key(YamlTreeParserSingle._cmp))

        # Сначала резолвим все типы во всех модулях
        for i in sorted_list:
            name = i['name'].replace('\\', '/').split('/')
            self.modules.append(Module(i, name, self.alltypes))

        # Загружаем все остальное
        for yaml, module in zip(sorted_list, self.modules):
            module.load(alltypes=self.alltypes)
        self.alltypes.resolve()

        for i in self.modules:
            i.resolve(self.modules)

        self.devices.append(Device(ym, self.alltypes, self.modules))


def generate_interface(input_filename, outdir, file_type, **kwargs):
    """Генерация pygen файлов в директории outdir."""
    logger.info(f'Generation started for {input_filename}')

    target_file = None
    if file_type == InputFileType.yaml_file:
        target_file = open(input_filename, mode="r", encoding=encoding)
    elif file_type == InputFileType.zpaq_file:
        with open(input_filename, mode="rb") as zpaq_f:
            yaml_txt = zpaq.decompress(zpaq_f.read()).decode(encoding)
        target_file = io.StringIO(yaml_txt)

    if target_file is not None:
        parser = YamlTreeParserSingle(target_file)
        full_out_dir = stw_python_gen.generateScripts(
            parser, outdir, input_file_info(input_filename), **kwargs,
        )

    target_file.seek(0)
    yaml_txt = target_file.read()
    with pathlib.Path(full_out_dir).joinpath('firmware.yml').open('w', encoding='utf-8') as file:
        file.write(yaml_txt)
    with pathlib.Path(full_out_dir).joinpath('firmware.zpaq').open('wb') as file:
        file.write(zpaq.compress(yaml_txt.encode(encoding)))

    gen_directory = os.path.abspath(outdir)
    for device in parser.devices:
        logger.info(f'Done for {device.name}. Results in: {gen_directory}')


def input_file_info(input_filename) -> str:
    """Описание исходных данных для генерации."""
    now_timestamp = now_split_str()
    gen_name = 'stw-py-api-generator'
    gen_version = pkg_resources.get_distribution(gen_name).version
    path = pathlib.Path(input_filename)
    file_name = path.name

    with open(path, 'rb') as input_file:
        file_bytes = input_file.read()
        crc = hashlib.sha3_512(file_bytes).hexdigest()

    txt = (f'Сгенерирован при помощи пакета {gen_name}.\n'
           f'Версия: {gen_version}\n'
           f'Дата: {now_timestamp}\n\n'
           f'Использовать с брокерами и рантаймом версии {gen_version} или только с сохранением мажорной версии.\n\n'
           f'Исходный файл: {file_name}. sha3_512: {crc}\n'
           f'Репозиторий проекта: https://gl.1440.space/sat/rig/core/stw-py-api/stw-py-api-engine\n'
           f'Документация: https://gl.1440.space/sat/rig/core/stw-py-api/stw-py-api-engine/README.md')

    return txt


class InputFileType(str, Enum):
    """Варианты форматов входных файлов."""
    zpaq_file = 'zpaq'
    yaml_file = 'yaml'
    auto = 'auto'


def normalalize_opt_root(optional_root: str):
    """Optional root pcoressing."""
    # учитывает что путь может начинаться с `./` `.\\` `/` `\\`
    optional_root = re.sub(r'^\.\/|^\.\\', '', optional_root)
    # заменяет остальные слешы на точки
    optional_root = re.sub(r'[\\/]', '.', optional_root)

    if optional_root.endswith('.'):
        optional_root = optional_root[:-1]

    return optional_root


def main(
    file_name: str = typer.Argument(None, help='input file name'),
    out_dir: str = typer.Argument(None, help='output folder'),
    file_type: InputFileType = typer.Option(InputFileType.auto),
    optional_root: str = typer.Option('', help='create optional root directory'),
    packet: str = typer.Option('', help='packet name'),
    packet_description: str = typer.Option('', help='description for packet'),
    packet_version: str = typer.Option('0.0.0', help='packet version'),
    pypi_reg: str = typer.Option(None, help='pypi repository reference'),
    force_pygen: bool = typer.Option(False, help='delete old pygen if it exist'),
):
    if optional_root:
        optional_root = normalalize_opt_root(optional_root)

    if file_type == InputFileType.auto:
        _, file_extension = os.path.splitext(file_name)
        extension_map = {
            '.yml': InputFileType.yaml_file,
            '.zpaq': InputFileType.zpaq_file,
        }
        file_type = extension_map[file_extension]

    if packet:
        generate_interface(file_name, out_dir, file_type, packet=packet, force_pygen=force_pygen)
        packet_info = {
            'name': packet,
            'description': packet_description,
            'version': packet_version,
            'pypi_registry': f'"{pypi_reg}"' if pypi_reg else f'"{pipy_registry}"',
            'versioning': 'true' if versioning else 'false',
            'runtime_version': f"'{version('stw_py_api_generator')}'"
        }
        create_packet(packet_info, out_dir)
    else:
        generate_interface(
            file_name,
            out_dir,
            file_type,
            root_dir=optional_root,
            force_pygen=force_pygen,
        )


def create_packet(packet_info, out_dir):
    """Создание пакета с настройками packet_info в директории out_dir."""
    os.makedirs(out_dir, exist_ok=True)
    if not packet_info['description']:
        now = now_str()
        packet_info['description'] = f'Generated at {now}'

    packet_info['packages'] = list_folders(out_dir)

    toml_src_path = os.path.join(builder_dir, 'template.pyproject.toml')
    with open(toml_src_path, 'rt', encoding=encoding) as toml_src:
        txt = toml_src.read()
        for var_name, var_value in packet_info.items():
            txt = txt.replace(f'{{{{{var_name}}}}}', var_value)
    toml_path = os.path.join(out_dir, 'pyproject.toml')
    with open(toml_path, 'tw', encoding=encoding) as toml_res:
        toml_res.write(txt)


def list_folders(directory):
    """Список packages по именам всех папок в указанной директории."""
    directories = [
        some_path for some_path in os.listdir(directory)
        if os.path.isdir(os.path.join(directory, some_path))
    ]
    lines = [f'{{ include = "{dir_one}" }}' for dir_one in directories]
    return ',\r\n\t'.join(lines)


def typer_main():
    """Точка входа для script подхода."""
    typer.run(main)


def direct_call(*args, **kwargs):
    """Функция для вызова main-a из python кода.

    Arg-и передаются напрямую, kwarg-и преобразуются в --kwarg-name kwarg-value.
    """
    arg_list = [
        str(arg) for arg in args
    ]
    for kwarg_name, kwarg_value in kwargs.items():
        norm_name = kwarg_name.replace('_', '-')
        arg_list.extend(
            [f'--{norm_name}', str(kwarg_value)],
        )
    app = typer.Typer()
    app.command()(main)
    app(arg_list)


if __name__ == '__main__':
    typer.run(main)
