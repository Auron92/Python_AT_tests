"""Работа с именами классов, папок и пр."""
from os import path
from typing import Generator, Optional

from stw_py_api_generator.legacy.stw_yaml_gen import Module
from stw_py_api_generator.python_classes.generic import PythonClass, PythonModule


def _snake_to_upper_generator(string: str) -> Generator[str, None, None]:
    """Убирает все underscore и символы после underscore - большие."""
    next_upper = True
    for letter in string:
        if letter == '_':
            next_upper = True
            continue
        if next_upper:
            next_upper = False
            yield letter.upper()
        else:
            yield letter.lower()


def snake_to_upper(string: str) -> str:
    """Преобразование snake_case к UpperCamelCase."""
    return ''.join(_snake_to_upper_generator(string))


def special(letter: str) -> bool:
    """Check if letter is special char."""
    return letter in '.,_'


def upper_to_snake(class_name: str) -> str:
    """Преобразование UpperCamelCase к snake_case. AbcDef -> abc_def.py."""
    if class_name:
        class_name = class_name[0].lower() + class_name[1:]
    fragments = [
        letter if letter.islower() or special(letter)
        else f'_{letter.lower()}'
        for letter in class_name
    ]
    if not fragments:
        raise ValueError('invalid class_name')
    return ''.join(fragments)


def dotted_to_snake(name: str) -> str:
    """Привести имя some.module.name к some_module_name."""
    return name.replace('_', '__').replace('.', '_')


def snake_to_dotted(name: str) -> str:
    """Привести имя some_module_name к some.module.name."""
    return name.replace('_', '.').replace('..', '_')


def name_to_snake_case(name: str) -> str:
    """Преобразование some-package-name1.2.3 к some_package_name1_2_3."""
    raw_name_parts = name.split('-')
    name_parts = []

    for part in raw_name_parts:
        part = '_'.join(part.split('.')) if '.' in part else part
        name_parts.append(part)

    return '_'.join(name_parts)


def class_filename(python_class: PythonClass) -> str:
    """AbcDef -> abc_def.py"""  # noqa: D403, D400
    if python_class.custom_file_name:
        snake = python_class.custom_file_name
    else:
        last_word = python_class.name.split('.')[-1]
        snake = upper_to_snake(last_word)
    return f'{snake}.py'


def module_folder(module: PythonModule, base_path=None) -> path:
    """Папка для модуля."""
    path_items = module.full_name.split('.')
    folder_path = path.join(*path_items)
    if base_path is None:
        return folder_path
    return path.join(base_path, folder_path)


def self_class_name(
    module: PythonModule | str, packet_name: str | None = None,
) -> str:
    """Получить имя self-класса для модуля с полным путём module_name."""
    if isinstance(module, str):
        module_name = module
    else:
        module_name = module.name
    last_segment = module_name.split('.')[-1]
    class_name = snake_to_upper(last_segment)
    if packet_name is not None:
        return f'{packet_name}.{module}.{class_name}'
    packet_name = module.packet.name
    return f'{packet_name}.{module_name}.{class_name}'


def self_class_item_name(module: PythonModule) -> str:
    """Имя переменной для перехода по имени модуля."""
    class_name = self_class_name(module)
    last_word = class_name.split('.')[-1]
    return upper_to_snake(last_word)


def last_word(sentence: str) -> str:
    """Последнее слово из разделённых точкой."""
    return sentence.split('.')[-1]


def relative_import(packet: PythonModule, module: Module, some_type: str) -> str:
    """Текст импорта ret_type относительно модуля module."""
    if some_type == 'None':
        return ''

    mod_path = module.path
    if some_type.startswith(mod_path):
        start = len(mod_path)
        rel_path = some_type[start + 1:]
        place = upper_to_snake(rel_path)
        return f'from .{place} import {rel_path}'

    # импорт делаем с именем пакета
    some_type_elements = some_type.split('.')
    base_path = '.'.join(some_type_elements[:-1])
    some_type_name = some_type_elements[-1]
    return f'from {packet.name}.{base_path} import {some_type_name}'


def is_system_type_name(type_name: str) -> bool:
    """Относится ли этот тип к системным."""
    return type_name in {'int', 'float', 'bool'}


def command_name_to_upper(command_name: str) -> str:
    """Преобразование типа timePeriods к TimePeriods."""
    return command_name[0].upper() + command_name[1:]


def base_import_path(packet_name: str, root_name: Optional[str]) -> str:
    """Получить базовый путь импорта в зависимости от целевой папки генерации."""
    return f'{root_name}.{packet_name}' if root_name else packet_name
