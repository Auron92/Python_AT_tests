"""Определение переходов на следующие уровни."""
from typing import Generator, List

from stw_py_api_generator import naming
from stw_py_api_generator.custom_types import ModuleRegistry
from stw_py_api_generator.python_classes.generic import PythonModule
from stw_py_api_generator.python_classes.next_level_item import NextLevelItem


def nested_modules(
    registry: ModuleRegistry, py_module: PythonModule,
) -> Generator[PythonModule, None, None]:
    """Модули, вложенные непосредственно в модуль py_module."""
    for _, reg_module in registry.items():
        if reg_module.full_name.startswith(f'{py_module.full_name}.'):
            reg_level = reg_module.full_name.count('.')
            mod_level = py_module.full_name.count('.')
            if reg_level == mod_level + 1:
                yield reg_module


def _import_for_class_name(class_name: str) -> str:
    """Строка импорта для полного имени класса."""
    words = class_name.split('.')
    first_part = words[-2]
    second_part = words[-1]
    return f'from .{first_part} import {second_part}'


def next_modules(
    registry: ModuleRegistry, py_module: PythonModule,
) -> List[NextLevelItem]:
    """Переходы к вложенным модулям."""
    next_items = [
        NextLevelItem(
            class_name=naming.self_class_name(module).split('.')[-1],
            item_name=naming.self_class_item_name(module),
            import_string=_import_for_class_name(
                naming.self_class_name(module),
            ),
        )
        for module in nested_modules(registry, py_module)
    ]
    imports = {nl_item.import_string for nl_item in next_items}
    py_module.self_class.imports = py_module.self_class.imports.union(imports)
    return next_items


def next_classes(
    registry: ModuleRegistry, py_module: PythonModule,
) -> List[NextLevelItem]:
    """Переходы к классам модуля."""


def build_next_levels(registry: ModuleRegistry):
    """Переходы должны быть у.

    1. self-класса для перехода к каждому следующему self-классу.
    2. self-класса для перехода к каждому классу этого модуля
    """
    for _module_path, py_module in registry.items():
        self_class = py_module.self_class
        if self_class is not None:
            self_class.next_levels.extend(
                next_modules(registry, py_module),
            )
