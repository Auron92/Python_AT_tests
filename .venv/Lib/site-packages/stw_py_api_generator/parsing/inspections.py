"""Анализ и обработка данных из registry и парсера."""
import re
from typing import List

from stw_py_api_generator import naming
from stw_py_api_generator.custom_types import ModuleRegistry
from stw_py_api_generator.legacy.stw_yaml_gen import CmdTm, CmdTmParam, TypeWrapper
from stw_py_api_generator.python_classes.generic import PythonClass, PythonModule


def update_registry_modules(
    registry: ModuleRegistry, module_name: str, packet: PythonModule,
) -> None:
    """Создание не существующих модулей для имени X.Y.Z."""
    current = packet.name
    for sub_name in module_name.split('.'):
        parent = registry.get(current, packet)
        current = f'{current}.{sub_name}' if current else sub_name
        class_name = naming.last_word(
            naming.self_class_name(current, packet.name),
        )
        if current not in registry:
            registry[current] = PythonModule(
                parent=parent,
                name=sub_name,
                classes=[],
                self_class=PythonClass(
                    is_self_class=True,
                    name=class_name,
                    creatable=True,
                ),
                packet=packet,
            )


def module_from_registry(
    registry: ModuleRegistry, module_name: str, packet: PythonModule,
) -> PythonModule:
    """Получить PythonModule из registry. Если его нет - создаётся."""
    full_module_name = f'{packet.name}.{module_name}'
    if full_module_name not in registry.keys():
        update_registry_modules(registry, module_name, packet)

    return registry[full_module_name]


def _command_rep_array(command: CmdTm) -> List[TypeWrapper]:
    """В качестве rep может быть один объект. Тогда из него делаем массив."""
    if isinstance(command.rep, list):
        return command.rep
    return [command.rep]


def _increase_type_name(type_name):
    if re.fullmatch(r'.*\d+\b', type_name):
        type_name_base = re.split(r'\d+\b', type_name)
        index = type_name.split(type_name_base[0])[1]
        new_index = int(index) + 1
        return f'{type_name_base[0]}{new_index}'
    return f'{type_name}1'


def _get_type_from_import_string(import_str):
    return import_str.split('import ')[1].split(' as ')[-1]


def _get_raw_import(import_str):
    return import_str.split(' as ')[0]


def _check_import_collision(imports, import_to_add):
    raw_import = _get_raw_import(import_to_add)
    type_to_add = _get_type_from_import_string(import_to_add)
    prepared_import = import_to_add
    for existing_import in imports:
        actual_existing_type = _get_type_from_import_string(existing_import)
        if type_to_add == actual_existing_type:
            new_type_name = _increase_type_name(type_to_add)
            prepared_import = f'{raw_import} as {new_type_name}'
            prepared_import = _check_import_collision(
                imports, prepared_import,
            )
    return prepared_import


def _actualize_imports(   # noqa: WPS210
    packet: PythonModule, module, cmd_tm_param: CmdTmParam, imports,
) -> None:
    """Добавить импорт в коллекцию, если его там нет."""
    is_system = cmd_tm_param.type.type.kind == 'system'
    if is_system:
        return  # для системных типов дополнительные импорты не нужны

    # не нужно делать импорт, если тип в том же модуле
    type_module = cmd_tm_param.type.type.name.module
    current_module = module.name
    if type_module == current_module:
        return

    arg_type_module = cmd_tm_param.type.type.name.module
    arg_type_name = cmd_tm_param.type.name.name
    full_type = (
        f'{arg_type_module}.{arg_type_name}'
    )

    relative_import = naming.relative_import(packet, module, full_type)
    if relative_import not in imports:
        prepared_import = _check_import_collision(imports, relative_import)
        if relative_import != prepared_import:
            arg_alias = prepared_import.split(' as ')[1]
            cmd_tm_param.type.name.alias = arg_alias
        imports.add(prepared_import)


def prepare_to_as_import(orig_variable_name: str, orig_import: str, import_parts: list):
    """Преобразовать импорт переменной в as импорт.

    from obcu.sat.mode.binding.activation_params_type import ActivationParams
    ->
    from obcu.sat.mode.binding.activation_params_type import ActivationParams as ObcuSatModeBindingActivationParams

    Возвращает полное имя из as и сам импорт.
    """
    full_variable_name = naming.snake_to_upper('_'.join(import_parts)) + orig_variable_name
    as_import = orig_import + f' as {full_variable_name}'  # noqa: WPS336
    return full_variable_name, as_import
