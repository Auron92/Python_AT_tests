"""Классы и функции для создания команд."""
from dataclasses import dataclass, field
from typing import List

from stw_py_api_generator import naming
from stw_py_api_generator.build_python_code.types.manipulation import py_basic_data_types
from stw_py_api_generator.c_types import double_float_like, int_like, single_float_like
from stw_py_api_generator.python_classes.generic import PythonClass


@dataclass
class CommandSenderClass(PythonClass):
    """Типовой класс с созданием переходов по модулям внутри cmds."""

    next_level: List[str] = field(default_factory=list)

    def __post_init__(self):
        self.name = 'CommandSender'


def _types_from_cmd_args(method):
    types = []

    without_imports = [
        *py_basic_data_types,
        *int_like,
        *single_float_like,
        *double_float_like,
        'bool_type',
        'bytes_type',
        'string',
    ]

    for arg in method.args:
        if arg.argument_type not in without_imports:
            types_in_hint = arg.argument_type_hint.split(' | ')
            import_types_classes = ', '.join(types_in_hint)
            type_desc = arg.type_module_name, naming.upper_to_snake(arg.argument_type), import_types_classes
            types.append(type_desc)
    return types


def _used_custom_types_from_cmds(methods):
    types = []
    for method in methods:
        types.extend(_types_from_cmd_args(method))
    return types


def imports_for_cmds(methods):
    """Множество строк - импортов типов для команд."""
    types = _used_custom_types_from_cmds(methods)
    return {
        'from gen_device.types.{modules}.{file_name}_type import {self_name}'.format(
            modules=type_[0],
            file_name=type_[1],
            self_name=type_[2],
        ) for type_ in types
    }
