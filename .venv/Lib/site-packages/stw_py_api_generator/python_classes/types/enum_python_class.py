"""Описание типа enum."""
from dataclasses import dataclass, field
from typing import List, Set, TypedDict

from stw_py_api_generator import naming
from stw_py_api_generator.build_python_code.types.manipulation import type_description, unwrap
from stw_py_api_generator.legacy.stw_yaml_gen import TypeEnum
from stw_py_api_generator.python_classes.generic import PythonClass, TypePythonClass
from stw_py_api_generator.python_classes.types.struct_python_class import import_string


class EnumItem(TypedDict):
    """Одна строка внутри Enum-a."""

    name: str
    value: str
    info: str


class TypeInfo(TypedDict):
    """Класс, от которого зависит этот Enum: IntEnum, Enum, StrEnum и т.п."""

    name: str
    import_string: str


@dataclass
class EnumPythonClass(TypePythonClass):
    """Класс для создания типа enum."""

    enum_items: List[EnumItem] = field(default_factory=list)
    base_type: str | None = None

    @classmethod
    def from_yaml_type(cls, enum_type: TypeEnum) -> PythonClass:
        """Конструирование из yaml описания."""
        name = enum_type.name.name
        file_name = naming.upper_to_snake(name)
        real_type = unwrap(enum_type)

        parent_type = _parent_type(real_type)
        base_type = _base_type(real_type)

        return cls(
            name=name,
            docstring=enum_type.info,
            custom_file_name=f'{file_name}_type.py',
            imports=_imports(base_type, parent_type),
            enum_items=_enum_items(real_type),
            base_type=base_type['name'],
        )


def _imports(base_type: TypeInfo, parent_type: TypeInfo) -> Set[str]:
    return {
        type_info['import_string']
        for type_info in (base_type, parent_type)
        if type_info['import_string']
    }


def _parent_type(enum_type: TypeEnum) -> TypeInfo:
    """Тип, от которого наследуется текущий Enum."""
    base_name = unwrap(enum_type.base).name.name
    int_enum = {
        'name': 'enum.IntEnum', 'import_string': 'import enum',
    }
    if base_name.startswith('uint'):
        return int_enum
    if base_name.startswith('int'):
        return int_enum
    raise NotImplementedError(base_name)


def _enum_items(enum_type: TypeEnum) -> List[EnumItem]:
    return [
        {
            'name': value.name,
            'value': value.value,
            'info': value.info or '',
        }
        for value in enum_type.values
    ]


def _base_type(enum_type: TypeEnum) -> TypeInfo:
    """Тип, общий для всех элементов enum-a."""
    base = unwrap(enum_type.base)
    desc = type_description(base)

    return {
        'name': desc['type_name'],
        'import_string': import_string(base),
    }
