"""Базовые классы для генерации кода."""
from dataclasses import dataclass, field
from typing import List, Optional, Set

from stw_py_api_generator.python_classes.next_level_item import NextLevelItem


@dataclass
class MethodArgument(object):
    """Аргумент метода."""

    argument_name: str
    argument_type: str
    # type_hint может отличаться от типа
    # это используется для всяких u8, что бы использовать просто int
    argument_type_hint: str
    docstring: str
    is_enum: bool
    type_module_name: str

    @property
    def argument_type_repr(self):
        """Forward declaration должны быть обернуты в кавычки."""
        return f"'{self.argument_type}'"


@dataclass
class PythonMethod(object):
    """Информация о методе."""

    docstring: str = ''
    module_name: str = ''
    method_name: str = ''
    args: List[MethodArgument] = field(default_factory=list)
    return_type: List[str] = field(default_factory=lambda: ['None'])
    req_type: str = ''
    rep_type: str = ''
    msg_id: int | None = None
    rep_id: int | None = None
    method_path: str = ''
    gen_req_type: bool = False


@dataclass
class PythonClass(object):
    """Информация о классе для генерации кода."""

    name: str = ''
    docstring: str = ''
    base_classes: List[str] = field(default_factory=list)
    imports: Set[str] = field(default_factory=set)
    methods: List[PythonMethod] = field(default_factory=list)
    custom_file_name: str = ''
    packet: Optional['PythonModule'] = None
    # deprecated ?
    next_levels: List[NextLevelItem] = field(default_factory=list)
    is_self_class: bool = False  # True - это класс для перехода к модулю
    creatable: bool = False


@dataclass
class BasicTypeClass(object):
    """Класс под "встроенные" типы. int16, uint32 и т.п."""

    class_name: str
    is_signed: bool
    is_float: bool
    bit_size: int
    inherent_from: str


@dataclass
class VarIntTypeClass(object):
    """Класс под "встроенные" типы. varint16, varuint32 и т.п."""

    class_name: str
    bit_size: int
    is_signed: bool
    inherent_from: str


@dataclass
class PythonModule(object):
    """Исходные данные для генерации python модуля."""

    name: str
    parent: Optional['PythonModule'] = None  # noqa: WPS462
    packet: Optional['PythonModule'] = field(default=None)  # noqa: WPS462
    classes: List[PythonClass] = field(default_factory=list)
    root_dir_name: str = ''
    self_class: PythonClass | None = None
    init_file_content: str = ''
    is_root_module: bool = False

    @property
    def full_name(self):
        """Полное имя модуля."""
        full_name = self.name
        parent = self.parent
        while parent is not None:
            full_name = f'{parent.name}+{full_name}'
            parent = parent.parent
        return full_name

    @property
    def name_by_yaml(self):
        """Имя модуля как в yaml описании."""
        full_name = self.name
        parent = self.parent
        while parent is not None:
            if not (parent.name == 'types' or parent.is_root_module):
                full_name = f'{parent.name}.{full_name}'
            parent = parent.parent
        return full_name

    @property
    def original_name(self):
        """Полное имя как в описании."""
        raw_names = self.full_name.split('+')
        names = []
        for name in raw_names:
            if name.endswith('_module'):
                names.append(name.partition('_module')[0])
        return '.'.join(names)

    @property
    def self_import_name(self):
        """Это имя, которое можно использовать в import-е собственных типов."""
        if self.root_dir_name:
            return f'{self.root_dir_name}.{self.full_name}'
        return self.full_name

    def __str__(self):
        return self.full_name

    def __repr__(self):
        return self.__str__()


@dataclass
class TypesItem(object):
    """Упоминание типа внутри Types."""

    type_module: str
    type_name: str
    name: str
    docstring: str = ''


@dataclass
class TypePythonClass(PythonClass):
    """Класс внутри gen_device.types."""

    inner_types: List['TypesItem'] = field(default_factory=list)
