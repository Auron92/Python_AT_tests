"""Генерация ТМИ и событий."""
from collections import defaultdict

from stw_py_api_generator.build_python_code.yaml_utils import find_parent, next_level_names
from stw_py_api_generator.naming import last_word, snake_to_upper
from stw_py_api_generator.parsing.yml_file_parser import DummyYamlModule
from stw_py_api_generator.python_classes.cfg import CfgPythonClass, CfgRootPythonClass, cfg_from_yaml_module
from stw_py_api_generator.python_classes.events import EventsPythonClass, EventsRootPythonClass, events_from_yaml_module
from stw_py_api_generator.python_classes.general import types_imports
from stw_py_api_generator.python_classes.generic import PythonModule
from stw_py_api_generator.python_classes.tms import TmsPythonClass, TmsRootPythonClass, tms_from_yaml_module

_obj_type_params_map = {
    'cfg': {
        'root_module_name': 'cfg',
        'root_py_class': CfgRootPythonClass,
        'py_class': CfgPythonClass,
        'custom_file_name': 'cfg.py',
        'gen_items_func': cfg_from_yaml_module,
    },
    'tms': {
        'root_module_name': 'tms',
        'root_py_class': TmsRootPythonClass,
        'py_class': TmsPythonClass,
        'custom_file_name': 'tm.py',
        'gen_items_func': tms_from_yaml_module,
    },
    'events': {
        'root_module_name': 'events',
        'root_py_class': EventsRootPythonClass,
        'py_class': EventsPythonClass,
        'custom_file_name': 'events.py',
        'gen_items_func': events_from_yaml_module,
    },
}


def build_modules(yaml_module_map: dict, device_module: PythonModule, objects_type: str):
    """Добавить модули к карте модулей."""
    module_map = defaultdict(list)
    module_params_map = _obj_type_params_map[objects_type]

    # создание основной карты
    root_module = PythonModule(name=module_params_map['root_module_name'], parent=device_module)
    root_class = module_params_map['root_py_class']
    root_py_class = root_class(
        custom_file_name=module_params_map['custom_file_name'],
        next_levels=[module.name for module in yaml_module_map[0]],
    )
    root_module.classes.append(root_py_class)
    module_map[0].append(root_module)
    next_level_module = PythonModule(name='next_level', parent=root_module)
    module_map[1].append(next_level_module)

    if yaml_module_map:
        inner_modules_map = build_inner_modules(
            yaml_module_map, module_params_map, next_level_module,
        )
        add_inner_to_module_map(module_map, inner_modules_map)

    return module_map


def build_inner_modules(yaml_module_map, module_params_map, next_level_module):
    """Создание вложенных модулей."""
    max_level = max(yaml_module_map.keys())
    inner_modules_map = defaultdict(list)

    for level in range(max_level + 1):
        yaml_modules = yaml_module_map[level]
        for yaml_module in yaml_modules:
            add_level(
                yaml_module_map, level, yaml_module, inner_modules_map, next_level_module, module_params_map,
            )

    return inner_modules_map


def add_inner_to_module_map(module_map, inner_modules_map):
    """Добавление вложенных модулей в основную карту."""
    for level, inner_items in inner_modules_map.items():
        module_map[level + 2].extend(inner_items)


def add_level(  # noqa: WPS211, WPS317
    yaml_module_map: dict, level: int, yaml_module: DummyYamlModule, module_map: dict, parent: PythonModule,
    module_params_map: dict,
):
    """
    Генерация модуля с переходом next_level во вложенный модуль и класса.

    Есть 'core.can' путь.
    Для yaml_module='core' создаются:
        core_module - модуль с переходом на вложенные модули через next_level
        core.py - файл, содержащий класс с переходам can в can_module
        внутри core_module - модуль next_level - для переходов
    """
    # *2, т.к. в module_map на каждый yaml module создается два - module и его next_module
    map_level = level * 2
    name = yaml_module.name
    last_word_name = last_word(name)

    # Создание модуля
    my_module = PythonModule(
        name=f'{last_word_name}_module',
        parent=find_parent(name, level, module_map, parent),
    )
    next_level_module = PythonModule(
        name='next_level',
        parent=my_module,
    )
    module_map[map_level].append(my_module)
    module_map[map_level + 1].append(next_level_module)

    class_items = module_params_map['gen_items_func'](yaml_module)

    # Создание класса внутри .py модуля
    my_class = module_params_map['py_class'](
        custom_file_name=f'{last_word_name}.py',
        next_levels=next_level_names(name, level, yaml_module_map),
        items=class_items,
        imports=types_imports(class_items),
    )
    my_module.parent.classes.append(my_class)


def get_import_path_and_name(entity_import: str, msg, attr_name, collision_names):
    """Получить путь импорта и название объекта."""
    imported_name = getattr(msg, attr_name)
    import_sub_str = imported_name
    modules = msg.module_name.split('.')
    sub_modules = modules[:-1]
    module = modules[-1]
    if sub_modules:
        sub_modules_str = '.'.join([f'{module}_module.next_level' for module in sub_modules])
        sub_modules_str = f'.{sub_modules_str}.'
    else:
        sub_modules_str = '.'

    if imported_name in collision_names:
        imported_name = snake_to_upper('_'.join(modules)) + imported_name
        import_sub_str += f' as {imported_name}'  # noqa: WPS336

    import_str = f'from gen_device.{entity_import}.next_level{sub_modules_str}{module} import {import_sub_str}'
    return import_str, imported_name


def get_imports(entity, msg, collision_names):
    """Получить импорты для сообщения в зависимости от его типа: команда, ТМ и т.д."""
    imports = set()

    if entity == 'tms':
        import_, _ = get_import_path_and_name(entity, msg, 'type_name', collision_names)
        imports.add(import_)

    elif entity in {'events', 'cfg'}:
        import_, _ = get_import_path_and_name(entity, msg, 'type_name', collision_names)
        imports.add(import_)

    elif entity == 'cmds':
        entity_import = f'{entity}.command_sender_module'
        req_import, req_type_name = get_import_path_and_name(entity_import, msg, 'req_type', collision_names)
        rep_import, rep_type_name = get_import_path_and_name(entity_import, msg, 'rep_type', collision_names)
        if msg.req_type != 'ReqMessage':
            imports.add(req_import)
        imports.add(rep_import)

    return imports
