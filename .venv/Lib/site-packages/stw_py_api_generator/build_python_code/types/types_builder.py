"""Генерация карты модулей для типов."""
from collections import defaultdict

from stw_py_api_generator import naming
from stw_py_api_generator.build_python_code import yaml_map_builder
from stw_py_api_generator.build_python_code.types import build_py_class
from stw_py_api_generator.build_python_code.types.manipulation import unwrap
from stw_py_api_generator.legacy.stw_yaml_gen import Types, TypeStruct
from stw_py_api_generator.python_classes.generic import PythonModule


def build_types(device, device_module):
    """Составить карту модулей для типов."""
    tm_yaml_map = yaml_map_builder.validated_yaml_module_map(
        device.modules, 'types',
    )
    return _types_module(tm_yaml_map, device_module)


def _types_module(yaml_map, parent):
    """Построение Python модуля types."""
    types_module = PythonModule(name='types', parent=parent)
    types_map = defaultdict(list)

    if not yaml_map:
        return {}

    max_level = max(yaml_map.keys())
    _add_inner_types(max_level, yaml_map, types_map, types_module)

    result_map = defaultdict(list)
    result_map[0].append(types_module)
    for level, types_items in types_map.items():
        result_map[level + 1].extend(types_items)
    return result_map


def _add_inner_types(max_level, yaml_map, types_map, types_module):
    """Добавить внутренние модули для типов."""
    for level in range(max_level + 1):
        for yaml_module in yaml_map[level]:
            py_module = _ensure_module_exists(level, yaml_module.name, types_map, types_module)
            for tm_type in _node_types(yaml_module):
                _add_type_class(py_module, tm_type)


def _add_type_class(module: PythonModule, tm_type: TypeStruct) -> None:
    real_type = unwrap(tm_type)
    py_class = build_py_class.from_yaml_type(real_type)
    module.classes.append(py_class)


def _ensure_module_exists(level, name, tm_map, zero_parent):
    """Создание модуля при необходимости."""
    new_module = PythonModule(
        name=naming.last_word(name),
        parent=_find_parent(name, level, tm_map, zero_parent),
    )
    if new_module not in tm_map[level]:
        tm_map[level].append(new_module)
    return new_module


def _find_parent(name, level, tm_map, zero_parent):
    """Родительский модуль для type yaml модуля из списка PythonModule-ей."""
    if level == 0:
        return zero_parent
    parent_module_name = name[:name.rfind('.')]
    py_level = level - 1

    possible_parents = [mod for mod in tm_map[py_level] if mod.name_by_yaml == parent_module_name]
    name_parent_map = {parent.name_by_yaml: parent for parent in possible_parents}

    for orig_parent_name, parent in name_parent_map.items():
        if orig_parent_name == parent_module_name:
            return parent


def _node_types(node) -> TypeStruct:
    if isinstance(node.types, Types):
        yield from node.types.types.values()
    return []
