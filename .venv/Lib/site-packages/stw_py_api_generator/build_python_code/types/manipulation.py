"""Базовые инструменты для работы с типами из yaml."""
from stw_py_api_generator.legacy.stw_yaml_gen import (
    Type, TypeArray, TypeBits, TypeEnum, TypeOptional, TypeString, TypeStruct, TypeSynonym, TypeSystem, TypeVariant,
    TypeVector, TypeWrapper,
)

py_basic_data_types = ('int', 'float', 'str', 'bytes', 'bool')


def unwrap(wrapped_type: TypeWrapper | Type) -> Type:
    """Вернуть вложенное описание типа из объекта."""
    if isinstance(wrapped_type, TypeWrapper):
        return unwrap(wrapped_type.type)
    return wrapped_type


def type_description(field_type):
    """Описание типа."""
    actual_type = unwrap(field_type)

    std_types = (
        TypeStruct, TypeEnum, TypeArray, TypeSynonym, TypeBits, TypeString, TypeOptional, TypeVector, TypeVariant,
    )
    if isinstance(actual_type, TypeSystem):
        return {
            'type_module': '',
            'type_name': c_to_python_type(actual_type.name.name),
        }
    elif isinstance(actual_type, std_types):
        type_name = actual_type.name
        return {
            'type_module': type_name.module,
            'type_name': type_name.name,
        }
    raise NotImplementedError(f'Тип не поддерживается: {actual_type}')


def c_to_python_type(type_name: str) -> str:  # noqa: C901, WPS212
    """Вернуть python тип данных, соответствующий C типу данных."""
    if type_name.startswith('uint'):
        return type_name
    if type_name.startswith('int'):
        return type_name
    if type_name.startswith('varuint'):
        return type_name
    if type_name.startswith('varint'):
        return type_name
    if type_name == 'float_type':
        return 'float_type'
    if type_name == 'double':
        return 'double'
    if type_name == 'bool_type':
        return 'bool_type'
    if type_name == 'char':
        return 'string'
    if type_name == 'string':
        return type_name
    if type_name == 'bytes_type':
        return 'bytes_type'
    raise ValueError(f'unsupported type name: {type_name}')
