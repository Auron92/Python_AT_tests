"""Создание файлов на основе сгенерированной карты."""
import os
import re
import shutil
from pathlib import Path
from typing import List, Set

import isort
import jinja2
from loguru import logger

from stw_py_api_generator import __file__ as module_file_path
from stw_py_api_generator.c_types import double_float_like, int_like, single_float_like, u_types, var_int_like
from stw_py_api_generator.custom_types import ModuleMap
from stw_py_api_generator.general import encoding
from stw_py_api_generator.jinja_renders.template_utils import jinja_globals
from stw_py_api_generator.jinja_renders.writers import write_class_file
from stw_py_api_generator.python_classes.generic import BasicTypeClass, PythonModule

module_path = os.path.dirname(module_file_path)
template_dir = os.path.join(module_path, 'templates')

gitignore_dir_names = {  # noqa: WPS317
    'build', 'config', 'cover', 'cython_debug', 'htmlcov', 'instance', 'target',
    'develop-eggs', 'dist', 'docs', 'downloads', 'eggs', 'env', 'site', 'var',
    'lib', 'lib64', 'parts', 'profile_default', 'reports', 'sdist', 'share', 'venv', 'wheels',
}


def make_files_by_map(
    base_path: os.path,
    module_map: ModuleMap,
    source_info: str,
    **kwargs,
):
    """Создание директорий и __init__ файлов для модулей."""
    root = module_map[0][0]
    # проход по увеличению level - дискуссионное решение
    root.init_file_content = '{doc_string}\r\n{original}'.format(
        doc_string=f'"""\r\n{source_info}\r\n"""',
        original=root.init_file_content,
    )
    if module_map.keys():
        max_level = max(module_map.keys()) + 1
    else:
        max_level = 0

    folder = os.path.join(base_path, str(root))
    if kwargs.get('force_pygen', False) and os.path.exists(folder):
        shutil.rmtree(folder)
        logger.warning(f'Папка {folder} была удалена для генерации новой прошивки. См. флаг --force-pygen')

    for level in range(max_level + 1):
        for lvl_module in module_map[level]:
            _create_module_files(base_path, lvl_module, root, **kwargs)

    _check_gitignore_dir_names(module_map)

    return os.path.abspath(folder)


def _collect_conflicting_dir_names(module_map: ModuleMap, gitignore_names: Set[str]) -> Set[str]:
    """Сбор имён директорий, конфликтующих с .gitignore."""
    dir_names = set()
    for level_modules in module_map.values():
        for module in level_modules:
            dir_names.update(_get_conflicting_names(module, gitignore_names))
    return dir_names


def _get_conflicting_names(module: PythonModule, gitignore_names: Set[str]) -> Set[str]:
    """Возвращает множество имён, конфликтующих с .gitignore для данного модуля."""
    conflicting_names = set()
    folder_path_parts = _parent_names(module) + [module.name]
    for dir_name in folder_path_parts:
        dir_name_lower = dir_name.lower()
        if dir_name_lower in gitignore_names:
            conflicting_names.add(dir_name_lower)
    return conflicting_names


def _check_gitignore_dir_names(module_map: ModuleMap):
    """Проверка имён директорий на совпадение с .gitignore."""
    dir_names = _collect_conflicting_dir_names(module_map, gitignore_dir_names)
    root_module = module_map[0][0]
    root_name_lower = root_module.name.lower()
    if root_name_lower in gitignore_dir_names:
        dir_names.add(root_name_lower)
    if dir_names:
        conflicts = ', '.join(f"'{name}'" for name in sorted(dir_names))  # noqa: WPS221
        logger.warning(
            f'Следующие имена директорий часто встречаются в .gitignore и могут вызвать конфликты: {conflicts}. ',
        )


def _create_module_files(base_path, module: PythonModule, root: PythonModule, **kwargs):
    """Создать файлы модулей."""
    # folder
    folder_path = os.path.join(base_path, *_parent_names(module), module.name)
    os.mkdir(folder_path)
    root.root_dir_name = kwargs.get('root_dir')

    # init file
    init_path = os.path.join(folder_path, '__init__.py')
    with open(init_path, 'wt', encoding=encoding) as ini_file:
        ini_file.write(module.init_file_content)

    # class files
    for class_one in module.classes:
        file_name = class_one.custom_file_name or class_one.name
        if not file_name:
            raise ValueError(f'empty class name for {class_one}')
        class_file_path = os.path.join(folder_path, file_name)
        write_class_file(class_one, class_file_path, root)


def _parent_names(module: PythonModule, parent_list=None):
    """Массив имён всех родителей."""
    if parent_list is None:
        parent_list = []
    if module.parent is None:
        return parent_list
    parent_list.insert(0, module.parent.name)
    return _parent_names(module.parent, parent_list)


def make_basic_type_files(module_map, out_dir: str):
    """Создание файла, содержащего описание "системных" типов из Си."""
    basic_types_desc: List[BasicTypeClass] = []

    float_type = set(single_float_like + double_float_like)
    types = set(int_like + var_int_like + u_types) | float_type
    inherents = dict.fromkeys(float_type, 'BaseFloat, Number')
    inherents.update(dict.fromkeys(var_int_like, 'VarIntBase, BaseInt'))
    inherents.update(dict.fromkeys(int_like + u_types, 'BaseInt, Number'))

    for type_name in types:
        normalized_name = type_name.replace('_', '') if type_name not in float_type else type_name
        is_float = type_name in float_type
        basic_types_desc.append(
            BasicTypeClass(
                class_name=type_name,
                is_signed=_is_signed(normalized_name),
                is_float=is_float,
                bit_size=_bit_size(normalized_name),
                inherent_from=inherents[type_name],
            ),
        )
    basic_types_desc.sort(key=lambda class_obj: class_obj.class_name)
    _write_basic_type_file(module_map, out_dir, basic_types_desc)


def _is_signed(type_name: str) -> bool:
    """Проверить, является ли тип знаковым."""
    if type_name.startswith('i'):
        return True
    if type_name.startswith('u'):
        return False
    if type_name.startswith('vari'):
        return True
    if type_name.startswith('varu'):
        return False
    if type_name in {'double', 'f64', 'float_type', 'f32'}:
        return True
    raise ValueError('wrong name of basic type')


def _bit_size(type_name: str) -> int:
    """Размерность типа в битах. Определяется по цифре в названии."""
    bit_size_map = {
        'float_type': 32,
        'f32': 32,
        'double': 64,
        'f64': 64,
    }
    bit_size = bit_size_map.get(type_name)
    if not bit_size:
        pattern = re.compile(r'\d+')
        size = pattern.findall(type_name)
        bit_size = int(size[0])
    return bit_size


def _write_basic_type_file(
    module_map,
    out_dir: str,
    basic_types_desc: List[BasicTypeClass],
) -> None:
    """Записать файл с основными типами."""
    root_element = module_map[0][0]
    file_path = Path(out_dir) / f'{root_element.name}' / 'basic_types.py'
    data = {
        'classes': basic_types_desc,
    }
    file_content = _render(data, 'basic_types.py.jinja2')
    with open(file_path, 'wt') as file:
        file.write(file_content)


def write_map_file(module_map, out_dir: str, content, file_name: str, template_name: str) -> None:
    """Записать содержимое карты в файл."""
    root_element = module_map[0][0]
    file_path = Path(out_dir) / f'{root_element.name}' / file_name
    file_content = _render(content=content, jinja_template_name=template_name, make_isort=False)
    with open(file_path, 'wt', encoding='utf-8') as file:
        file.write(file_content)


def write_messages_map_file(module_map, out_dir: str, content) -> None:
    """Записать карту сообщений в файл."""
    write_map_file(module_map, out_dir, content, 'messages.py', 'messages_map.py.jinja2')


def write_entities_map_file(module_map, out_dir: str, content) -> None:
    """Записать карту сущностей в файл."""
    write_map_file(module_map, out_dir, content, 'entities.py', 'entities.py.jinja2')


def write_device_sim_file(module_map, out_dir: str, content) -> None:
    """Записать файл симулятора устройства."""
    write_map_file(module_map, out_dir, content, 'device_simulator.py', 'device_simulator.py.jinja2')


def _render(content, jinja_template_name: str, make_isort: bool = True):
    """Рендер содержимого с использованием Jinja2 шаблона."""
    template_path = os.path.join(template_dir, jinja_template_name)
    with open(template_path, 'rt') as file:
        template_txt = file.read()
        template = jinja2.Template(
            template_txt, trim_blocks=False, lstrip_blocks=False,
        )
        template.globals = jinja_globals
        code = template.render(content)
        if make_isort:
            code = isort.code(code)
        return code
