"""Генерация модуля для команд."""
from collections import defaultdict
from typing import Dict, List

from stw_py_api_generator import naming
from stw_py_api_generator.build_python_code.build_command import methods_from_yaml_module
from stw_py_api_generator.build_python_code.yaml_utils import find_parent, next_level_names
from stw_py_api_generator.custom_types import ModuleMap
from stw_py_api_generator.python_classes.cmds import CommandSenderClass, imports_for_cmds
from stw_py_api_generator.python_classes.generic import PythonModule


def add_cmds(yaml_map, module_map, parent):
    """Сгенерировать и добавить к карте модулей cmds (команды)."""
    cmds = _cmds_modules(yaml_map, parent)
    cmds_next_module = cmds[2][0]

    for level, modules in cmds.items():
        module_map[level].extend(modules)

    add_inner_cmds(yaml_map, module_map, cmds_next_module)


def add_inner_cmds(yaml_map, module_map, cmds_next_module):
    """Сгенерировать и добавить вложенные модули с командами к карте."""
    in_cmds_modules = build_cmd_modules(yaml_map, cmds_next_module)

    # parent для уровня 0
    if in_cmds_modules:
        for module in in_cmds_modules[0]:
            module.parent = cmds_next_module

    for level, modules in in_cmds_modules.items():
        module_map[level + 3].extend(modules)


def _cmds_modules(yaml_map, parent) -> ModuleMap:
    """Модуль cmds."""
    next_names = [module.name for module in yaml_map[0]]
    cmds_class = CommandSenderClass(
        next_levels=next_names, custom_file_name='command_sender.py',
    )
    cmds_module = PythonModule(
        name='cmds', parent=parent, classes=[cmds_class],
    )
    my_module = PythonModule(
        name='command_sender_module', parent=cmds_module,
    )
    cmds_next_module = PythonModule(name='next_level', parent=my_module)
    return {
        0: [cmds_module],
        1: [my_module],
        2: [cmds_next_module],
    }


def build_cmd_modules(yaml_map, packet) -> Dict[int, List[PythonModule]]:
    """Создание cmds модуля для gen_device."""
    py_modules = _cmd_modules(yaml_map, packet)
    return dict(py_modules)


def _cmd_modules(yaml_module_map, packet):
    """Создание PythonModule-ей по карте Yaml модулей."""
    py_modules = defaultdict(list)

    # итерация должна быть строго по увеличению уровня
    max_level = max(yaml_module_map.keys())
    for level in range(0, max_level + 1):
        for yaml_module in yaml_module_map[level]:
            _generate_module(
                level, yaml_module, yaml_module_map, py_modules, packet,
            )

    return py_modules


def _generate_module(level: int, yaml_module, yaml_module_map, py_modules, packet) -> None:  # noqa: WPS211, WPS210, E501
    """Генерация пары модулей (x_module и x_module/next_level)."""
    name = yaml_module.name
    parent = find_parent(name, level, py_modules, None)

    last_word = naming.last_word(name)
    module = PythonModule(name=f'{last_word}_module', parent=parent)
    nl_module = PythonModule(name='next_level', parent=module)

    # класс CommandSender-a. В нём будут "переходы" дальше
    # кладутся переходы в предыдущий уровень
    methods = methods_from_yaml_module(yaml_module)

    class_callback = CommandSenderClass

    new_class = class_callback(
        custom_file_name=f'{last_word}.py',
        next_levels=next_level_names(name, level, yaml_module_map),
        methods=methods,
        imports=imports_for_cmds(methods),
    )

    if parent is None:
        parent = packet
    parent.classes.append(new_class)

    py_modules[level * 2].append(module)
    py_modules[level * 2 + 1].append(nl_module)
