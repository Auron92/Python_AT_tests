"""Работа с деревом yaml элементов."""
from collections import defaultdict

from stw_py_api_generator import naming
from stw_py_api_generator.c_types import matched_system_type


def next_level_names(full_name, level, yaml_module_map):
    """Имена модулей на следующем модуле."""
    next_level_items = yaml_module_map[level + 1]
    full_next_names = [module.name for module in next_level_items]

    parent_names = [
        module_name[:module_name.rfind('.')]
        for module_name in full_next_names
    ]
    self_names = [
        module_name[module_name.rfind('.') + 1:]
        for module_name in full_next_names
    ]
    names = zip(parent_names, self_names)
    return [
        self_name
        for parent_name, self_name in names
        if parent_name == full_name
    ]


def _methods(yaml_module):
    """Список из пар: путь до метода и название метода."""
    return [(tm.module, tm.name) for tm in yaml_module.tms]


def find_parent(full_name, level, py_modules, zero_parent):
    """Родительский модуль для yaml модуля из списка PythonModule-ей."""
    if level == 0:
        return zero_parent

    parent_module_name = full_name.split('.')[-2]
    parent_module_name = f'{parent_module_name}_module'
    expected_parent_name = full_name[:full_name.rfind('.')]
    py_level = (level - 1) * 2 + 1

    possible_parents = [mod for mod in py_modules[py_level] if mod.parent.name == parent_module_name]
    name_parent_map = {parent.original_name: parent for parent in possible_parents}

    for orig_parent_name, parent in name_parent_map.items():
        if orig_parent_name == expected_parent_name:
            return parent


def get_type_import_map(imports):
    """Получить карту импортов, где ключ - короткое имя типа, значение - импорты с тем же именем."""
    imports_map = defaultdict(dict)

    for imp in imports:
        if not imp:
            continue
        sub_imp = imp.partition('.types.')[-1]
        full_path, _, type_name = sub_imp.partition('_type import ')
        upper_type_name = naming.upper_to_snake(type_name)
        module_path = sub_imp.rpartition(f'.{upper_type_name}')[0]
        imports_map[type_name][module_path] = imp

    return imports_map


def add_local_imports_to_tm_params(items, type_imports_map):
    """Добавить локальный импорт к ТМ параметру при наличии коллизии имен."""
    local_imports = set()

    for item in items:
        for param in item.params:
            collision = type_imports_map.get(param.param_type, None)
            if collision:
                new_import = collision[param.type_module_name]
                param.local_import = new_import
                local_imports.add(new_import)

    return local_imports


def add_local_imports_to_types(items, type_imports_map):
    """Добавить локальный импорт к типу при наличии коллизии имен."""
    local_imports = set()

    for item in items:
        collision = type_imports_map.get(item.type_name, [])
        if len(collision) > 1:
            new_import = collision[item.type_module]
            item.local_import = new_import
            local_imports.add(new_import)

    return local_imports


def get_type_items(inner_types, type_imports_map):
    """Подготовить объекты типов с их внутренними типами и импортами."""
    items = []

    for inner_type in inner_types:
        type_name = inner_type.type_name
        local_import = getattr(inner_type, 'local_import', '')

        if inner_type.name == inner_type.type_name:
            if not local_import:
                local_import = type_imports_map[inner_type.type_name][inner_type.type_module]

            type_name = f'{inner_type.type_name}_'
            local_import = f'{local_import} as {type_name}'

        item_data = {
            'name': inner_type.name,
            'type': type_name,
            'type_in_typed_dict': matched_system_type(inner_type.type_name),
            'docstring': inner_type.docstring,
            'local_import': local_import,
        }
        items.append(item_data)

    return items


def get_tms_items(inner_items, type_imports_map):
    """Подготовить объекты телеметрии с их типами и импортами."""
    for item in inner_items:
        process_item(item, type_imports_map)
    return inner_items


def process_item(item, type_imports_map):
    """Обрабатывает параметры каждого элемента."""
    local_imports_map = []
    local_import = getattr(item, 'local_import', '')
    for param in item.params:
        process_param(param, type_imports_map, local_import, local_imports_map)


def process_param(param, type_imports_map, local_import, local_imports_map):
    """Обрабатывает параметр, его типы и импорты."""
    if param.name == param.param_type:
        local_import = update_local_import(param, type_imports_map, local_import)
        param.param_type = f'{param.param_type}_'
        param.local_import = f'{local_import} as {param.param_type}'

    if hasattr(param, 'local_import'):  # noqa: WPS421
        handle_import_duplicates(param, local_imports_map)


def update_local_import(param, type_imports_map, local_import):
    """Обновляет локальный импорт для параметра."""
    if not local_import:
        local_import = type_imports_map[param.param_type][param.type_module_name]
    return local_import


def handle_import_duplicates(param, local_imports_map):
    """Управляет дубликатами локальных импортов."""
    if param.local_import in local_imports_map:
        param.local_import = ''
    local_imports_map.append(param.local_import)
