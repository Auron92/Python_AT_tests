"""
Обертка над PyGen девайсами.

Расширяет функционал Pygen классов без изменения методов.
Пытается вобрать в себя функции, которые ещё не добавлены или никогда не будут добавлены в py-api-engine.
"""

import json
import typing
from pathlib import Path
from time import sleep

import allure
from allure_commons.types import AttachmentType
from loguru import logger
from stw_gen_sample3_api.events.next_level.core_module.next_level.sw import FrmTypeEvent
from stw_gen_sample3_api.types.core.sw.firmware_type_type import FirmwareType
from stw_py_api_runtime.gen_classes.catchers.monitoring import monitor
from stw_py_api_runtime.sdk.brokers.broker_api import TmCatcherAPI
from stw_py_api_runtime.sdk.exceptions import SendCommandError

from stw_pro_test.upgraded_device.utils import TmClass, collide
from stw_pro_test.utils import calc_mean, extract_device_name, generate_time_str
from stw_pro_test.utils.converters import convert_raw_image

if typing.TYPE_CHECKING:
    from stw_gen_sample3_api import Sample3Device

    CollidedDevice: typing.TypeAlias = 'UpgradedDevice | Sample3Device'
else:
    CollidedDevice = object

DevicePygen = typing.TypeVar('DevicePygen')


class UpgradedDevice(CollidedDevice):
    """
    PygenDevice with extra methods.

    Не определять в классе __init__, поломается upgrade
    """

    def log_meta(
        self,
        meta_file_path: Path,
        with_boot=True,
        boot_report_timeout=15,
    ) -> None:  # noqa: C901
        """
        Создание log_meta файла прибора

        Файл требуется для выгрузки log в allure, если не нужна выгрузка, то не нужна мета (ваш кэп).
        Вызывается в фикстуре прибора (device)
        """
        # Если файл уже есть, то даже не пытаемся вне зависимости от содержимого
        if meta_file_path.exists():
            return

        logger.info('Не найден `device_meta_file`. Создаём.')
        turned_on = False

        if self.__dict__.get('_boot') is None and with_boot:
            # CAN id загрузчика должен совпадать с CAN id прибора
            self._define_boot(boot_report_timeout)

        if with_boot and not turned_on:
            try:
                turned_on: bool = self.wait_until_turned_on(timeout=boot_report_timeout)
            except TimeoutError as e:
                # Если уж тут получим SendCommandError, то устройство совсем не пашет
                actual_frm_type = self.tms.core.sw.frmTypeInfo.get_once()

                logger.info(f'Перезагрузились в {actual_frm_type.value}')
                if self.name == 'PDCU' and actual_frm_type == FirmwareType.Main:
                    logger.info('Это БКП, бутрепорта не жди')
                else:
                    raise TimeoutError(f'{e}') from e

        if self.__dict__.get('_sw_version') is None:  # Don't use hasattr because of __getattr__
            version = self.cmds.core.sw.getVersion()
            version = '{major}.{minor}.{patch}.{build}'.format_map(version)
            self._sw_version = version

        with open(meta_file_path, 'w', encoding='utf8') as dut_file:  # NOSONAR
            json.dump(
                {
                    'name': self.name,  # там чёрная магия внутри property; must be first.
                    'sn': self._sn,
                    'version': self._sw_version,
                    'boot': self._boot,
                },
                dut_file,
                indent=4,
            )
        logger.info(f'Создан `device_meta_file` по адресу: {meta_file_path}')

    def _define_boot(self, boot_report_timeout: int):
        self._boot = None

        self.cmds.core.sw.reset(extra_wait_rep=False)
        try:
            self.events.core.sw.bootReport.wait(timeout=boot_report_timeout)
        except TimeoutError:
            logger.warning('Не смогли дождаться перезагрузки устройства либо пропустили её.')

        try:
            boot_version = self.cmds.core.sw.getVersion()
            self._boot = 'BL-{major}.{minor}.{patch}.{build}'.format_map(boot_version)
        except SendCommandError:
            logger.warning(
                'Сообщение о версии ПО загрузчика не получено.\n'
                f'Возможно, адрес загрузчика отличается от адреса прибора ({self.device_id:#x})',
            )

    @property
    def name(self) -> str:
        """Get name from SN."""
        if self.__dict__.get('_sn') is None:
            sn = self.cmds.core.sw.getSerial()
            sn = str(sn).replace('\x00', '')
            if '.' in sn:
                separator = '.'
            elif '-' in sn:
                separator = '-'
            else:
                logger.error('У вас там что, новый формат серийника?!')
                raise SystemExit

            self._sn = sn
            sn = sn.split(separator)
            self._sn = separator.join(sn[:3])
            if 'DEFAULT' in self._sn:
                logger.error('У прибора не прошит серийник')
                raise SystemExit('Серийник не прошит')
        if self.__dict__.get('_name') is None:
            self._name = extract_device_name(self._sn)
        return self._name[:5]

    @property
    def artifacts_path(self) -> Path:
        """Путь сохранения артефактов"""
        if self.__dict__.get('_artifacts_path') is None:
            self._artifacts_path = Path(f'./artifacts/{self.name}')
        self._artifacts_path.mkdir(parents=True, exist_ok=True)
        return self._artifacts_path

    def wait_until_turned_on(self, timeout=30, active=False) -> bool:
        """
        Just wait for bootReport from device.

        :param timeout: return False if exceeds this value
        :param active: actively ask device about FrmType if True else wait event bootReport
        :return: True if success
        """
        if active:
            return self._wait_until_turned_on_active(timeout)
        else:
            return self._wait_until_turned_on_passive(timeout)

    def _wait_until_turned_on_passive(self, timeout=30) -> bool:
        """
        Пассивно ожидаем событие загрузки ПО.

        :param int timeout: Сколько будем ждать включения, by default 30.
        :return: `True`, если дождались. `False`, если так и не получили `event` с `FirmwareType.Main`.
        """
        for i in range(2):  # -> Загрузка по очереди бута и ПО
            logger.info(f'Ожидаем загрузку устройства {i + 1}й раз.')
            try:
                frm_type: FrmTypeEvent = self.events.core.sw.frmType.wait(timeout=timeout)
            except TimeoutError:
                return self.in_main  # Запрашиваем frmType == Main на случай, если уже загрузились
            if frm_type.event == FirmwareType.Main:
                return True
            if frm_type.event == FirmwareType.Boot:
                continue
        return False  # Получили 2 ивента, но так и не в FirmwareType.Main (￢_￢;)

    def _wait_until_turned_on_active(self, timeout=30) -> bool:
        """Инициативная проверка типа ПО."""
        for _ in range(timeout):
            if self.in_main:
                return True
            sleep(1)
        return False

    @property
    def in_main(self) -> bool:
        """Находится ли прибор сейчас в главном ФПО (не boot)."""
        return self._in_software_type(FirmwareType.Main)

    def _in_software_type(self, expected_software: FirmwareType) -> bool:
        """Находится ли прибор в ожидаемом состоянии ПО: boot, Main, ..."""
        try:
            frm_type = self.tms.core.sw.frmTypeInfo.get_once()
        except (TimeoutError, SendCommandError):
            return False
        return bool(frm_type == expected_software)  # cast to bool because of bad __eq__

    def upgraded_reboot(self, timeout=30) -> bool:
        """
        Reboot device and wait until turned on. And turn on tm on reboot

        Old name - "reboot". Renamed because of name conflict with py-api-engine

        :return: True if success
        """
        self.cmds.core.sw.reset(extra_wait_rep=False)
        reboot_result = self.wait_until_turned_on(timeout=timeout)
        return reboot_result

    def ping_device(self) -> bool:
        """
        Метод для пинга устройства.

        :return: True - если устройство отвечает, False - если устройство не отвечает.
        """
        try:
            self.tms.core.can.canStats.get_once()
            return True
        except (SendCommandError, TimeoutError):
            return False

    def get_mean_tm(
        self,
        tm: TmCatcherAPI,
        duration,
        params: list[str] | None = None,
    ) -> dict | TmClass:
        """
        Accumulate messages and calc mean values.

        Works with "simple" struture (without nested dicts)
        :param tm: ТМИ вида device.tms.
        :param duration: duration of "listening" of tm messages
        :param params: Параметры, которые нужно усреднить, если не указано, значит все
        :return: message with mean values
        """
        # TODO рассмотреть возможность удаления в связи с добавлением этого функционала в движок
        #  https://j.1440.space/browse/FUNTEST-461
        messages = self.get_tm_s(tm, duration)

        messages_to_out = '\n'.join(map(str, messages))
        logger.info(f'Получены ТМ пакеты:\n{messages_to_out}')

        mean_values = calc_mean(messages, params=params)
        logger.info(f'Рассчитано среднее: {mean_values}')
        return mean_values

    @staticmethod
    def get_tm_s(tm: list[TmClass] | TmClass, duration=2) -> list[TmClass]:
        """
        Get tm messages on "duration" period

        :param tm: ТМИ вида device.tms. ... или список ТМИ
        :param duration: duration of "listening" of tm messages
        :return: list[message]
        """
        if isinstance(tm, list):
            messages_stats = monitor(*tm, duration=duration)
        else:
            messages_stats = monitor(tm, duration=duration)
        messages = list(messages_stats.events.values())
        return messages

    def download_file(self, file_id=0, file_name: Path | None = None) -> bool:
        """
        Используется только с приборами, у которых есть core.fs

        На приборе файл должен быть создан перед скачаванием
        """
        if not hasattr(self.cmds.core, 'fs'):
            raise TypeError('У прибора должен присутствовать модуль файловой системы')

        file_name = file_name or (self.artifacts_path / f'file_{generate_time_str()}.bin')
        file_name.parent.mkdir(parents=True, exist_ok=True)
        file_name.touch(exist_ok=True)
        self.cfg.file_handler.file_id = file_id
        self.cfg.download_bin_file(bin_file_path=file_name)
        return file_name.stat().st_size > 0

    def attach_image(
        self,
        file_name: Path | None = None,
        convert_to: str | None = None,
        size: tuple[int, int] | None = None,
    ) -> tuple[bool, Path]:
        """
        Используется только с приборами, у которых есть core.fs.

        Снимок должен быть сделан на момент вызова
        :param file_name: artifacts_path/file_*log_time* by default
        :param convert_to: file extension to convert. .bmp by default
        :param size: need for conversion
        :return: download result
        """
        file_id = 0
        if convert_to and not size:
            raise ValueError('Parameter "size" is required')

        file_name = file_name or (self.artifacts_path / f'file_{generate_time_str()}.bmp')
        download_result = self.download_file(file_id, file_name)

        if not download_result:
            logger.warning(f'Не удалось скачать файл {file_name.name}. File_id = {file_id}')
            return download_result, file_name

        if convert_to:
            if not convert_to.startswith('.'):
                convert_to = '.' + convert_to
            convert_raw_image(file_name.absolute(), file_name.with_suffix(convert_to), *size)  # type: ignore[misc]
            new_suffix = convert_to
        else:
            new_suffix = '.bmp'

        converted_file_name = file_name.with_suffix(new_suffix)
        attachment_type = getattr(AttachmentType, new_suffix[1:].upper(), AttachmentType.BMP)

        allure.attach.file(
            source=converted_file_name,
            name=file_name.name,
            attachment_type=attachment_type,
        )

        return download_result, converted_file_name

    @classmethod
    def upgrade(cls, device_pygen: type[DevicePygen]):
        """Объединение классов device и UpgradedDevice."""
        new_type: DevicePygen | cls = collide('upgraded_device', device_pygen, cls)  # type: ignore
        return new_type

    def __getattr__(self, name):
        """Just for calming down linter"""
        return self.__dict__.get(name)
