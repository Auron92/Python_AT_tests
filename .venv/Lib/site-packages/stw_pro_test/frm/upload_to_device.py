"""Функции для прошивки устройства."""

import zlib
from pathlib import Path
from time import sleep
from typing import Annotated

import typer
from loguru import logger
from stw_brokers_sreda.bin_broker import SredaBinBroker
from stw_gen_sample3_api import Sample3Device as CoreDevice
from stw_gen_sample3_api.basic_types import uint8_t
from stw_gen_sample3_api.cmds.command_sender_module.next_level.core_module.next_level.sw import (
    GetVersionRep,
)
from stw_gen_sample3_api.types.repstub.ok_type import Ok
from tqdm import tqdm

from stw_pro_test.config import app
from stw_pro_test.frm.utils import extract_frm_id_and_version, get_file
from stw_pro_test.utils import engine_version_greater_than


def upload_soft(
    device: CoreDevice,
    frm_content: str | Path | bytes,
    pack_size: int = 128,
    sleep_after_init=0,
) -> bool:
    """
    Загрузка файла прошивки в память прибора без прожига.

    :param device: Устройство, в которое передается файл
    :param frm_content: файл прошивки в виде пути/до/файла или байт
    :param pack_size: размер посылки в sendData
    """
    if not isinstance(frm_content, bytes):
        with open(frm_content, 'rb') as f:
            frm_content = f.read()

    frm_crc = zlib.crc32(frm_content)

    frm_size = len(frm_content)  # bytes
    if not engine_version_greater_than('1.1.0'):
        frm_content = list(map(uint8_t, frm_content))

    try:
        device.cmds.core.frm.abort()
        device.cmds.core.frm.init(
            size=frm_size,
            extra_timeout=10,  # Если команда не получает ответ от прибора попробуйте увеличить extra_timeout
        )
    except Exception as exc:
        logger.error('Не смогли инициировать приём ПО. Либо времени не хватает, либо прибор не пашет.')
        raise exc

    # отдельно создаем бар, чтобы он соответствовал размеру файла, а не количеству чанков
    bar = tqdm(total=frm_size, desc='Загрузка файла в прибор, байт', position=0, leave=True)

    sleep(sleep_after_init)  # NOSONAR FIXME: https://j.1440.space/browse/FUNTEST-1096

    for offset in range(0, frm_size, pack_size):
        piece_len = offset + pack_size
        data_to_send = frm_content[offset:piece_len]

        pack_to_send_size = pack_size
        if len(data_to_send) < pack_size:
            # Дополняем нулями
            if engine_version_greater_than('1.1.0'):
                trailing_zeros = [0] * (pack_size - len(data_to_send))
                data_to_send += bytes(trailing_zeros)
            else:
                trailing_zeros = [uint8_t(0)] * (pack_size - len(data_to_send))
                data_to_send += trailing_zeros
            pack_to_send_size = len(frm_content[offset:piece_len])  # размер последнего кусочка

        try:
            device.cmds.core.frm.sendData(
                offset=offset,
                size=pack_to_send_size,
                data=data_to_send,
            )
        except Exception as exc:
            logger.enable('stw_py_api_runtime')
            raise exc
        bar.update(pack_to_send_size)

    logger.enable('stw_py_api_runtime')
    result = device.cmds.core.frm.finish(size=frm_size, crc=frm_crc)
    return result == Ok.Ok


def burn_soft(device: CoreDevice) -> bool | GetVersionRep.annotation_type:
    """Прожиг прошивки, загруженный в память прибора."""
    timeout = 120
    status = device.tms.core.frm.status.get_once()
    if status.uploadedSize != 0 and status.uploadedSize == status.expectedSize:
        device.cmds.core.frm.burn(extra_wait_rep=False)
        device.events.core.sw.bootReport.wait(timeout=timeout)  # Это от бута
        device.events.core.sw.bootReport.wait(timeout=timeout)
        new_version = device.cmds.core.sw.getVersion()
        return new_version
    else:
        return False


def upload_and_burn(  # noqa: C901
    device_id: int = typer.Argument(help='Node id'),
    sreda_server_ip: str = typer.Argument(help='Sreda server connections string - ip:port'),
    path_to_firmware: str = typer.Argument(help='path/to/file'),
    force_burn: Annotated[
        bool,
        typer.Option(
            '--force_burn',
            help='Прошивать, не смотря на совпадение передаваемой и приборной версий прошивки',
        ),
    ] = False,
) -> bool:
    """Прошивка прибора через CAN."""
    if isinstance(path_to_firmware, str):
        path_to_firmware = Path(path_to_firmware)  # Из-за typer версии 0.9 не можем использовать в args typehint

    broker = SredaBinBroker(sreda_server_connection=sreda_server_ip, timeout=10)
    broker.init()
    device = CoreDevice(device_id=device_id, broker=broker)

    device_version = device.tms.core.sw.version.get_once()
    device_firmware_id = device.tms.core.sw.firmwareId.get_once()
    device_version = device_version.value
    device_firmware_id = device_firmware_id.value
    frm_id, frm_version = extract_frm_id_and_version(path_to_firmware.name)
    if device_version.to_json() == frm_version.to_json():
        logger.warning(f'Прошивки совпадают:\n{device_version = }\n{frm_version = }')
        if not force_burn:
            logger.debug(
                'Перепрошивка выполняться не будет из-за совпадения версий. Можно использовать флаг --force_burn.',
            )
            return True
    if device_firmware_id.to_json() != frm_id.to_json():
        raise TypeError(f'Недопустимый firmwareId: device - "{device_firmware_id}" | file - "{frm_id}"')

    upload_success = upload_soft(device, path_to_firmware)
    if not upload_success:
        return upload_success
    burn_success = burn_soft(device)
    broker._stop()
    if not burn_success:
        return burn_success
    else:
        return True


def upload_and_burn_with_config(
    config_section_name: str = typer.Argument(default='DEFAULT', help='Название секции конфига'),
) -> bool:
    """Прошивка прибора через CAN. На вход подается имя секции конфига."""
    section_config = app.general_config[config_section_name]
    device_id = section_config.getdecimal('device_id')
    sreda_server_ip = section_config.get('sreda_server_ip')

    flash_file = get_file(section_config)
    if flash_file.name == '-1':
        # Проверяем существование файла всё равно.
        raise ValueError('Ни один из параметров, для получения прошивки не задан: flash_file, frm_id+frm_version')

    return upload_and_burn(device_id, sreda_server_ip, flash_file)
