"""Объекты, реализующие оборачивающие утилиту allurectl и взаимодействие с ней."""

import os
import platform
import re
import shlex
import stat
import subprocess
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Any, TypeVar

import requests
from loguru import logger
from tqdm import tqdm

from stw_pro_test.uploader.allure.const import ALLURE_META_FILE, AMF_UPLOAD_FLAG, AMF_UPLOAD_RESULTS
from stw_pro_test.utils import get_file_data, set_file_data

__all__ = [
    'Allurectl',
    'AllurectlIndex',
    'AllurectlReport',
    'AllurectlTime',
    'AllurectlUpload',
]

RegReturn = TypeVar('RegReturn')


@dataclass(frozen=True)
class AllurectlTime:
    """Данные из секций TIMINGS таблиц вывода allurectl."""

    duration: str = ''
    min: str = ''
    avg: str = ''
    max: str = ''


@dataclass(frozen=True)
class AllurectlIndex:
    """Данные из секции Indexer Stats -> STATS таблицы вывода allurectl."""

    container: int = 0
    attach: int = 0
    result: int = 0
    unknown: int = 0


@dataclass(frozen=True)
class AllurectlUpload:
    """Данные из секции Uploading Stats -> FILES таблицы вывода allurectl."""

    batches: int = 0
    total: int = 0
    uploaded: int = 0
    size: str = ''
    bytes: float = 0.0


@dataclass(frozen=True)
class AllurectlReport:
    """
    Данные из **STDOUT** allurectl.

    Немного подробнее о том, что там в отчете, можно прочитать тут:
    https://docs.qameta.io/allure-testops/ecosystem/allurectl/#how-to-read-allurectl-output
    """

    version: str
    project_id: int
    project_name: str
    launch_id: int
    launch_name: str
    session_id: int
    report_link: str
    files_indexed: int
    finished_files: int
    orphan_files: int
    waiting_time: str
    watcher_time: str

    index_stats: AllurectlIndex
    index_time: AllurectlTime
    upload_stats: AllurectlUpload
    upload_time: AllurectlTime


class Allurectl:
    """Uploads reports to allure."""

    BIN_DIR = './bin'
    URL = 'https://github.com/allure-framework/allurectl/releases/latest/download/'

    RE_VERSION = r'Allure\sTestOps\sClient\s(v\d+\.\d+\.\d+)'
    RE_PROJECT = r'Project\s\[(\d+)\]\swith\sname\s\[(.+)\]'
    RE_LAUNCH = r'Launch\s\[(\d+)\]\swith\sname\s\[(.+)\]'
    RE_SESSION = r'Session\s\[(\d+)\]\sstarted'
    RE_LINK = r'Report\slink:\s(\S+)'
    RE_FILES_STATS = r'Total\sfiles\sindexed:\s(\d+)\s\|\|\sFinished\sfiles:\s(\d+)\s\|\|\sOrphan\sFiles:\s(\d+)(\n|\\n)Waiting Finished'  # noqa: E501
    RE_WAITING_TIME = r'Waiting\sFinished\.\sWaited\sfor\s(.+)'
    RE_WATCHER_TIME = r'Watcher\sfinished\sin\s\[(.+)\]'
    RE_IND_STATS_PATTERN = r'\|\s*\|\s*(allure\.)?(\w+)\s*\|\s*(\d+)'
    RE_IND_TIMES = r'.*?Duration=([\S]+)\s*\|\s*Min=([\S]+)\s*\|\s*Avg=([\S]+)\s*\|\s*Max=([\S]+)\s*\|'
    RE_UPL_STATS = r'TotalBatches=(\d+)\s*\|\s+TotalFiles=(\d+)\s*\|\s*UploadedFiles=(\d+)\s*\|\s*TotalSize=([\d\.]+)\s([KMGT]?B)\s*\|\s*ErrorsCount=(\d*)'  # noqa: E501
    RE_UPL_TIMES = r'.*Duration=([\S]+)\s*\|\s*Min=([\S]+)\s*\|\s*Avg=([\S]+)\s*\|\s*Max=([\S]+)\s*\|'

    SIZE_UNITS_ORDERED = ('B', 'KB', 'MB', 'GB', 'TB')

    @staticmethod
    def get_bin_path() -> Path:
        """
        Возвращает путь до нужного исполняемого файла allurectl. При отсутствии оного попытается его скачать.

        :return: Path - путь к исполняемому файлу allurectl
        """
        bin_dir = Path(__file__).parent.resolve().joinpath(Allurectl.BIN_DIR)
        bin_dir.mkdir(parents=True, exist_ok=True)

        operating_system = platform.system().lower()
        machine = platform.machine().lower()

        if machine == 'arm64' or machine == 'aarch64':
            arch = 'arm64'
        elif '64' in machine or 'x86_64' in machine:
            arch = 'amd64'
        elif 'i386' in machine or 'i686' in machine:
            arch = '386'
        else:
            raise RuntimeError(f'Не поддерживаемая архитектура: {machine}')

        if operating_system not in ('windows', 'linux', 'darwin'):
            raise RuntimeError(f'Неизвестная ОС {operating_system}')

        bin_name = f'allurectl_{operating_system}_{arch}'
        bin_name += '.exe' if operating_system == 'windows' else ''

        bin_path: Path = bin_dir.joinpath(bin_name)

        if not bin_path.exists():
            try:
                logger.info('Исполняемый файл allurectl не найден. Начинаю загрузку...')
                url = Allurectl.URL + bin_name

                response = requests.get(url, timeout=30)
                response.raise_for_status()

                with open(bin_path, 'wb') as out_file:
                    out_file.write(response.content)

                logger.info(f'Файл успешно загружен: {bin_path}')

            except requests.exceptions.RequestException as req_err:
                error_msg = f'Ошибка загрузки файла {bin_name}: {req_err}'
                logger.error(error_msg)
                raise RuntimeError(error_msg) from req_err
            except OSError as io_err:
                error_msg = f'Ошибка записи файла {bin_name}: {io_err}'
                logger.error(error_msg)
                raise RuntimeError(error_msg) from io_err

        bin_path.chmod(bin_path.stat().st_mode | stat.S_IEXEC)
        return bin_path

    def __init__(self, token: str, report_dir: str | Path) -> None:
        """
        Uploads report to allure.

        :param token: allure token
        """
        # Для отправки
        self.endpoint: str = 'https://allure.1440.space'
        self.token: str = token
        self.report_path: Path = Path(report_dir).resolve()
        self.allurectl_path: Path = self.get_bin_path()
        self.allure_meta_path: Path = self.report_path / ALLURE_META_FILE

        # После отправки
        self.upload_counter = 0
        self.stdout: str = ''
        self.stderr: str = ''
        self.allurectl_report: AllurectlReport | None = None

    def upload(self, retries: int = 0, delay: int = 10, launch_id: int = 0) -> bool:
        """
        Совершает выгрузку отчёта в Allure.

        Данные отчета по выгрузке записываются в allure_meta_file.

        :return: bool - Выгрузка удалась/не удалась
        """
        command = (
            f'{self.allurectl_path} upload '
            + f'"{self.report_path}" '
            + f'--endpoint "{self.endpoint}" '
            + f'--token "{self.token}" '
            + f'--config "{self.allure_meta_path}" '
        )
        command += f'--launch-id {launch_id} ' if launch_id else ''

        args = shlex.split(command) if os.name == 'posix' else command

        logger.info(f'{"Произвожу" if self.upload_counter == 0 else "Повторяю"} выгрузку: {command}')
        self.stdout, self.stderr = subprocess.Popen(  # noqa: S603
            args,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            encoding='utf8',
        ).communicate()

        if self.stderr:
            self.upload_counter += 1
            logger.warning(f'Попытка выгрузки {self.upload_counter} не удалась. Ошибка: {self.stderr}')

            if self.upload_counter < retries:
                logger.info(f'Следующая попытка через {delay} сек.')
                with tqdm(total=delay, desc='Ожидание', unit='сек') as pbar:
                    for _ in range(delay):
                        time.sleep(1)
                        pbar.update(1)
                return self.upload(retries, delay)
            return False

        self._process_allurectl_report()
        if self.allurectl_report is not None:
            logger.success(f'Выгрузка прошла успешно. Launch URL: {self.allurectl_report.report_link}')
        return True

    def _process_allurectl_report(self) -> None:
        """
        Обрабатывает **stdout** вывод allurectl и сохраняет результаты.

        Результаты сохраняются в `self.allurectl_report`, а также `allure_meta_file`.
        В `allurectl upload --help` есть чудесная опция `--output`, позволяющая получить вывод скрипта в формате `json`.
        Как жаль, только, что не работает. Поэтому для получения результатов делаем черную магию с регулярками.
        """
        self.allurectl_report = self._parse_stdout()

        allure_meta = get_file_data(self.allure_meta_path, dict)
        allure_meta[AMF_UPLOAD_FLAG] = True
        allure_meta[AMF_UPLOAD_RESULTS] = asdict(self.allurectl_report)
        updated: bool = set_file_data(self.allure_meta_path, allure_meta)

        logger.info('Результаты выгрузки добавлены в allure_meta_file') if updated else ...

    def _parse_stdout(self) -> AllurectlReport:
        """Много regularОчек внутри."""
        project_id, project_name = self._read_project_info()
        launch_id, launch_name = self._read_launch_info()
        files_indexed, finished_files, orphan_files = self._read_file_stats()

        return AllurectlReport(
            version=self._read_allurectl_version(),
            project_id=project_id,
            project_name=project_name,
            launch_id=launch_id,
            launch_name=launch_name,
            session_id=self._read_session_id(),
            report_link=self._read_report_link(),
            files_indexed=files_indexed,
            finished_files=finished_files,
            orphan_files=orphan_files,
            waiting_time=self._read_waiting_time(),
            watcher_time=self._read_watcher_time(),
            index_stats=self._read_indexer_stats(),
            index_time=self._read_indexer_time(),
            upload_stats=self._read_uploader_stats(),
            upload_time=self._read_uploader_time(),
        )

    @staticmethod
    def _get_match_part(
        type_: type[RegReturn],
        re_match: re.Match[str] | None,
        part_number: int,
        default: Any,
    ) -> RegReturn:
        """
        Обрабатывает результат регулярного поиска и возвращает значение в нужном type

        :param type: Тип возвращаемого значения: на выбор `'integer', 'string', 'float'` (используйте константы выше);
        :param re_match: Результат работы `re.search` и подобных;
        :param part_number: Номер группы поиска;
        :param default: Значение, если регулярка не нашла совпадений.

        :return: Значение типа type
        """
        return type_(re_match.group(part_number)) if re_match else default  # type: ignore

    @staticmethod
    def _parse_timings(re_match: re.Match[str] | None) -> dict[str, str]:
        return {
            'duration': Allurectl._get_match_part(str, re_match, 1, ''),
            'min': Allurectl._get_match_part(str, re_match, 2, ''),
            'avg': Allurectl._get_match_part(str, re_match, 3, ''),
            'max': Allurectl._get_match_part(str, re_match, 4, ''),
        }

    def _read_allurectl_version(self) -> str:
        re_match = re.search(self.RE_VERSION, self.stdout, re.U)
        return self._get_match_part(str, re_match, 1, 0)

    def _read_project_info(self) -> tuple[int, str]:
        re_match = re.search(self.RE_PROJECT, self.stdout, re.U)
        return (
            self._get_match_part(int, re_match, 1, 0),
            self._get_match_part(str, re_match, 2, ''),
        )

    def _read_launch_info(self) -> tuple[int, str]:
        re_match = re.search(self.RE_LAUNCH, self.stdout, re.U)
        return (
            self._get_match_part(int, re_match, 1, 0),
            self._get_match_part(str, re_match, 2, ''),
        )

    def _read_session_id(self) -> int:
        re_match = re.search(self.RE_SESSION, self.stdout, re.U)
        return self._get_match_part(int, re_match, 1, 0)

    def _read_report_link(self) -> str:
        re_match = re.search(self.RE_LINK, self.stdout, re.U)
        return self._get_match_part(str, re_match, 1, '')

    def _read_file_stats(self) -> tuple[int, int, int]:
        re_match = re.search(self.RE_FILES_STATS, self.stdout, re.U)
        return (
            self._get_match_part(int, re_match, 1, 0),
            self._get_match_part(int, re_match, 2, 0),
            self._get_match_part(int, re_match, 3, 0),
        )

    def _read_waiting_time(self) -> str:
        re_match = re.search(self.RE_WAITING_TIME, self.stdout, re.U)
        return self._get_match_part(str, re_match, 1, '')

    def _read_watcher_time(self) -> str:
        re_match = re.search(self.RE_WATCHER_TIME, self.stdout, re.U)
        return self._get_match_part(str, re_match, 1, '')

    def _read_indexer_stats(self) -> AllurectlIndex:
        index_stats = {}
        stats_pattern = re.compile(self.RE_IND_STATS_PATTERN)
        for re_match in stats_pattern.finditer(self.stdout):
            index_stats[re_match.group(2)] = int(re_match.group(3))

        try:
            return AllurectlIndex(**index_stats)
        except TypeError as t_err:
            logger.error(f'Ошибка при чтении `Indexer Stats::STATS` - {t_err}. Шаблон не соответствует.')
            return AllurectlIndex()

    def _read_indexer_time(self) -> AllurectlTime:
        re_match = re.search(self.RE_IND_TIMES, self.stdout, re.U)
        timings = self._parse_timings(re_match)
        try:
            return AllurectlTime(**timings)
        except TypeError as t_err:
            logger.error(f'Ошибка при чтении `Indexer Stats::TIMINGS` - {t_err}. Шаблон не соответствует.')
            return AllurectlTime()

    def _read_uploader_stats(self) -> AllurectlUpload:
        re_match = re.search(self.RE_UPL_STATS, self.stdout, re.U)
        units = self._get_match_part(str, re_match, 5, 'B').upper()
        size = self._get_match_part(float, re_match, 4, 0.0)

        try:
            return AllurectlUpload(
                batches=self._get_match_part(int, re_match, 1, 0),
                total=self._get_match_part(int, re_match, 2, 0),
                uploaded=self._get_match_part(int, re_match, 3, 0),
                size=f'{size} {units}',
                bytes=size * (1024 ** self.SIZE_UNITS_ORDERED.index(units)),
            )
        except TypeError as t_err:
            logger.error(f'Ошибка при чтении `Uploading Stats::FILES` - {t_err}. Шаблон не соответствует.')
            return AllurectlUpload()

    def _read_uploader_time(self) -> AllurectlTime:
        re_match = re.search(self.RE_UPL_TIMES, self.stdout, re.U | re.S)
        timings = self._parse_timings(re_match)
        try:
            return AllurectlTime(**timings)
        except TypeError as t_err:
            logger.error(f'Ошибка при чтении `Uploading Stats::TIMINGS` - {t_err}. Шаблон не соответствует.')
            return AllurectlTime()
