"""Вспомогательные утилиты для работы с ini конфигом."""

import ast
import configparser
import os
import pathlib
import shutil
from typing import Annotated
from warnings import warn

import typer
from loguru import logger

from stw_pro_test.utils.converters import any2int

TEMPLATE_PATH = pathlib.Path(__file__).parent / 'config.template.ini'
DEFAULT_DEVICE_SECTION = 'default.device'


def fill_config_from_env(  # noqa: C901
    config: configparser.ConfigParser,
    env_white_list: list[str] | None = None,
    env_black_list: list[str] | None = None,
) -> None:
    """
    Заполнение (дополнение) конфига параметрами из env.

    Все параметры из env идут в DEFAULT секцию.
    Если в env есть секция с json-ом (как в ATF) - то будет создана новая секция.
    Секция будет носить имя параметра из env, внутри будут параметры из "json"-а.

    :param config: Initialised ConfigParser instance
    :param env_white_list: params will be written from this list (All by default)
    :param env_black_list: params from this list won't be written (none of params by default)
    :return:
    """
    env_black_list = env_black_list or []
    env_white_list = env_white_list or []
    for name, parameter in os.environ.items():
        if env_white_list and parameter not in env_white_list:
            continue
        if parameter in env_black_list:
            continue

        if parameter.startswith(
            '{',
        ):  # Лучший способ в соотношении "затратность-точность"
            # json.loads не работает, т.к. они (a.k.a json-ы) там поломанные: одинарные кавычки и "=" вместо ":",
            # Хоть и называются json-ми (в ATF).
            parameter_as_dict = ast.literal_eval(parameter)
            config.add_section(name)
            for (
                parameter_name_in_section,
                parameter_in_section,
            ) in parameter_as_dict.items():
                parameter_in_section = str(parameter_in_section)
                config.set(
                    name,
                    parameter_name_in_section,
                    parameter_in_section,
                )
            continue

        try:
            config['DEFAULT'][name] = parameter
        except ValueError:
            continue  # Bad Interpolation syntax for ConfigParser


def prepare_config(path_to_config: pathlib.Path | str | None = None) -> configparser.ConfigParser:
    """
    Чтение конфига по указанному пути в зависимости от условий.

    Если файл не существует, то будет заполнен template значениями из ENVIRONMENT.
    Если в конфиге есть секция `additional configs` с параметром `paths`, то будут прочитаны все указанные конфиги.

    :param path_to_config:
    :return: подготовленный объект ConfigParser.
    """
    if isinstance(path_to_config, str):
        path_to_config = pathlib.Path(path_to_config)
    config = configparser.ConfigParser(
        interpolation=configparser.ExtendedInterpolation(),
        converters={'decimal': any2int},
    )
    if path_to_config and path_to_config.exists():
        logger.debug(f'Используется конфиг {path_to_config.absolute()}')
        config_dir = path_to_config.parent

        # temp config for reading additional configs
        temp_config = configparser.ConfigParser(
            interpolation=configparser.ExtendedInterpolation(),
        )
        temp_config.read(path_to_config, encoding='utf8')
        additional_configs: list[str] = []
        if temp_config.has_section('additional configs'):
            additional_configs: str = temp_config['additional configs'].get(
                'paths',
                '',
            )
            additional_configs = additional_configs.split(', ')

        all_configs_names = [path_to_config.name, *additional_configs]
        configs = [config_dir / config_name for config_name in all_configs_names if (config_dir / config_name).exists()]
        config.read(configs, encoding='utf8')
        return config

    logger.debug(
        f'Используется конфиг по умолчанию. {TEMPLATE_PATH.absolute()}',
    )
    config.read(TEMPLATE_PATH, encoding='utf8')  # Берем template за основу
    fill_config_from_env(config)
    # Это не должно быть какой-то секцией (DEFAULT - секция), поэтому очищаем имеющуюся
    config[DEFAULT_DEVICE_SECTION] = config['DEFAULT']
    return config


def prepare_defaults(prepared_config: configparser.ConfigParser, params_from_cli: dict) -> configparser.SectionProxy:
    """
    Из конфига по умолчанию или заданный через `use_section` делает `SectionProxy` и дозаполняет значениями из CLI.

    :param prepared_config: (configparser.ConfigParser) - Объект ConfigParser
    :param params_from_cli: (dict[str | str]) - Cловарь, с аргументами CLI и их значениями
    :return: `configparser.SectionProxy`
    """
    if prepared_config.has_section(section=DEFAULT_DEVICE_SECTION):
        defaults: configparser.SectionProxy = prepared_config[DEFAULT_DEVICE_SECTION]
    else:
        defaults = prepared_config['DEFAULT']

    use_given = defaults.get('use_given') or params_from_cli.get('use_given')
    use_section = defaults.get('use_section', use_given) or params_from_cli.get('use_section', use_given)
    if use_given:
        warn(
            'Параметр "use_given" в config.ini устарел. Используйте "use_section".',
            DeprecationWarning,
            stacklevel=1,
        )

    if use_section:
        if use_section not in prepared_config:
            raise ValueError(f"Указанная секция '{use_section}' отсутствует в конфигурационном файле.")
        defaults = prepared_config[use_section]

    for parameter_name, parameter_from_cli in params_from_cli.items():
        defaults[parameter_name] = str(parameter_from_cli)  # Only str can be written in config

    return defaults


def _path_for_typer(str_path: str) -> pathlib.Path:
    """
    Кастомный парсер для typer-a.

    В других пакетах (stw-py-api) используется typer==0.9.0.
    Эта версия не поддерживает pathlib.Path.
    """
    # FIXME убрать при обновлении typer в stw-py-api
    #  https://j.1440.space/browse/PLATSWRIG-2422
    return pathlib.Path(str_path)


def make_config_from_template(
    path_to_new_config: Annotated[
        str | pathlib.Path | None,
        typer.Argument(
            help='create new config here. Creates where called by default.',
            parser=_path_for_typer,
        ),
    ] = None,
    path_to_template: Annotated[
        str | pathlib.Path | None,
        typer.Argument(
            help='use template from here. Use built-in by default',
            parser=_path_for_typer,
        ),
    ] = None,
):
    """Замена cmd команды COPY."""
    path_to_template = path_to_template or TEMPLATE_PATH
    path_to_new_config = path_to_new_config or pathlib.Path('./config.ini')
    shutil.copy(path_to_template.absolute(), path_to_new_config.absolute())
    if path_to_new_config.exists():
        logger.success(
            f'New config created here: {path_to_new_config.absolute()}',
        )
    else:
        logger.error(
            f'Error while creating config at "{path_to_new_config.absolute()}"',
        )


def make_config_from_template_cli():
    """Замена cmd команды COPY."""
    typer.run(make_config_from_template)
