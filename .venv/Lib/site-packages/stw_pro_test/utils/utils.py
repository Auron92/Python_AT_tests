"""Различные утилиты, которые не попали в другие группы."""

import configparser
import json
import math
import secrets
import sys
import time
from collections.abc import Iterable
from datetime import datetime
from importlib.metadata import version
from pathlib import Path
from types import GenericAlias
from typing import Any, TypeVar
from warnings import warn

import allure
import pytest
import toml
import yaml
from loguru import logger
from packaging.version import Version
from stw_brokers_sreda.bin_broker import SredaBinBroker
from stw_py_api_runtime.gen_classes.pygen_device_class import PyGenDevice
from tqdm import tqdm

DeviceClass = TypeVar('DeviceClass', bound=PyGenDevice)


def extract_device_name(serial: str) -> str:
    """
    Извлекает имя устройства из его серийного номера.

    Вроде бы формат серийника не должен меняться, но такое происходит.
    Данная функция постарается избавить вас от боли смены формата серийника.
    Работает с серийниками вида:
    * DNAMEY-XXXX-XXXX,
    * DNAME.XXX.XXX-XY.XX.XXX
    где DNAME - имя прибора (5 символов)
    """
    if '.' in serial:
        separator = '.'
    elif '-' in serial:
        separator = '-'
    else:
        logger.error('У вас там что, новый формат серийника блеатЪ?!')
        sys.exit()

    name = serial.split(separator)[0]
    return name[:5]


def get_internal_attribute(instance, attribute_abs_path: str):
    """
    Go through attribute_abs_path and return attr.

    :param instance: class instance
    :param attribute_abs_path: device.device.core.internal_attribute
        (without instance name)
    :return:
    """
    attr_names = attribute_abs_path.split('.')
    deep_instance = instance
    for counter, attr_name in enumerate(attr_names[:-1]):
        if counter == 0:
            deep_instance = getattr(instance, attr_names[0])
            continue
        deep_instance = getattr(deep_instance, attr_name)

    if hasattr(deep_instance, attr_names[-1]):
        return getattr(deep_instance, attr_names[-1])
    else:
        raise AttributeError(f'There is no attribute: {attribute_abs_path}')


TmClass = TypeVar('TmClass')


def calc_mean(  # noqa: C901
    messages: list[TmClass],
    params: list[str] | None = None,
) -> TmClass | dict:
    """
    Calc mean values for list of "simple" dicts (not nested).

    :param messages: packets with the same structure
    :param args: name of params to calc mean
    :return: TmClass if no params were given else dict with param
    """
    mean_values = messages[0].__dict__.copy()
    attrs = mean_values.keys()
    if params:
        mean_values = {}
        for tm_param in params:
            mean_values[tm_param] = getattr(messages[0], tm_param)
        attrs = params

    # filling
    for message in messages[1::]:
        for value_name in attrs:
            if engine_version_greater_than('1.1.0'):
                mean_values[value_name] += getattr(message, value_name)
            else:
                mean_values[value_name] += float(getattr(message, value_name))

    # calculating mean
    for value_name in attrs:
        mean_values[value_name] = mean_values[value_name] / len(messages)

    if not params:
        constructor = type(messages[0])
        mean_values = constructor(**mean_values)

    return mean_values


def get_nested_dict(structure: TmClass) -> tuple[TmClass, str | None]:
    """
    dict_with_one_key = {'one_key': object} -> (object, 'one_key')

    Because pytest.approx doesn't support nested keys (can be added in AttrDict)
    :param structure: AttrDict or dict with dict inside
    :return nested Attrdict with key (none if dict is not nested)
    """
    try:
        structure = structure.__dict__
    except TypeError:
        return structure, None

    structure_len = len(structure)
    if structure_len == 1:
        nested_key, nested_structure = next(iter(structure.items()))
        return nested_structure, nested_key
    return structure, None


def wait(
    delay_value: float,
    description: str = '',
    with_allure_step: bool = True,
    step: float = 0.01,
):
    """
    Wait with statusbar in console.

    :param delay_value: waiting time
    :param description: for showing in statusbar
    :param with_allure_step: log allure step or not
    :param step: statusbar update step
    """
    if not description.endswith('.'):
        description = f'{description}. '
    if with_allure_step:
        allure.step(f'{description}Ожидаем {delay_value} секунд')
        # with allure.step(f'Ожидаем {delay_value} секунд'):  # Just for logging
        #     pass
    all_values = int(delay_value - delay_value / 25)
    all_values = all_values or 1
    statusbar = tqdm(
        total=all_values,
        bar_format='Прошло/~осталось: {elapsed}/~{remaining} |{bar}| ',
        dynamic_ncols=True,
    )

    start = time.time()
    while time.time() - start < delay_value:
        statusbar.update(step)
        time.sleep(step)
    logger.info(f'{description}Ожидание {delay_value} сек. окончено')


def waiter(**kwargs):
    """
    Wait with statusbar in console.

    :param kwargs:
    """
    warn('Waiter is deprecated. Use wait instead.', DeprecationWarning, stacklevel=1)
    wait(**kwargs)  # For comparability


def generate_time_str() -> str:
    """Gen timestamp as str for unique file names. e.g. 1.1.2007_12.00.00.0."""
    log_time = datetime.today().strftime('%d.%m.%Y_%H.%M.%S')
    ms, *_ = math.modf(time.time())  # noqa: WPS472
    ms *= 1e3
    log_time = f'{log_time}.{int(ms)}'
    return log_time


one_time_unique_str = generate_time_str()
"""Созданное один раз время за пуск дата+время."""


def generate_time_hash_str() -> str:
    """Возвращает `one_time_unique_str` + случайный хэш."""
    return f'{one_time_unique_str}_{"".join(secrets.choice("0123456789abcdef") for _ in range(8))}'


one_time_hash_unique_str = generate_time_hash_str()
"""Созданное один раз время за пуск дата+время+хэш."""


def _parse_invocation_params(invocation_params: Iterable[str]) -> dict[str, str]:
    """
    Парсит параметры вызова (аргументы командной строки) и преобразует их в словарь.

    - Метод поддерживает только параметры, начинающиеся с `--`. Остальные параметры игнорируются.
    - Если параметр не содержит `=`, он считается флагом и преобразуется в пару `ключ='True'`.

    Пример:
        >>> _parse_invocation_params(['--env=production', '--verbose', '--debug'])
        {'env': 'production', 'verbose': 'True', 'debug': 'True'}

    :param invocation_params: (Iterable[str]) - Итерируемый объект, содержащий строковые параметры.
    :return: dict[str, str] - Словарь, где ключи — это имена параметров, а значения — соответствующие им значения.

    """
    cli_params = {}
    for parameter in invocation_params:
        is_flag = False
        if parameter.startswith('--'):
            is_flag = True
            parameter = parameter.replace('--', '')
        try:
            # Параметр вида --parameter_option="hello"
            param_name, param_value = parameter.split('=', 1)
        except ValueError:
            if not is_flag:
                # Иные параметры, которые нас не интересуют
                continue
            # Параметр вида --feature_flag
            param_name, param_value = (parameter, 'True')  # Наличие флага подразумевает bool True

        cli_params[param_name] = param_value
    return cli_params


def extract_invocation_params(config: pytest.Config) -> dict[str, str]:
    """
    Извлекает параметры запуска из addopts конфига pytest и CLI.

    Параметры из CLI переписывают addopts.

    :param config: (pytest.Config)
    :return: dict[str, str] - словарь с аргументами из addopts и CLI.
    """
    addopts_params: str = config.inicfg.get('addopts', '')  # type: ignore
    invocation_params: dict[str, str] = _parse_invocation_params(addopts_params.split())

    cli_params: dict[str, str] = _parse_invocation_params(config.invocation_params.args)
    invocation_params.update(**cli_params)

    config_path = invocation_params.get('config_path')

    if not config_path:
        return invocation_params

    if not Path(config_path).is_absolute():  # If relative like './config/config.ini'
        ini_file_dir: Path | None = config.inipath
        if ini_file_dir is None:
            raise AttributeError('Отсутствует конфигурационный файл для pytest - .ini, .toml')

        # Считаем, что путь указан от корневой директории, и в ней же находится pytest.ini
        config_path = ini_file_dir.parent / config_path
        config_path = config_path.resolve()
        if not config_path.exists():
            w_str = f'Не найдено файла конфигурации `{config_path}`'
            logger.warning(w_str)
            warn(w_str, Warning, stacklevel=2)

        invocation_params['config_path'] = str(config_path)

    return invocation_params


DataT = TypeVar('DataT')


def _read_file_data(file_path: Path, mode: str, encoding: str | None) -> Any:
    """Читает данные из файла."""
    suffix: str = file_path.suffix.lower()

    try:
        with file_path.open(mode=mode, encoding=encoding) as file:
            if suffix in ['.yaml', '.yml']:
                return yaml.safe_load(file)
            elif suffix == '.json':
                return json.load(file)
            elif suffix == '.toml':
                return toml.load(file)
            elif suffix == '.ini':
                config = configparser.ConfigParser()
                config.read(file_path)
                return {section: dict(config[section]) for section in config.sections()}
            elif suffix == '.txt':
                return file.read()
            elif suffix in ['', '.bin', '.exe']:
                return file.read()  # Бинарные данные
            else:
                raise NotImplementedError(f'Unsupported file format: {file_path}')

    except (yaml.YAMLError, json.JSONDecodeError, toml.TomlDecodeError, configparser.Error) as parse_err:
        raise ValueError(f'Parse error in file {file_path}.') from parse_err
    except FileNotFoundError as fnaf_err:
        raise FileNotFoundError(f'File not found on Path: {file_path}') from fnaf_err


def _validate_required_keys(data: dict, required_keys: str | Iterable[str], file_path: Path) -> None:
    """Проверяет наличие обязательных ключей в словаре."""
    if isinstance(required_keys, str):
        required_keys = {required_keys}
    elif isinstance(required_keys, Iterable):
        required_keys = set(required_keys)
    else:
        raise TypeError(f'Unsupported type for `required_keys`: {type(required_keys)}')

    missing_keys: set[str] = required_keys - data.keys()
    if missing_keys:
        raise ValueError(f'Missing keys in file {file_path}: {missing_keys}')


def get_file_data(
    file_path: Path,
    expected_type: type[DataT] = dict[str, Any],
    required_keys: str | Iterable[str] | None = None,
    required_len: int | None = None,
) -> DataT:
    """
    Читает данные из файла или без расширения и возвращает их в виде указанного типа данных.

    На текущий момент умеем работать с файликами форматов `.yaml`, `.yml`, `.json`,
    `.toml`, `.ini`, `.txt`, `.bin`, `.exe` и без указанного расширения.

    :param Path file_path: Путь к файлу.
    :param type expected_type: Ожидаемый тип данных (`dict`, `list`, `set`, `bytes`, `str` и т.д.).
        По умолчанию `dict[str, Any]`.
    :param str | Iterable[str] required_keys: Имя ключа или список ключей, которые должны обязательно
        присутствовать в результате. Поддерживается только для словарей. Для других типов игнорируется.
    :param int required_len: Требуемая минимальная длина результата. Только для итерируемых типов данных.
    :return: Данные указанного типа.
    :raise NotImplementedError: Если передан файл неподдерживаемого формата.
    :raise FileNotFoundError: Если файл не найден.
    :raise ValueError: Если невозможно прочитать данные или файл не соответствует требованиям.
    :raise TypeError: Если данные не соответствуют ожидаемому типу.
    """
    if isinstance(expected_type, GenericAlias):
        expected_type = type(expected_type())

    # Определяем режим открытия файла (текстовый или бинарный)
    mode, encoding = ('r', 'utf-8') if expected_type in (str, dict, list, tuple, set) else ('rb', None)

    # Чтение данных из файла
    data = _read_file_data(file_path, mode, encoding)

    # Кастуем тип для tuple и set. Сначала, т.к. дальше проверка по типу
    if expected_type in (tuple, set) and isinstance(data, list):
        data = expected_type(data)  # type: ignore[call-arg]

    # Если в файле, например, '', сделаем её пустым требуемым значением, т.к. проверка required_xx важнее
    if not data:
        data = expected_type()

    # Проверяем тип данных
    if not isinstance(data, expected_type):
        raise TypeError(f'Expected type {expected_type}, but got {type(data)}.')

    # Проверка required_keys (только для словарей)
    if required_keys is not None and isinstance(data, dict):
        _validate_required_keys(data, required_keys, file_path)

    # Проверка required_len (для Iterable)
    if required_len is not None and isinstance(data, Iterable):
        data_len: int = len(data)  # type: ignore
        if data_len < required_len:
            raise ValueError(f'Expected length {required_len}, but got {data_len}.')

    return data  # type: ignore[no-any-return]


def set_file_data(file_path: Path, data: Any) -> bool:
    """
    Записывает данные в файл.

    На текущий момент умеем работать с файликами форматов `.yaml`, `.yml`, `.json`,
    `.toml`, `.ini`, `.txt`, `.bin`, `.exe` и без указанного расширения.

    :param Path file_path: Путь к файлу.
    :param Any data: Данные для записи в файл. Может быть словарем, списком, строкой, байтами и т.д.
    :return: True, если запись прошла успешно.
    :raise NotImplementedError: Если передан файл неподдерживаемого формата.
    :raise TypeError: Если невозможно записать данные или данные не соответствуют требованиям.
    """
    suffix: str = file_path.suffix.lower()

    # Определяем режим открытия файла (текстовый или бинарный)
    mode, encoding = ('w', 'utf-8') if isinstance(data, (str, dict, list, tuple, set)) else ('wb', None)

    try:
        with file_path.open(mode=mode, encoding=encoding) as file:
            if suffix in ['.yaml', '.yml']:
                yaml.safe_dump(data, file)
            elif suffix == '.json':
                json.dump(data, file)
            elif suffix == '.toml':
                toml.dump(data, file)
            elif suffix == '.ini':
                config = configparser.ConfigParser()
                config.read_dict(data)
                config.write(file)
            elif suffix == '.txt':
                file.write(data)
            elif suffix in ['', '.bin', '.exe']:
                file.write(data)
            else:
                raise NotImplementedError(f'Unsupported file format: {file_path}')

    except (yaml.YAMLError, json.JSONDecodeError, configparser.Error, TypeError) as dump_err:
        raise TypeError(f'Cannot write {data} to {file_path}') from dump_err
    return True


def create_sreda_device(
    device_cls: type[DeviceClass],
    sreda_server_ip: str,
    device_id: int | None,
    active_module='CAN1',
) -> DeviceClass:
    """Возвращает подключенный через SredaBinBroker экземпляр переданного устройства"""
    broker = SredaBinBroker(
        sreda_server_connection=sreda_server_ip,
        active_module=active_module,
    )
    broker.init()
    return device_cls(device_id=device_id, broker=broker)


def get_stw_engine_version() -> Version:
    """
    Получает используемую версию stw-движка.

    :return: packaging.version.Version
    """
    return Version(version('stw-py-api-runtime'))


def engine_version_greater_than(ver: str) -> bool:
    """
    Отвечает на вопрос, новее ли версия, чем `ver`.

    :param str ver: версия, с которой сравнивать.
    :return: `True`, если версия новее или равна. `False` если старше.
    """
    return get_stw_engine_version() >= Version(ver)
