"""Средства для обработки транспортного сообщения."""
from stw_py_api_runtime.sdk.brokers.message import (
    DeviceAddress, Priority, PriorityConverter,
)
from stw_py_api_runtime.sdk.network_utils import (
    get_host_port_from_ip, get_ip_endpoint,
)
from stw_sreda_api.common_pb2 import Endpoint, TimbrelAddress
from stw_sreda_api.timbrel_messages_pb2 import TimbrelPriority


class SredaPriorityConverter(PriorityConverter):
    """Преобразователь из общего типа в транспортный sreda-api.

    Необходимо, так как у брокера по транспортному уровню приходит тип,
    определенный этим транспортом. А в рантайме приоритет общий и от транспорта не зависит.
    """

    protocol_transport_map = {
        Priority.HIGHEST: TimbrelPriority.HIGHEST,
        Priority.HIGH: TimbrelPriority.HIGH,
        Priority.LOW: TimbrelPriority.LOW,
        Priority.LOWEST: TimbrelPriority.LOWEST,
    }
    transport_protocol_map = {transport: protocol for protocol, transport in protocol_transport_map.items()}

    @classmethod
    def transport_to_protocol(cls, raw_value: TimbrelPriority) -> Priority:
        """Преобразовать значение транспортного типа в общий."""
        try:
            return cls.transport_protocol_map[raw_value]
        except KeyError:
            raise KeyError(
                f'Unknown transport priority {raw_value}, expected {cls.transport_protocol_map.keys()}',  # noqa: WPS237
            )

    @classmethod
    def protocol_to_transport(cls, raw_value: Priority) -> TimbrelPriority:
        """Преобразовать значение общего типа в транспортный."""
        try:
            return cls.protocol_transport_map[raw_value]
        except KeyError:
            raise KeyError(
                f'Unknown protocol priority {raw_value}, expected {cls.protocol_transport_map.keys()}',  # noqa: WPS237
            )


class AddressConverter(object):
    """Преобразователь адреса девайса из общего типа в транспортный sreda-api.

    Необходимо, так как у брокера по транспортному уровню приходит тип,
    определенный этим транспортом. А в рантайме приоритет общий и от транспорта не зависит.
    """

    @classmethod
    def transport_to_base(cls, address: TimbrelAddress) -> str | int:
        """Преобразовать адрес на транспортном уровне в стандартный питонячий тип."""
        actor_type = address.WhichOneof('address')  # node_id | endpoint
        actor_id = getattr(address, actor_type)
        if isinstance(actor_id, Endpoint):
            actor_id = get_ip_endpoint(actor_id.host, actor_id.port)
        return actor_id

    @classmethod
    def transport_to_runtime(cls, address: TimbrelAddress) -> DeviceAddress:
        """Преобразовать адрес на транспортном уровне в runtime формат."""
        base_address = cls.transport_to_base(address)
        return cls.base_to_runtime(base_address)

    @classmethod
    def runtime_to_transport(cls, address: DeviceAddress, main_endpoint: bool = False) -> TimbrelAddress:
        """Преобразовать адрес прибора из runtime формата в транспортный."""
        if address.node_id is not None and not main_endpoint:
            return TimbrelAddress(node_id=address.node_id)

        host, port = get_host_port_from_ip(address.endpoint)
        return TimbrelAddress(endpoint=Endpoint(host=host, port=port))

    @classmethod
    def base_to_transport(cls, address: int | str) -> TimbrelAddress:
        """Преобразовать адрес прибора из runtime формата в транспортный."""
        device_address = cls.base_to_runtime(address)
        return cls.runtime_to_transport(device_address)

    @classmethod
    def base_to_runtime(cls, address: int | str) -> DeviceAddress:
        """Преобразовать адрес в стандартном питонячьем типе в runtime формат."""
        if isinstance(address, int):
            return DeviceAddress(node_id=address)
        elif isinstance(address, str):
            return DeviceAddress(endpoint=address)
        raise ValueError(f'Invalid device address type: expected int or str, but given {type(address)}')  # noqa: WPS237
