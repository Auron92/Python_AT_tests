"""Бинарный брокер SredaBinBroker."""
from dataclasses import dataclass, field
from queue import SimpleQueue
from threading import Event, Thread
from typing import Callable, Dict, List, Optional, Type
from uuid import UUID

import grpc
from loguru import logger
from stw_py_api_runtime import app_config
from stw_py_api_runtime.broker_extension.extend import MessageHandler
from stw_py_api_runtime.gen_classes.catchers.cmd_catcher import CmdCatcher
from stw_py_api_runtime.gen_classes.catchers.event_catcher import EventCatcher
from stw_py_api_runtime.gen_classes.catchers.tm_catcher import TmCatcher
from stw_py_api_runtime.gen_classes.custom_types import Command
from stw_py_api_runtime.gen_classes.telemetry.observer import TelemetryObserver
from stw_py_api_runtime.gen_classes.telemetry.parse import Message
from stw_py_api_runtime.gen_classes.telemetry.predicates import (
    Predicate, StreamMsgChannel,
)
from stw_py_api_runtime.gen_classes.types.returned_types import ReturnTypes
from stw_py_api_runtime.logger_utils import (
    activate_tm_log, setup_custom_logging, write_tm_log,
)
from stw_py_api_runtime.sdk.brokers.broker_api import BrokerAPI
from stw_py_api_runtime.sdk.brokers.fragments.commanding import (
    QueueReqRepCommander,
)
from stw_py_api_runtime.sdk.brokers.fragments.unpacking import (
    unpack_bin_message, unpack_message,
)
from stw_py_api_runtime.sdk.brokers.message import DeviceAddress, Priority
from stw_py_api_runtime.serialization.message_data import BinSerializer
from stw_sreda_api.modules.can_pb2_grpc import CanModuleServiceStub
from stw_sreda_api.modules_pb2 import ModuleType
from stw_sreda_api.timbrel_messages_pb2 import (
    TimbrelEventMessage, TimbrelReqRepMessage, TimbrelTelemetryMessage,
)

from stw_brokers_sreda.bin_broker.connections import (
    init_handlers_threads, init_server_connections,
)
from stw_brokers_sreda.req_rep_commanding import ProtobufMessageCreator
from stw_brokers_sreda.sreda_ifc import (
    check_api_version, check_sreda_module, check_sreda_support,
    get_active_module_info, get_module_id_by_name, get_server_modules_map,
)
from stw_brokers_sreda.tm_observe import ProtobufTimbrelPredicate


@dataclass
class SredaBinBrokerAPI(BrokerAPI):  # noqa: WPS214
    """Брокер, который подключается только к SREDA-server.

    Использует кодирование данных сообщения в бинарном виде.
    """

    sreda_server_connection: str = '127.0.0.1:3441'
    active_module: str = 'CAN1'
    tm_observer: TelemetryObserver = field(default_factory=TelemetryObserver)
    tm_catcher_class: Type[TmCatcher] = TmCatcher
    event_catcher_class: Type[EventCatcher] = EventCatcher
    cmd_catcher_class: Type[CmdCatcher] = CmdCatcher
    predicate_class: Type[Predicate] = ProtobufTimbrelPredicate
    serializer: BinSerializer = field(default_factory=BinSerializer)
    commander: Optional[QueueReqRepCommander] = field(default=None)
    message_creator: ProtobufMessageCreator = field(default_factory=ProtobufMessageCreator)
    safe_init: bool = field(default=False)
    raise_on_error_msg: bool = field(default=True)
    safe_init_timeout: int = field(default=10)
    is_async: bool = field(default=False)
    timeout: float = field(default=3, repr=False)
    retry_sending: bool = field(default=False, repr=False)
    sending_tries_count: int = field(default=3, repr=False)
    _channel: Optional[grpc.Channel] = field(default=None)
    _stub: Optional[CanModuleServiceStub] = field(default=None)
    _modules_map: Dict[str, str] = field(default_factory=dict)
    _telemetry_started: Event = field(default=None)
    _stop_event: Event = field(default=None)
    _req_thread: Optional[Thread] = field(default=None)
    _event_thread: Optional[Thread] = field(default=None)
    _event_queue: SimpleQueue = field(default_factory=SimpleQueue)
    _tm_thread: Optional[Thread] = field(default=None)
    _tm_queue: SimpleQueue = field(default_factory=SimpleQueue)
    _address: DeviceAddress = field(default=None)

    def __post_init__(self, *args, **kwargs):
        """Настройка объекта после основной инициализации.

        Инициализирует кастомные уровни логирования и создает объект ProtobufTimbrelReqRepCommander.
        """
        self.active_module = self.active_module.upper()
        self._address = DeviceAddress(node_id=app_config.broker_client_id)
        activate_tm_log()
        setup_custom_logging()

    def set_timeout(self, new_value: float) -> None:  # noqa: WPS615
        """Установить новое значение таймаута."""
        self.timeout = new_value
        if self.commander is not None:
            self.commander.timeout = new_value

    def set_retry_sending(self, new_value: bool) -> None:  # noqa: WPS615
        """Установить новое значение флага - переотправлять ли команду в случае отсутствия ответа."""
        self.retry_sending = new_value
        if self.commander is not None:
            self.commander.retry_sending = new_value

    def set_sending_tries_count(self, new_value: int) -> None:  # noqa: WPS615
        """Установить новое значение - сколько раз переотправлять команду в случае отсутствия ответа."""
        self.sending_tries_count = new_value
        if self.commander is not None:
            self.commander.sending_tries_count = new_value

    def init(self):  # noqa: WPS210
        """Установка подключений, получение необходимой информации."""
        self._telemetry_started = Event()
        self._stop_event = Event()

        module_items = get_server_modules_map(self.sreda_server_connection).items()
        self._modules_map = {name.upper(): settings for name, settings in module_items}
        check_sreda_module(self._modules_map, self.active_module)
        check_api_version(self.sreda_server_connection)
        check_sreda_support(self.sreda_server_connection)

        active_module_id = get_module_id_by_name(self._modules_map, self.active_module)
        module_name, module_type = get_active_module_info(self.sreda_server_connection, self.active_module)
        channel, stub = init_server_connections(
            self.sreda_server_connection,
            module_type=module_type,
        )
        self._channel = channel
        self._stub = stub

        if module_type == ModuleType.TimbrelOverIpModuleType:
            self._address.endpoint = str(self._modules_map[module_name.upper()]['endpoint'])
            self.message_creator.by_over_ip = True

        self.commander = QueueReqRepCommander(
            timeout=self.timeout,
            retry_sending=self.retry_sending,
            sending_tries_count=self.sending_tries_count,
            serializer=self.serializer,
            message_creator=self.message_creator,
            active_module=self.active_module,
            sender_address=self._address,
        )

        req_thread, event_thread, tm_thread = init_handlers_threads(
            req_send_queue=self.commander.req_queue,
            req_rep_recv=self._on_req_rep_recv,
            req_rep_rpc=self._stub.TimbrelReqRep,
            event_queue=self._event_queue,
            event_recv=self._on_tm_recv,
            event_rpc=self._stub.TimbrelEvent,
            tm_queue=self._tm_queue,
            tm_recv=self._on_tm_recv,
            tm_rpc=self._stub.TimbrelTelemetry,
            metadata=[('sreda-module-id', active_module_id)],
            stop_event=self._stop_event,
        )

        self._req_thread = req_thread
        self._event_thread = event_thread
        self._tm_thread = tm_thread

        self.wait_first_tm(self.safe_init_timeout)
        logger.trace(f'Broker started running with server {self.sreda_server_connection}')

    def _stop(self):
        """Освобождение ресурсов брокера.

        Рекомендуется вызывать его по окончанию работы.
        """
        if self._stop_event is not None:
            self._stop_event.set()

        if self._channel is not None:
            self._channel.close()
            logger.trace('Closed grpc channel')

        for th in (self._req_thread, self._event_thread, self._tm_thread):
            if th is not None:
                th.join()

        logger.trace(f'Broker stopped and disconnected from server {self.sreda_server_connection}')

    def change_active_module(self, new_module):
        """Смена активного модуля.

        Args:
            new_module (str): имя нового модуля

        Raises:
            ModuleNotFoundError: когда имя указанного модуля не найдено в списке доступных
        """
        if new_module.upper() not in self._modules_map:
            raise ModuleNotFoundError(f'Module {new_module} is not available.')

        self.active_module = new_module.upper()
        self._reset_and_reinit()
        logger.info(f'Successfully switched to new module: {self.active_module}')

    def send_transport_messages(self, messages: list):
        """Отправить на активный модуль массив сырых транспортных сообщений."""
        for message in messages:
            if isinstance(message, TimbrelReqRepMessage):
                self.commander.req_queue.put(message)
            elif isinstance(message, TimbrelEventMessage):
                self._event_queue.put(message)
            elif isinstance(message, TimbrelTelemetryMessage):
                self._tm_queue.put(message)

    def send_command_raw(
        self,
        device_address: DeviceAddress,
        command: str,
        message_id: int,
        return_types: ReturnTypes,
        extra_retry: bool = True,
        extra_priority: Priority = Priority.LOWEST,
        extra_need_rep: bool = True,
        extra_wait_rep: bool = True,
        extra_timeout: int | None = None,
        **kwargs,
    ) -> Message:
        """
        Отправить команду.

        Args:
            device_address: адрес прибора
            command: полное имя команды
            message_id: id сообщения команды из описания прошивки
            return_types: возможные типы ответа по описанию прошивки
            extra_retry: если True, при отсутствии ответа отправлять команду повторно (кол-во раз - sending_tries_count)
            extra_priority: приоритет команды согласно протоколу Timbrel
            extra_need_rep: если True, требуется ответ на команду со стороны прибора
            extra_wait_rep: если True, нужно дождаться ответ от прибора
            extra_timeout: сколько (сек) ждать ответ
            kwargs: аргументы команды

        Returns:
            Объект, завернутый в тип из пайген согласно описанию прошивки (базовый тип Message)
        """
        transport_msg = self.commander.send_command_raw(
            device_address=device_address,
            command=command,
            message_id=message_id,
            extra_retry=extra_retry,
            extra_priority=extra_priority,
            extra_need_rep=extra_need_rep,
            extra_wait_rep=extra_wait_rep,
            extra_timeout=extra_timeout,
            **kwargs,
        )
        if transport_msg is None:
            return
        return unpack_message(self, transport_msg, command, StreamMsgChannel.REQ_REP, return_types)

    def send_command_batch(
        self,
        device_address: DeviceAddress,
        commands: List[Command],
    ):
        """Отправка пачки команд на шину can."""
        commands_resp = []
        transport_responses = self.commander.send_command_batch(device_address, commands)
        for idx, transport_msg in enumerate(transport_responses):
            command_params = commands[idx]
            resp = unpack_message(
                self, transport_msg, command_params.name, StreamMsgChannel.REQ_REP, command_params.types,
            )
            commands_resp.append(resp)
        return commands_resp

    def subscribe_to_tm(
        self,
        *,
        predicate: Predicate,
        callback: Callable,
        use_single: bool,
    ) -> UUID:
        """Подписаться на получение определенного сообщения.

        Возвращает идентификатор подписчика.

        Args:
            predicate (Predicate): Предикат для фильтрации сообщений.
            callback (Callable): Функция обратного вызова для обработки сообщения.
            use_single (bool): Флаг.

        Returns:
            UUID: Идентификатор подписчика.
        """
        return self.tm_observer.add_subscriber(
            predicate=predicate,
            use_single=use_single,
            callback=callback,
        )

    def unsubscribe_from_tm(self, subscriber_id) -> None:
        """Отписаться от получения определенного сообщения.

        Args:
            subscriber_id (int): Идентификатор подписчика.
        """
        self.tm_observer.remove_subscriber(subscriber_id)

    def _cleanup_resources(self):
        """Очистка активных ресурсов."""
        self._modules_map = {}
        self._stub = None
        self._channel = None

        self._telemetry_started.clear()
        self._stop_event.clear()
        self.tm_observer.subscribers.clear()

    def _reset_and_reinit(self):
        """Очистка ресурсов и повторная инициализация."""
        self._stop()
        self._cleanup_resources()
        self.init()

    def _on_req_rep_recv(self, msg: TimbrelReqRepMessage):
        """Вызывается при получении каждого req-rep сообщения."""
        if msg.is_rep:
            self.commander.add_rep(msg)
        self.tm_observer.notify_subscribers(msg, StreamMsgChannel.REQ_REP)

    def _on_tm_recv(self, msg: TimbrelTelemetryMessage | TimbrelEventMessage):
        """Вызывается при получении каждого tm сообщения."""
        self._telemetry_started.set()
        channel = StreamMsgChannel.TM if isinstance(msg, TimbrelTelemetryMessage) else StreamMsgChannel.EVENT
        self.tm_observer.notify_subscribers(msg, channel)
        write_tm_log(f'{channel.name} | {self.get_message_meta(msg)} | {msg.data}')  # noqa: WPS221, WPS237
        self.tm_observer.check_delta_delta(msg.header.timestamp, None)

    def unpack_transport_message(self, message: object, channel: str, data_types: ReturnTypes):
        """Вытащить полезные данные и их тип из транспортного сообщения."""
        message_id = message.header.message_id
        data_bytes = self.get_message_data(message)
        return unpack_bin_message(self, message, message_id, data_bytes, data_types)

    def is_message_rep(self, message: object) -> bool:
        """Возвращает True, если сообщение является rep - ответом на команду."""
        return isinstance(message, TimbrelReqRepMessage) and message.is_rep

    def get_message_data(self, message):
        """Получить полезные данные из транспортного сообщения."""
        return message.data

    def get_message_meta(self, message):  # noqa: C901
        """Получить метаинформацию из message транспортного уровня.

        Args:
            message: Сообщение транспортного уровня.

        Returns:
            dict: Словарь с метаинформацией.
        """
        meta = {}
        if hasattr(message, 'header'):
            if hasattr(message.header, 'timestamp'):
                meta['timestamp'] = message.header.timestamp
            if hasattr(message.header, 'cti'):
                meta['cti'] = message.header.cti
            if hasattr(message.header, 'message_id'):
                meta['message_id'] = message.header.message_id
        if hasattr(message, 'server_id'):
            meta['server_id'] = message.server_id
        return meta


class SredaBinBroker(SredaBinBrokerAPI, MessageHandler):
    """
    Расширенный бинарный брокер, работающий через SREDA-server.

    Args:
        :param sreda_server_connection (str) - Адрес SREDA-сервера;

        :param active_module (str) - Активный модуль;

        :param tm_observer (TelemetryObserver) - Объект наблюдателя телеметрии;

        :param tm_catcher_class (Type[TmCatcher]) - Обработчик телеметрии;

        :param event_catcher_class (Type[EventCatcher]) - Обработчик событий;

        :param cmd_catcher_class (Type[CmdCatcher]) - Обработчик команд;

        :param predicate_class (Type[Predicate])-  Обработчик предиката;

        :param serializer (BinSerializer) - Cериализатор;

        :param commander (Optional[QueueReqRepCommander]) - Обработчик команд и сопоставления с ответами ина них;

        :param timeout (float) -  Таймаут ожидания ответа на команду;

        :param retry_sending (bool) - Нужно ли повторно отправлять сообщение;

        :param sending_tries_count (int) -  Количество попыток запроса при retry_sending=True;

        :param safe_init (bool) - Если True, брокер при старте ждет первое ТМ сообщение;

        :param raise_on_error_msg (bool) - Если True, при получении ошибочного ответа на команду, будет рейзится ошибка;

        :param safe_init_timeout (int) - Таймаут ожидания первого ТМ сообщения;
    """
