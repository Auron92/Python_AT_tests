"""Патч grpc библиотеки."""
import time

import grpc
from grpc import _common
from grpc._channel import _EMPTY_FLAGS, _event_handler, _MultiThreadedRendezvous
from grpc._cython import cygrpc
from loguru import logger

WAIT_TIMEOUT = 1


class FrozenStreamError(grpc.RpcError):

    def __init__(self, grpc_code, message=None):
        self.grpc_code = grpc_code
        self.message = message or f'Received code {self.grpc_code}, but resp ready waiting timeout ({WAIT_TIMEOUT} sec)'

    def code(self):
        return self.grpc_code


def _is_frozen(code_received: bool, code_received_timestamp: float) -> bool:
    if not code_received or code_received_timestamp is None:
        return False

    if time.perf_counter() - code_received_timestamp > WAIT_TIMEOUT:
        return True

    return False


def patched_next(self):
    """Смысла патча в том, чтобы не допустить бесконечное ожидание сообщения.

    Этот метод (next) ждет, когда циклично вызывающийся _response_ready() вернет True.
    А это случится, если получено реальное сообщение, либо grpc код с выполнением внутреннего условия.
    С низкой вероятностью наблюдалось бесконечное зависание - когда код есть, а условие не отрабатывало.

    Поэтому теперь, если получен код, но ожидание вышло по таймауту - рейзим исключение.
    """
    with self._state.condition:
        if self._state.code is None:
            event_handler = _event_handler(
                self._state, self._response_deserializer
            )
            self._state.due.add(cygrpc.OperationType.receive_message)
            operating = self._call.operate(
                (cygrpc.ReceiveMessageOperation(_EMPTY_FLAGS),),
                event_handler,
            )
            if not operating:
                self._state.due.remove(cygrpc.OperationType.receive_message)
        elif self._state.code is grpc.StatusCode.OK:
            raise StopIteration()
        else:
            raise self

        code_received = False
        code_received_timestamp = None

        def _response_ready():
            """Проверка, получено ли сообщение или код."""
            nonlocal code_received
            nonlocal code_received_timestamp

            if self._state.code is not None and not code_received:
                code_received = True
                code_received_timestamp = time.perf_counter()

            is_ready = self._state.response is not None or (
                cygrpc.OperationType.receive_message not in self._state.due
                and self._state.code is not None
            )
            if not is_ready and _is_frozen(code_received, code_received_timestamp):
                # ловля зависания по таймауту
                raise FrozenStreamError(
                    grpc_code=self._state.code,
                    message=f'Received code {self._state.code} but timeout waiting ({WAIT_TIMEOUT})',
                )

            return is_ready

        _common.wait(self._state.condition.wait, _response_ready)
        if self._state.response is not None:
            response = self._state.response
            self._state.response = None
            return response
        elif cygrpc.OperationType.receive_message not in self._state.due:
            if self._state.code is grpc.StatusCode.OK:
                raise StopIteration()
            elif self._state.code is not None:
                raise self


def patch_grpc_multithread():
    _MultiThreadedRendezvous.__next__ = patched_next
    logger.trace(f'Grpc _MultiThreadedRendezvous stream iterator patched with timeout {WAIT_TIMEOUT}')
