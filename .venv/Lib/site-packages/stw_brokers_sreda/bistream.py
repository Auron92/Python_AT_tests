"""Двусторонний стрим (отправка и получение сообщений через стримы."""
import datetime
import threading
from queue import SimpleQueue
from threading import Thread
from typing import Any, Callable

import grpc
from loguru import logger
from stw_py_api_runtime.gen_classes.telemetry.predicates import StreamMsgChannel

from stw_brokers_sreda.exceptions import raise_rpc_error
from stw_brokers_sreda.grpc_patch import WAIT_TIMEOUT, FrozenStreamError


def create_bistream(
    out_queue: SimpleQueue | None,
    msg_handler: Callable,
    rpc: grpc.StreamStreamMultiCallable,
    metadata: Any,
    thread_name: str,
    channel: StreamMsgChannel,
    stop_event: threading.Event,
):
    """Создание двунаправленного стрима.

    Для отправки сообщений "туда" - нужно просто положить его в out_queue.
    Каждое принятое сообщение будет передано как аргумент в функцию
    msg_handler.
    """
    queue_getter = out_queue.get if out_queue is not None else SimpleQueue().get
    out_iterator = iter(queue_getter, None)
    in_stream = rpc(out_iterator, metadata=metadata)

    def _loop(msg_handler, stream, channel):
        """Запустить обработку потока сообщений."""
        logger.trace(f'{channel.name} stream started')

        while not stop_event.is_set():
            try:
                for msg in stream:
                    if stop_event.is_set():
                        # проверяем и внутри цикла, т.к. событие может измениться, пока мы итерируемся
                        return
                    msg_handler(msg)

            except (grpc.RpcError, FrozenStreamError) as rpc_error:

                if isinstance(rpc_error, FrozenStreamError):
                    logger.trace(f'{channel.name} was frozen: {rpc_error.message}')

                if rpc_error.code() == grpc.StatusCode.CANCELLED and stop_event.is_set():
                    # канал закрыт нами, но исключение выбросилось раньше события
                    return

                raise_rpc_error(rpc_error)

        logger.trace(f'{channel.name} stream finished')

    loop_thread = Thread(
        target=_loop,
        args=(msg_handler, in_stream, channel),
        name=thread_name,
        daemon=True,
    )
    loop_thread.start()
    return loop_thread
