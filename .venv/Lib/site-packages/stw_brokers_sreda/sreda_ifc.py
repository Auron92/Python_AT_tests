"""Этот модуль предоставляет функции для взаимодействия с модулями SREDA."""

from importlib.metadata import version as pkg_version

import grpc
from loguru import logger
from packaging import version
from stw_py_api_runtime.sdk.exceptions import ModuleNameError
from stw_sreda_api import common_pb2
from stw_sreda_api.common_pb2 import Empty
from stw_sreda_api.modules_pb2_grpc import ModulesServiceStub
from stw_sreda_api.services import bind_pb2_grpc
from stw_sreda_api.services.bind_pb2_grpc import BindServiceStub
from stw_sreda_api.modules_pb2 import ModuleType

APPROVED_VERSIONS = (
    (0, 13),
    (1, 2),
    (1, 3),
    (1, 4),
    (1, 5),
    (1, 6),
    (1, 7),
    (2, 0),
)


def get_server_modules_map(sreda_server_connection: str) -> dict:
    """Получить список модулей среды.

    Args:
        sreda_server_connection (str): Строка подключения к серверу SREDA.

    Returns:
        dict: Словарь, отображающий имена модулей.
    """
    server_modules_map = {}

    with grpc.insecure_channel(sreda_server_connection) as channel:
        stub = ModulesServiceStub(channel)
        modules_stream = stub.GetModules(Empty())
        modules_info = list(next(modules_stream).list)

    for module_info in modules_info:
        server_modules_map[module_info.info.name] = {'id': module_info.id.id}

        if module_info.type == ModuleType.TimbrelOverIpModuleType:
            endpoint = module_info.settings.json.fields['selfEndpoint']
            server_modules_map[module_info.info.name]['endpoint'] = endpoint.string_value

    return server_modules_map


def get_module_id_by_name(modules_map: dict, module_name: str) -> str:
    """Получить идентификатор модуля по его id.

    Args:
        modules_map (dict): Словарь, отображающий имена модулей.
        module_name (str): Имя модуля, для которого требуется получить идентификатор.

    Returns:
        str: Идентификатор указанного модуля.

    Raises:
        ModuleNameError: Если указанное имя модуля не найдено в modules_map.
    """
    pre_modules_map = {_name.upper(): settings['id'] for _name, settings in modules_map.items()}
    try:
        module_id = pre_modules_map[module_name]
    except KeyError as exp:
        raise ModuleNameError(f'Module {module_name} not found in map: {pre_modules_map}') from exp
    return module_id


def check_sreda_module(modules_map: dict, active_module: str):
    """Проверка наличия модуля в карте модулей.

    Args:
        modules_map: карта всех доступных модулей
        active_module: имя проверяемого модуля

    Raises:
        ModuleNotFoundError: Если указанный модуль не найден в карте модулей.
    """
    modules = [module.upper() for module in modules_map.keys()]
    if active_module not in modules:
        raise ModuleNotFoundError(f'Module {active_module} not found in map: {modules_map}')


def get_active_module_info(sreda_server_connection: str, target_module_name: str) -> tuple:
    """Получить информацию об активном модуле (имя и тип).

    Args:
        sreda_server_connection (str): Строка с адресом подключения к серверу SREDA.
        target_module_name (str): Имя целевого модуля.

    Returns:
        tuple: Кортеж, содержащий сгенерированное имя и тип модуля.

    Raises:
        ModuleNotFoundError: Если модуль с указанным именем не найден.
    """
    target_module_name_upper = target_module_name.upper()
    with grpc.insecure_channel(sreda_server_connection) as channel:
        stub = ModulesServiceStub(channel)
        modules_stream = stub.GetModules(Empty())
        modules_info = list(next(modules_stream).list)
        for module_info in modules_info:
            if module_info.info.name.upper() == target_module_name_upper:
                return module_info.info.name, module_info.type
    raise ModuleNotFoundError(f'Module {target_module_name_upper} not found in map')


def get_server_info(channel):
    """
    Получение информации о сервере SREDA.

    Args:
        channel: gRPC канал.

    Returns:
        server_info: Информация о сервере.
    """
    bind_stub = bind_pb2_grpc.BindServiceStub(channel)
    request = common_pb2.Empty()
    return next(bind_stub.GetInfo(request))


def check_version(sreda_version):
    """
    Проверка версии SREDA.

    Args:
        sreda_version (str): Версия SREDA.

    Логирует ошибку, если версия не одобрена.
    """
    version_parts = sreda_version.split('.')
    if len(version_parts) >= 2:
        major, minor = map(int, version_parts[:2])
        current_version = (major, minor)

        if current_version not in APPROVED_VERSIONS:
            approved_versions_str = ', '.join(f'{major}.{minor}+' for major, minor in APPROVED_VERSIONS)
            logger.error(f'Version {major}.{minor}+ is not approved. List of approved versions: {approved_versions_str}')
    else:
        logger.error(f'Unknown SREDA version: {sreda_version}')


def check_sreda_support(sreda_server_connection: str):
    """
    Проверка, что текущая версия SREDA поддерживается и одобрена.

    Args:
        sreda_server_connection (str): Строка подключения к серверу SREDA.

    Логирует ошибку, если версия не одобрена, но не прерывает выполнение.
    """
    try:
        with grpc.insecure_channel(sreda_server_connection) as channel:
            server_info = get_server_info(channel)
            sreda_version = server_info.version
            logger.info(f'Current SREDA server version: {sreda_version}')
            check_version(sreda_version)
    except grpc.RpcError as rpc_err:
        logger.error(f'Error while checking SREDA version: {rpc_err}')


def get_server_api_version(sreda_server_connection: str) -> str:
    """Получить версию API сервера."""
    temp_channel = grpc.insecure_channel(sreda_server_connection)
    bind_stub = BindServiceStub(temp_channel)
    response_iterator = bind_stub.GetInfo(Empty())
    server_info = next(response_iterator)
    api_version = server_info.api_version
    temp_channel.close()
    return api_version


def get_package_version(package_name: str) -> str:
    """Получить версию используемого API."""
    return pkg_version(package_name)


def compare_versions(client_version_str: str, server_version_str: str):
    """Сравнить версию API клиента и сервера и предупредить при различии."""
    client_version = version.parse(client_version_str)
    server_version = version.parse(server_version_str)
    if server_version > client_version:
        logger.warning(
            f"The latest compatible API version is {client_version_str}, "
            f"but the server is using {server_version_str}. Possible compatibility issues."
        )


def check_api_version(sreda_server_connection: str):
    """Проверить версию API сервера и сравнить ее с клиентской версией."""
    try:
        server_api_version = get_server_api_version(sreda_server_connection)
        client_api_version = get_package_version('stw-sreda-api')
        compare_versions(client_api_version, server_api_version)
    except grpc.RpcError as exc:
        logger.error(f'Failed to get server API version: {exc}')
    except Exception as exc:
        logger.error(f'Error during API version check: {exc}')
