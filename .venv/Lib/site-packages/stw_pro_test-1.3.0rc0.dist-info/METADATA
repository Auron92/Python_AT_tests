Metadata-Version: 2.4
Name: stw-pro-test
Version: 1.3.0rc0
Summary: Framework для написания проверок (тестов).
Author-email: "S.Lukyanov" <s.lukyanov@1440.space.com>
Requires-Python: <3.11,>=3.10
Requires-Dist: allure-pytest<3,>=2.13.5
Requires-Dist: graveyard-upload<0.3,>=0.2.3
Requires-Dist: loguru>=0.6.0
Requires-Dist: marshmallow<4,>=3.26.1
Requires-Dist: matplotlib<4,>=3.10.0
Requires-Dist: notification-bot<0.3,>=0.2.4
Requires-Dist: packaging~=25.0
Requires-Dist: pillow<12,>=11.0.0
Requires-Dist: pytest-check<3,>=2.4.1
Requires-Dist: pytest<9,>=8.3.3
Requires-Dist: pyyaml<7,>=6.0.2
Requires-Dist: toml<0.11,>=0.10.2
Requires-Dist: tqdm<5,>=4.66.5
Requires-Dist: typer<=0.11
Provides-Extra: engine
Requires-Dist: stw-brokers-sreda<2,>=1; extra == 'engine'
Requires-Dist: stw-gen-sample3-api<2; extra == 'engine'
Requires-Dist: stw-py-api-runtime<2,>=1; extra == 'engine'
Description-Content-Type: text/markdown

# Framework для написания проверок (тестов)

## TL;DR

[Как писать проверки.](docs/howto/write_tests.md)

## Мотивация

### Много технологий

В нашей компании используется определенный набор технологий/сервисов:

* Allure
* XRAY
* ATF
* SREDA
* graveyard
* minio
* SCPI
* CAN
* ...

### Много реализаций

В нашей компании много способных команд, которые сталкиваются с необходимостью взаимодействия с этими продуктами. И каждая команда решает эту проблему по-своему.

### Одно желание

Хочется избежать выполнения двойной (тройной) работы там, где это возможно. И, особенно там, где в этом нет желания.

## Что дает?

### Pytest

Если вы уже пишете на pytes/unittest у вас этого не отберут.
[Подробнее о pytest](docs/knowledge_base/pytest.md)

### Логирование

#### Непосредственно логи

Создание текстовых логов по умолчанию.
Используется Loguru, который позволяет делать кастомные обработчики логов. Например, мы дублировали логи в удаленную базу.

#### Механизм фонового логирования

Есть наборы фоновых watcher-ов:

* для ТМ приборов
* для наземного измерительного оборудования
С возможностью выполнять действия при выходе параметров за заданные границы

### Создание отчета(ов)

Pytest сам по себе умеет работать с популярными форматами отчётов. [Подробнее](https://docs.pytest.org/en/stable/how-to/output.html#creating-resultlog-format-files)

### Публикация результатов

* Результаты выполнения тестов можно без труда опубликовать в **Allure**. [Подробнее.](docs/howto/autoupload.md)
* Связка с Jira - изменение статуса задач с добавлением комментариев (ИЦ specific)
* Связка с XRAY - простановка статуса и прикрепление лога для тестов внутри TestExecution

### Взаимодействие с измерительным оборудованием

Для взаимодействия с измерительным оборудованием есть высокоуровневые прослойки.
Например, для ИП класс с методами `turn_on`, `turn_off`, `set_settings`, `get_status`. Всё это уже доступно через фикстуры.

### Конфигурация

Предлагается конфигурация с использованием .ini файла

А также при помощи использования ENV переменных.

[Подробнее о конфигурировании.](docs/howto/configure.md)
[Доступные опции](docs/protest/options.md)

### Утилиты

В ходе решения многих задач были созданы маленькие утилиты для внутреннего использования:

* "Безопасная" перепрошивка прибора
* Обработка ответов на команды
* Скачивание файлов с прибора и преобразование в нужный формат

## Для чего?

1) Избегать двойной и более работы.
2) Направить усилия заинтересованных в одно русло (сюда, конечно же)

## Для кого?

Для тех, кто:

* итак использует pytest не заметит разницы, но бесплатно получит ряд преимуществ.
* желает писать проверки для приборов
* хочет заниматься непосредственно решением задачи проверки прибора/ПО

## Как?

## Это обычный pytest

Здесь ничего не изобретается и не меняется исходный код pytest.
Для расширения функционала используются стандартные механизмы, описании в документации.
Это означает, что любое поведение может быть перегружено или отключено вовсе.

### Резюмируя

Для пользователя всё выглядит как обычный pytest с налётом утилит и некоторых автоматизаций.

Подробнее о том, как [начать писать проверки.](docs/howto/write_tests.md)
