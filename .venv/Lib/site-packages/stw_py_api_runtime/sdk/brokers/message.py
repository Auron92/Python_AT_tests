"""Средства для работы с сообщениями по протоколу Timbrel 2.0.

Спецификация протокола: https://c.1440.space/pages/viewpage.action?pageId=294478043
Значительная часть логики поддержана конкретно в брокере.
"""
import enum
import re
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional

from stw_py_api_runtime.sdk.exceptions import ValidationError


class Priority(enum.Enum):
    """Приоритет у сообщения согласно протоколу."""

    HIGHEST = 0
    HIGH = 1
    LOW = 2
    LOWEST = 3


class PriorityConverter(ABC):
    """Преобразователь из общего типа в транспортный.

    Необходимо, так как у брокера по транспортному уровню приходит тип,
    определенный этим транспортом. А в рантайме приоритет общий и от транспорта не зависит.
    """

    @classmethod
    @abstractmethod
    def transport_to_protocol(cls, value: object) -> Priority:
        """Преобразовать значение транспортного типа в общий."""
        raise NotImplementedError

    @classmethod
    @abstractmethod
    def protocol_to_transport(cls, value: Priority) -> object:
        """Преобразовать значение общего типа в транспортный."""
        raise NotImplementedError


@dataclass
class DeviceAddress:
    """Адрес прибора поверх CAN или IP.

    Прибор может одновременно работать по обоим каналам.
    Пример node_id: 0x0.
    Пример endpoint: 127.0.0.1:2222 (если IPv4) или [fec2::10]:88 (если IPv6).
    """

    node_id: Optional[int] = None
    endpoint: Optional[str] = None

    def __post_init__(self):
        self._validate()

    @property
    def main(self):
        """Основной адрес, если заданы оба, то node id."""
        # прибор может быть доступен по обоим транспортам, мы шлем пока одним вариантом
        if self.node_id:
            return self.node_id
        return self.endpoint

    def __eq__(self, other):
        if isinstance(other, int):
            return self.node_id == other
        if isinstance(other, str):
            return self.endpoint == other
        if isinstance(other, self.__class__):
            by_node = self.node_id == other.node_id and (
                self.node_id is not None and other.node_id is not None
            )
            by_endpoint = self.endpoint == other.endpoint and (
                self.endpoint is not None and other.endpoint is not None
            )
            return by_node or by_endpoint

    def __hash__(self):
        return hash((self.node_id, self.endpoint))

    def __str__(self):
        res = []
        if self.node_id is not None:
            res.append(f'node {hex(self.node_id)}')  # noqa: WPS237
        if self.endpoint is not None:
            res.append(f'ip {self.endpoint}')
        return ' '.join(res)

    # flake8: noqa: W503
    def _validate_endpoint(self):
        """Валидация ip адреса прибора."""
        if not self.endpoint:
            return

        regexp_ipv4_pattern = (
            r'^(((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}):'
            + '([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|'
            + '65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$')

        regexp_ipv6_pattern = (
            r'^\[(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|'
            + r'([0-9a-fA-F]{1,4}:){1,7}:|'
            + '([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|'
            + '([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|'
            + '([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|'
            + '([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|'
            + '([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|'
            + '[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|'
            + ':((:[0-9a-fA-F]{1,4}){1,7}|:)|'
            + 'fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|'
            + '::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|'
            + r'1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|'
            + '(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|'
            + '([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|'
            + r'(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|'
            + r'1{0,1}[0-9]){0,1}[0-9]))\]:([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|'
            + '65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$')

        ipv4_match = re.match(regexp_ipv4_pattern, self.endpoint)
        ipv6_match = re.match(regexp_ipv6_pattern, self.endpoint)
        if not ipv4_match and not ipv6_match:
            raise ValidationError('Invalid IP address of the device. '
                             'IP address must be IPv4 (127.0.0.1:2020) '
                             'or IPv6 format ([fec2::10]:11)')

    def _validate(self):
        """Общая валидация и валидация отдельных полей."""
        fields = self.__dataclass_fields__

        for field in fields:
            validate_method = getattr(self, f'_validate_{field}', None)
            if validate_method:
                validate_method()

        if self.node_id is None and self.endpoint is None:
            raise ValidationError('Must be specified node id or ip address, but given nothing.')


@dataclass
class MessageKey:
    """Уникальный ключ сообщения - кем, кому отправлено."""

    client_id: int | str
    server_id: int | str
    cti: int

    def __hash__(self):
        return hash((self.client_id, self.server_id, self.cti))
