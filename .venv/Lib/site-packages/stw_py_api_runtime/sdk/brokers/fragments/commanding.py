"""Переисопльзуемые фрагменты для отправки команд."""
import threading
import time
from abc import abstractmethod
from collections import defaultdict
from dataclasses import dataclass, field
from queue import SimpleQueue
from typing import Dict, List, Optional, Sequence, Tuple

from loguru import logger
from stw_py_api_runtime.gen_classes.custom_types import Command
from stw_py_api_runtime.sdk.brokers.broker_api import CommanderAPI, MessageCreatorAPI, SerializerAPI
from stw_py_api_runtime.sdk.brokers.message import DeviceAddress, MessageKey, Priority
from stw_py_api_runtime.sdk.exceptions import (
    BadArgumentsError, RpcDeadlineError, SendCommandError, TooManyCommandsError,
)

ClientId = int
DeviceId = int
MsgCounter = int
MapKey = Tuple[ClientId, DeviceId, MsgCounter]


@dataclass
class Counter(object):
    """Счетчик сообщений req-rep канала."""

    min_number = 0
    max_number = 4294967295
    number = 0

    def next(self):
        """Вернуть следующее значение счетчика."""
        ans = self.number
        self.number += 1  # noqa: WPS601
        if self.number > self.max_number:
            self.number = self.min_number  # noqa: WPS601
        return ans


@dataclass
class ReqRepCommander(CommanderAPI):
    """Отправка команд и сопоставление rep-ов с ответами на них."""

    timeout: float = 3.0
    retry_sending: bool = False
    sending_tries_count: int = 3
    broadcast_node_id: int = 0
    serializer: Optional[SerializerAPI] = None
    message_creator: Optional[MessageCreatorAPI] = None
    batch_limit: int = 5
    batch_wait_after_sending: float = 0
    active_module: str = field(default_factory=str)
    sender_address: Optional[DeviceAddress] = None

    def send_command_raw(  # noqa: WPS211, WPS210
        self,
        *,
        device_address: DeviceAddress,
        message_id: int,
        command: str,
        extra_retry: bool = True,
        extra_priority: Priority = Priority.LOWEST,
        extra_need_rep: bool = True,
        extra_wait_rep: bool = True,
        extra_timeout: int | None = None,
        **kwargs,
    ) -> object:
        """Отправить команду."""
        args_data = self._serialize_command(command, **kwargs)
        log_str = '(dev id: {0}, module: {1}) Sending {2}, msg id {3}: with args: {4}'.format(
            device_address, self.active_module, command, message_id, kwargs,
        )
        logger.trace(log_str)  # noqa: WPS221
        sending_args = dict(  # noqa: WPS317
            device_address=device_address,
            command=command,
            message_id=message_id,
            extra_priority=extra_priority,
            extra_need_rep=extra_need_rep,
            extra_wait_rep=extra_wait_rep,
            extra_retry=extra_retry,
            extra_timeout=extra_timeout,
            args_data=args_data,
            **kwargs,
        )
        try:
            rep = self._send_method(sending_args)
        except (TimeoutError, IndexError) as exp:
            raise SendCommandError(f'Sending of command {command} failed: {exp}') from exp
        return rep

    def _send_method(self, sending_args: dict):
        """Отправить команду методом, выбранным на основе настроек."""
        retry_flag = self.retry_sending
        if sending_args['extra_retry'] is not None:
            retry_flag = sending_args['extra_retry']
        if retry_flag:
            return self._send_with_retry(**sending_args)
        return self._send_once(**sending_args)

    def _send_with_retry(self, *args, **kwargs):
        """Отправить команду с несколькими попытками."""
        for try_idx in range(self.sending_tries_count):
            try:
                return self._send_once(*args, **kwargs)
            except (TimeoutError, RpcDeadlineError) as exp:
                trying = try_idx + 1
                logger.warning(
                    f'Failed message sending (try: {trying}, max: {self.sending_tries_count}): {exp}',
                )
        raise IndexError(f'Exceeded maximum retrying count ({self.sending_tries_count})')

    @abstractmethod
    def _send_once(
        self,
        *,
        device_address: DeviceAddress,
        command: str,
        message_id: int,
        extra_priority: Priority = Priority.LOWEST,
        extra_need_rep: bool = True,
        extra_wait_rep: bool = True,
        extra_timeout: int | None = None,
        args_data: bytes | dict,
    ):
        """Отправить команду разово."""
        raise NotImplementedError

    def _serialize_command(self, command: str, **kwargs) -> tuple:
        """Сериализация аргументов команды."""
        try:
            args_bytes = self.serializer.serialize_cmd_args(**kwargs)
        except Exception as exc:
            raise BadArgumentsError(f'Error of command args serialization: {exc}')

        return args_bytes

    def _wait_for_response(self, extra_wait_rep: bool, device_address: DeviceAddress) -> bool:
        if device_address.node_id == self.broadcast_node_id:
            logger.trace(f'Device id ({device_address.node_id}) is broadcast address - not waiting for response')
            return False
        return extra_wait_rep


@dataclass
class QueueReqRepCommander(ReqRepCommander):
    """Отправка команд и сопоставление rep-ов с ответами на них.

    Реализовано через очереди.
    """

    # очередь сообщений на отправку по каналу req-rep
    req_queue: SimpleQueue = field(default_factory=SimpleQueue)
    # счетчик сообщений в req rep канале
    _counter: Counter = field(default_factory=Counter)
    # отправленные сообщения
    _req_map: Dict[MessageKey, object] = field(default_factory=dict)
    # принятые сообщения
    _rep_map: Dict[MessageKey, object] = field(default_factory=dict)
    # эвенты ожидания сообщений
    _msg_event_map: Dict[MessageKey, threading.Event] = field(
        default_factory=lambda: defaultdict(threading.Event),
    )
    active_module: str = field(default_factory=str)

    def add_req(self, msg, map_key: MessageKey):
        """Добавить сообщение-запрос в очередь на отправку сообщений."""
        self._msg_event_map[map_key].clear()
        self._req_map[map_key] = msg

    def pop_req(self, map_key: MessageKey):
        """Изъять сообщение-запрос из очереди."""
        self._msg_event_map.pop(map_key, None)
        self._req_map.pop(map_key, None)

    def add_rep(self, msg, map_key: Optional[MessageKey] = None):
        """Добавить сообщение-ответ в очередь полученных сообщений, пометить эвент."""
        map_key = map_key or self.message_creator.get_in_message_key(msg)

        if map_key not in self._req_map:
            # not awaited rep-message (not our command)
            return
        self._req_map.pop(map_key)
        self._rep_map[map_key] = msg
        self._msg_event_map[map_key].set()

    def wait_rep(self, map_key: MessageKey, timeout: float) -> bool:
        """Ожидать сообщение-ответ."""
        return self._msg_event_map[map_key].wait(timeout)

    def pop_rep(self, map_key: MessageKey) -> object:
        """Изъять сообщение-ответ из очереди."""
        self._msg_event_map.pop(map_key)
        return self._rep_map.pop(map_key)

    def send_command_batch(
        self,
        device_address: DeviceAddress,
        commands: List[Command],
        priority: Priority = Priority.LOWEST,
    ):
        """
        Команда для параллельной отправки до N сообщений.

        Args:
            device_address: адрес прибора
            commands: список объектов, описывающих параметры команды

        Returns:
            Возвращает список ответов на команды.
        """
        commands_count = len(commands)
        if commands_count > self.batch_limit:
            raise TooManyCommandsError(f'Ожидаемое {self.batch_limit}, реальное {commands_count}')

        types_map = self.query_messages(device_address, commands, priority)

        cmds_responses = []
        for key, command in types_map.items():
            if not self.wait_rep(map_key=key, timeout=0):
                raise SendCommandError(f'Ответ на команду {command.name} не доставлен.')

            rep = self.pop_rep(map_key=key)
            cmds_responses.append(rep)

        return cmds_responses

    def query_messages(
        self,
        device_address: DeviceAddress,
        commands: List[Command],
        priority: Priority = Priority.LOWEST,
        need_rep: bool = True,
    ) -> dict:  # noqa: WPS210
        """
        Формирование посылки из N сообщений.

        Args:
            device_address: адрес прибора
            commands: список команд
            priority: приоритет для всех команд
            need_rep: если True, ждать ответ на все команды
        """
        types_map = {}

        for command in commands:
            args_data = self.serializer.serialize_cmd_args(**command.args)
            counter = self._counter.next()
            message = self.message_creator.create_command_message(
                receiver_address=device_address,
                sender_address=self.sender_address,
                message_id=command.message_id,
                counter=counter,
                args_data=args_data,
                priority=priority,
                need_rep=need_rep,
            )
            key = self.message_creator.get_out_message_key(message)
            types_map[key] = command
            self.add_req(msg=message, map_key=key)
            self.req_queue.put(message)
            if self.batch_wait_after_sending:
                time.sleep(self.batch_wait_after_sending)

        self.wait_responses(types_map.keys())
        return types_map

    def wait_responses(self, req_keys: Sequence, timeout: int | None = None):
        """Ожидание ответа на команду, с req_key.

        @param: req_keys - это ключи, идентифицирующие ответы сервера
        @param: timeout (сек.)
        """
        timeout = timeout or self.timeout

        for req_key in req_keys:
            start_time = time.time()
            if not self.wait_rep(map_key=req_key, timeout=timeout):
                break
            timeout = max(
                0,
                timeout - (time.time() - start_time),
            )

    def _send_once(
        self,
        *,
        device_address: DeviceAddress,
        command: str,
        message_id: int,
        extra_priority: Priority,
        extra_need_rep: bool = True,
        extra_wait_rep: bool = True,
        extra_timeout: int | None = None,
        args_data: bytes,
        **kwargs,
    ):
        """Отправить команду разово."""
        counter = self._counter.next()
        message = self.message_creator.create_command_message(
            receiver_address=device_address,
            sender_address=self.sender_address,
            message_id=message_id,
            counter=counter,
            args_data=args_data,
            priority=extra_priority,
            need_rep=extra_need_rep,
        )
        message_key = self.message_creator.get_out_message_key(message)
        self.add_req(msg=message, map_key=message_key)
        self.req_queue.put(message)
        log_str = '(dev id: {0}, module: {1}) Command {2} sent with args:'.format(
            device_address, self.active_module, command,
        )
        logger.trace(log_str)

        if not self._wait_for_response(extra_wait_rep, device_address):
            return  # noqa: WPS324

        timeout = extra_timeout or self.timeout
        if self.wait_rep(map_key=message_key, timeout=timeout):
            return self.pop_rep(map_key=message_key)

        self.pop_req(message_key)
        raise TimeoutError('Response for command not received')
