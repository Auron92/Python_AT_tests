# flake8 noqa: W503
"""Описание АПИ брокеров."""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from threading import Event
from typing import Any, Callable, Generic, List, Optional, Tuple, Type, TypeVar, Union  # noqa: WPS235
from uuid import UUID

from loguru import logger
from stw_py_api_runtime.gen_classes.custom_types import Command
from stw_py_api_runtime.gen_classes.telemetry.parse import Message, RepMessage, ReqMessage
from stw_py_api_runtime.gen_classes.telemetry.predicates import Predicate, StreamMsgChannel
from stw_py_api_runtime.gen_classes.types.returned_types import ReturnTypes
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.sdk.brokers.message import DeviceAddress, MessageKey, Priority
from stw_py_api_runtime.sdk.exceptions import DeserializeError

TransportMessage = TypeVar('TransportMessage')
TMMessage = Any
TmCallback = Callable[[TMMessage], bool]
PredicateOrCallable = Union['Predicate', Callable]


class SerializerAPI(ABC):
    """Преобразование транспортных данных (из tm_loop или чего-то подобного и обратно."""

    _type: str = ''

    @abstractmethod
    def deserialize_tm(self, tm_data, type_class):
        """Получение объекта с ТМ данными из транспортных данных."""
        raise NotImplementedError

    @abstractmethod
    def serialize_cmd_args(self, **kwargs):
        """Преобразование аргументов команд в формат для транспортного уровня."""
        raise NotImplementedError

    def serialize_cmd_rep(self, message_data: Message, variable_types: ReturnTypes):
        """Преобразование ответа на команду в формат для транспортного уровня."""
        raise NotImplementedError

    def serialize_tm_rep(self, message_data: Message):
        """Преобразование ТМ ответа в формат для транспортного уровня."""
        raise NotImplementedError

    def serialize_tm(self, message_data: Message):
        """Преобразование ТМ в формат для транспортного уровня."""
        raise NotImplementedError

    def _raise_deserialize_error(self, type_class, tm_data, exc):
        """Вывести ошибку десериализации с подробной информацией."""
        raise DeserializeError(f'Сan not deserialize data {tm_data} to type class {type_class}. Error: {exc}') from exc


class TelemetryObserverAPI(ABC):
    """Класс для обработки телеметрических сообщений."""

    @abstractmethod
    def add_subscriber(
        self, predicate: PredicateOrCallable, use_single: bool, callback: Callable,
    ) -> UUID:
        """Добавление подписчика на сообщение, которое определяется predicate."""
        raise NotImplementedError

    @abstractmethod
    def remove_subscriber(self, subscriber_id: UUID) -> None:
        """Удаление подписчика."""
        raise NotImplementedError

    @abstractmethod
    def notify_subscribers(self, message, channel: StreamMsgChannel):
        """Уведомить подписчиков о получении сообщения."""
        raise NotImplementedError


class MessageCreatorAPI:
    """Создание и обработка сообщений транспортного уровня."""

    @staticmethod
    def create_command_message(*args, **kwargs) -> object:
        """Создать сообщение команды."""
        raise NotImplementedError

    @staticmethod
    def create_command_message_rep(*args, **kwargs) -> object:
        """Создать сообщение - ответ на команду."""
        raise NotImplementedError

    @staticmethod
    def create_event_message(*args, **kwargs) -> object:
        """Создать сообщение - телеметрию."""
        raise NotImplementedError

    @staticmethod
    def create_tm_message(*args, **kwargs) -> object:
        """Создать телеметрическое сообщение."""
        raise NotImplementedError

    @staticmethod
    def get_in_message_key(message: object) -> MessageKey:
        """Получить ключ-идентификатор пришедшего в брокер сообщения по его полям.

        Здесь receiver_id - мы (клиент), а sender_id - то, откуда пришло (сервер).
        """
        raise NotImplementedError

    @staticmethod
    def get_out_message_key(message: object) -> MessageKey:
        """Получить ключ-идентификатор отправляемого брокером сообщения по его полям.

        Здесь sender_id - мы (клиент), а receiver_id - то, куда отправляем (сервер).
        """
        raise NotImplementedError

    @staticmethod
    def get_message_id(message: object) -> int:
        """Получить id сообщения из его тела."""
        raise NotImplementedError

    @staticmethod
    def get_device_id(message: object) -> int:
        """Получить id прибора из тела сообщения."""
        raise NotImplementedError

    @staticmethod
    def get_channel(message: object) -> StreamMsgChannel:
        """Получить канал, по которому пришло сообщение."""
        raise NotImplementedError

    @staticmethod
    def is_rep(message: object) -> bool:
        """Получить is_rep сообщения."""
        raise NotImplementedError


class CommanderAPI(ABC):
    """Отправка команд и сопоставление с ответами ина них."""

    # timeout отправки сообщений в секундах
    timeout: float = 3.0
    # повторять отправку команды
    retry_sending: bool = False
    # количество попыток на отправку команды
    sending_tries_count: int = 3
    # адрес, по которому отправляются broadcast команды и не приходит ответ
    broadcast_node_id: int = 0
    # апи для сериализации аргументов команды
    serializer: Optional[SerializerAPI] = None
    # апи для создания и обработки сообщений
    message_creator: Optional[MessageCreatorAPI] = None

    @abstractmethod
    def send_command_raw(  # noqa: WPS211
        self,
        *,
        device_address: DeviceAddress,
        message_id: int,
        command: str,
        extra_retry: bool = True,
        extra_priority: Priority = Priority.LOWEST,
        extra_need_rep: bool = True,
        extra_wait_rep: bool = True,
        extra_timeout: int | None = None,
        **kwargs,
    ) -> object:
        """Отправить команду."""
        raise NotImplementedError


class BrokerAPI(Generic[TransportMessage]):  # noqa: WPS338
    """
    API любого брокера.

    Args:
        :param commander (CommanderAPI) - Обработчик команд и сопоставления с ответами ина них;

        :param message_creator (MessageCreatorAPI) - Обработчик сообщений транспортного уровня;

        :param tm_observer (TelemetryObserverAPI) - Обработчик телеметрических сообщений;

        :param tm_catcher_class (Type['TmCatcherAPI']) - Интерфейс обработчика тм сообщений;

        :param event_catcher_class (Type['EventCatcherAPI']) - Интерфейс обработчика событий;

        :param cmd_catcher_class (Type['CmdCatcherAPI']) - Интерфейс обработчика команд;

        :param predicate_class (Type[Predicate]) - Интерфейс соответствия сообщения какому-либо критерию;

        :param serializer (SerializerAPI) - Интерфейс преобразования транспортных данных;

        :param timeout (float) - Таймаут ожидания ответа на команду;

        :param retry_sending (bool) -  Если True, повторно отправлять команды при отсутствии ответа;

        :param sending_tries_count (int) - Количество попыток запроса при retry_sending=True;

        :param safe_init (bool) - Если True, брокер при старте ждет первое ТМ сообщение;

        :param safe_init_timeout (int) - Таймаут ожидания первого ТМ сообщения;

        :param raise_on_error_msg (bool) - Если True, при получении ошибочного ответа на команду, будет рейзится ошибка;

        :param active_module (str) - Активный модуль;
    """

    commander: CommanderAPI
    message_creator: MessageCreatorAPI
    tm_observer: TelemetryObserverAPI
    tm_catcher_class: Type['TmCatcherAPI']
    event_catcher_class: Type['EventCatcherAPI']
    cmd_catcher_class: Type['CmdCatcherAPI']
    predicate_class: Type[Predicate]
    serializer: SerializerAPI
    timeout: float = 3.0
    retry_sending: bool = False
    sending_tries_count: int = 3
    safe_init: bool = False
    safe_init_timeout: int = 10
    raise_on_error_msg: bool = True
    active_module: str = field(default_factory=str)
    _telemetry_started: Event = None
    _address: DeviceAddress = None

    @abstractmethod
    def change_active_module(self, new_module):
        """Смена активного модуля."""
        raise NotImplementedError

    @abstractmethod
    def get_active_module(self):  # noqa: WPS615
        """Получить активный модуль."""
        return self.active_module

    @abstractmethod
    def send_command_raw(  # noqa: WPS211
        self,
        device_address: DeviceAddress,
        command: str,
        message_id: int,
        return_types: ReturnTypes,
        extra_retry: bool = True,
        extra_priority: Priority = Priority.LOWEST,
        extra_need_rep: bool = True,
        extra_wait_rep: bool = True,
        extra_timeout: int | None = None,
        **kwargs,
    ) -> Message:
        """
        Отправить команду.

        Args:
            device_address: адрес прибора
            command: полное имя команды
            message_id: id сообщения команды из описания прошивки
            return_types: возможные типы ответа по описанию прошивки
            extra_retry: если True, при отсутствии ответа отправлять команду повторно (кол-во раз - sending_tries_count)
            extra_priority: приоритет команды согласно протоколу Timbrel
            extra_need_rep: если True, требуется ответ на команду со стороны прибора
            extra_wait_rep: если True, нужно дождаться ответ от прибора
            extra_timeout: сколько (сек) ждать ответ
            kwargs: аргументы команды

        Returns:
            Объект, завернутый в тип из пайген согласно описанию прошивки (базовый тип Message)
        """
        raise NotImplementedError

    @abstractmethod
    def send_transport_messages(self, messages: list):
        """Отправить на активный модуль массив сырых транспортных сообщений."""
        raise NotImplementedError

    @abstractmethod
    def send_command_batch(
        self,
        device_address: DeviceAddress,
        commands: List[Command],
    ):
        """
        Команда для параллельной отправки до N сообщений.

        Args:
            device_address: адрес прибора
            commands: список объектов, описывающих параметры команды

        Returns:
            Возвращает список ответов на команды.
        """
        raise NotImplementedError

    @abstractmethod
    def subscribe_to_tm(
        self,
        *,
        predicate: Predicate,
        callback: Callable,
        use_single: bool,
    ) -> UUID:
        """Подписаться на получение определенного сообщения.

        Возвращает идентификатор подписчика.
        """
        raise NotImplementedError

    @abstractmethod
    def unsubscribe_from_tm(self, consumer_id):
        """Отписаться от получения определенного сообщения."""
        raise NotImplementedError

    @abstractmethod
    def unpack_transport_message(
        self,
        message: object,
        channel: str,
        data_types: ReturnTypes,
    ) -> Tuple[object, Type[Serializable]]:
        """Вытащить полезные данные и их тип из транспортного сообщения.

        На входе message транспортного уровня, на выходе кортеж, где первый элемент - полезные данные,
        второй - pygen тип, в который их надо десериализовать.
        Класс объект определяется из возможных типов сообщения - data_types.
        Этот метод вызывается ТОЛЬКО на тех сообщениях, в которых кто-то "заинтересован" (не на каждое сообщение).
        """
        raise NotImplementedError

    @abstractmethod
    def get_message_meta(self, message: object) -> dict:
        """Получить метаинформацию из message транспортного уровня."""
        raise NotImplementedError

    @abstractmethod
    def get_message_data(self, message: object) -> object:
        """Получить полезные данные из сообщения."""
        raise NotImplementedError

    @abstractmethod
    def is_message_rep(self, message: object) -> bool:
        """Возвращает True, если сообщение является rep - ответом на команду."""
        raise NotImplementedError

    @abstractmethod
    def init(self):
        """Метод для подключений и выделения ресурсов.

        Всегда вызывается перед началом работы с брокером.
        """
        raise NotImplementedError

    @abstractmethod
    def stop(self):
        """Освобождение ресурсов брокера.

        Рекомендуется вызывать его по окончанию работы.
        """
        return self._stop()

    @abstractmethod
    def _stop(self):
        """Освобождение ресурсов брокера."""
        raise NotImplementedError

    def wait_first_tm(self, timeout):
        """Дождаться первого сообщения."""
        if not self.safe_init:
            return
        logger.info(f'Ожидание первого сообщения (таймаут {timeout} с)...')
        if not self._telemetry_started.wait(timeout):
            raise TimeoutError(f'Включено ожидание сообщения, но за таймаут {timeout} ни одного не было получено')


TmType = TypeVar('TmType')


@dataclass
class CatcherAPI(ABC, Generic[TmType]):
    """Описание интерфейса обработчика сообщений."""

    device_address: DeviceAddress
    broker: BrokerAPI
    name: str
    msg_type: Serializable
    msg_id: int
    req_id: int
    rep_id: int

    timeout: int = 3
    stats = None
    _consumer_id = None
    _tm_message_id: int = None

    @abstractmethod
    def start(self):
        """Запустить получение сообщений."""
        raise NotImplementedError

    @abstractmethod
    def stop(self):
        """Остановить получение сообщений."""
        raise NotImplementedError


@dataclass
class TmCatcherAPI(CatcherAPI, Generic[TmType]):
    """Описание интерфейса обработчика тм сообщений."""

    @abstractmethod
    def wait(
        self,
        timeout: int = None,
        condition: Callable = None,
    ) -> TmType:
        """Вернуть первое полученное сообщение."""
        raise NotImplementedError

    @abstractmethod
    def get_once(self) -> TmType:
        """Получить разово синхронно."""
        raise NotImplementedError

    @abstractmethod
    def copy(self) -> TmType:
        """Создать копию объекта."""
        raise NotImplementedError

    @abstractmethod
    def subscribe(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на телеметрию, кладет в callback десериализованный объект телеметрии типа Message."""
        raise NotImplementedError

    @abstractmethod
    def subscribe_req(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на req телеметрии, вызывает callback когда была запрошена соответствующая телеметрия."""
        raise NotImplementedError

    @abstractmethod
    def subscribe_rep(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на rep, кладет в callback десериализованный объект телеметрии типа Message."""
        raise NotImplementedError

    @abstractmethod
    def enable(self, frequency: Union[Enum, str]):
        """Включить ТМ сообщение и задать ему частоту выдачи."""
        raise NotImplementedError

    @abstractmethod
    def disable(self):
        """Выключить ТМ сообщение."""
        raise NotImplementedError


@dataclass
class EventCatcherAPI(CatcherAPI, Generic[TmType]):
    """Описание интерфейса обработчика событий."""

    @abstractmethod
    def wait(
        self,
        timeout: int = None,
        condition: Callable = None,
    ) -> TmType:
        """Вернуть первое полученное сообщение."""
        raise NotImplementedError

    @abstractmethod
    def subscribe(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на событие, возвращает callback при получении события."""
        raise NotImplementedError


CmdRepType = TypeVar('CmdRepType')


@dataclass
class CmdCatcherAPI(ABC, Generic[CmdRepType]):
    """Описание интерфейса обработчика сообщений команд."""

    broker: BrokerAPI
    device_address: DeviceAddress
    name: str
    req_type: Type[ReqMessage]
    rep_type: Type[RepMessage]
    msg_id: Optional[int] = None
    rep_id: Optional[int] = None
    rep_name: Optional[str] = None
    wait_timeout: int = 3

    @abstractmethod
    def __call__(self, *args, **kwargs) -> CmdRepType:
        """Отправка команды."""
        raise NotImplementedError

    @abstractmethod
    def wait(
        self,
        timeout: Optional[int] = None,
        channel: StreamMsgChannel = StreamMsgChannel.REQ_REP,
        condition: Optional[Callable] = None,
    ) -> CmdRepType:
        """Дождаться сообщение с командой."""
        raise NotImplementedError

    @abstractmethod
    def wait_rep(
        self,
        timeout: Optional[int] = None,
        condition: Optional[Callable] = None,
    ) -> CmdRepType:
        """Дождаться сообщение с ответом на команду."""
        raise NotImplementedError

    @abstractmethod
    def subscribe_req(
        self,
        callback: Callable,
        use_single: bool = False,
    ):
        """Подписаться на req команды, вызывает callback когда была запрошена соответствующая команда."""
        raise NotImplementedError

    @abstractmethod
    def subscribe_rep(
        self,
        callback: Callable,
        use_single: bool = False,
    ):
        """Подписаться на rep команды, возвращает в callback десериализованный объект."""
        raise NotImplementedError
