"""Модуль для сериализаци и десериализации сообщений."""
import json
from typing import Iterable

from stw_py_api_runtime.gen_classes.telemetry.parse import Message
from stw_py_api_runtime.gen_classes.types.returned_types import ReturnTypes
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.sdk.brokers.broker_api import SerializerAPI
from stw_py_api_runtime.sdk.exceptions import SerializeError


class JsonSerializer(SerializerAPI):
    """Сериализация/десериализация сообщений в формате json."""

    _type: str = 'JSON'

    def deserialize_tm(self, tm_data, type_class):  # noqa: WPS326
        """Получение объекта с ТМ данными.

        tm_data - словарь (json compatible), содержание которого
        должно отразиться в экземпляре класса type_class.
        """
        try:
            return type_class.from_json(tm_data)
        except Exception as exc:
            self._raise_deserialize_error(type_class, tm_data, exc)

    def serialize_cmd_args(self, **kwargs):
        """Преобразование аргументов команд к json формату."""
        kwarg_dict = {
            arg_name: _arg_to_json(arg_value)
            for arg_name, arg_value in kwargs.items()
        }
        return json.dumps(kwarg_dict)


def _arg_to_json(arg_value):
    """Преобразование аргумента сообщения в json представление."""
    if isinstance(arg_value, Serializable):
        return arg_value.to_json()
    arg_type = type(arg_value)
    arg_info = f'type: {arg_type}, value: {arg_value}'
    raise NotImplementedError(f'serialization of argument not supported: {arg_info}')


class BinSerializer(SerializerAPI):
    """Сериализация/десериализация сообщений в виде байтов."""

    _type: str = 'BIN'

    def deserialize_tm(self, tm_data: bytes, type_class) -> Message:
        """Получение объекта с ТМ данными.

        tm_data - байты, содержание которых
        должно отразиться в экземпляре класса type_class.
        """
        if not isinstance(tm_data, bytes) and isinstance(tm_data, Iterable):
            tm_data = bytes(tm_data)
        try:
            return type_class.from_bin(tm_data)
        except Exception as exc:
            self._raise_deserialize_error(type_class, tm_data, exc)

    def deserialize_cmd_args(self, args_data: bytes, type_class) -> Message:
        """Десериализовать аргументы команды."""
        try:
            return type_class.from_bin(args_data)
        except Exception as exc:
            self._raise_deserialize_error(type_class, args_data, exc)

    def serialize_cmd_args(self, **kwargs) -> bytes:
        """Преобразовать аргументы команды в байты."""
        cmd_bytes = bytearray()
        for _, arg_value in kwargs.items():
            arg_bytes = arg_value.to_bin()
            cmd_bytes.extend(arg_bytes)
        return bytes(cmd_bytes)

    def serialize_cmd_rep(self, message_data: Message, variable_types: ReturnTypes) -> bytes:
        """Преобразовать ответ на команду в байты."""
        type_idx = variable_types.index(type(message_data))
        return _serialize_data_with_type(message_data, type_idx)

    def serialize_tm_rep(self, message_data: Message) -> bytes:
        """Преобразовать ТМ (ответ на команду) в байты."""
        type_idx = ReturnTypes.get_successful_type_idx()
        return _serialize_data_with_type(message_data, type_idx)

    def serialize_tm(self, message_data: Message) -> bytes:
        """Преобразовать ТМ в байты."""
        return message_data.to_bin()


def _serialize_data_with_type(message_data: Message, type_idx: int) -> bytes:
    """Сериализовать сообщение в байты, прибавив спереди индекс типа данных."""
    bin_message_data = message_data.to_bin()
    bin_type_idx = type_idx.to_bytes(1, 'little')
    return bin_type_idx + bin_message_data


def convert_rep_to_target_type(rep_data: object, variable_types) -> object:
    """Принудительно загнать ответ в один из возможных типов.

    Если данные (rep_data) уже одного из возможных типов (variable_types), ничего не делаем.
    Если нет, то предполагаем, что они стандартного питонячьего типа и пробуем загнать в успешный тип.
    """
    orig_rep_type = type(rep_data)
    if orig_rep_type not in variable_types:
        response_type = variable_types.successful_type
        try:
            rep_data = response_type(rep_data)
        except Exception as exp:
            raise SerializeError(
                f'Failed forced convert rep data to {response_type} type. Given {orig_rep_type}. Details: {exp}',
            )
    return rep_data
