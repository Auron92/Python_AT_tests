"""Обработка команд."""
from dataclasses import dataclass
from typing import Callable, Generic, Optional, Type, TypeVar
from uuid import UUID

from loguru import logger
from stw_py_api_runtime.gen_classes.catchers.message import wait_message
from stw_py_api_runtime.gen_classes.cmd_helpers import ensure_instance
from stw_py_api_runtime.gen_classes.telemetry.parse import RepMessage, ReqMessage
from stw_py_api_runtime.gen_classes.telemetry.predicates import StreamMsgChannel
from stw_py_api_runtime.gen_classes.types.returned_types import ReturnTypes
from stw_py_api_runtime.logger_utils import RuntimeAction
from stw_py_api_runtime.sdk.brokers.broker_api import BrokerAPI, CmdCatcherAPI
from stw_py_api_runtime.sdk.brokers.message import DeviceAddress

CmdRepType = TypeVar('CmdRepType')


@dataclass
class CmdCatcher(CmdCatcherAPI, Generic[CmdRepType]):  # noqa: WPS338
    """Класс для работы с сообщениями команд."""

    broker: BrokerAPI
    device_address: DeviceAddress
    name: str
    req_type: Type[ReqMessage]
    rep_type: Type[RepMessage]
    msg_id: int
    rep_id: int
    wait_timeout: int = 3

    def __call__(self, *args, **kwargs) -> CmdRepType:
        """Отправка команды."""
        kwargs = prepare_command_args(self.req_type, *args, **kwargs)
        result_send_cmd = self.broker.send_command_raw(
            device_address=self.device_address,
            command=self.name,
            message_id=self.msg_id,
            return_types=self.rep_type.return_types,
            **kwargs,
        )
        if result_send_cmd:
            log_msg = '(dev id: {0}, module: {1}) Received rep for command {2}: {3}'.format(
                self.device_address, self.broker.get_active_module(), self.name, result_send_cmd,
            )
            logger.log(RuntimeAction.COMMAND, log_msg)
        return result_send_cmd

    def __post_init__(self):
        self.rep_name = f'{self.name}.rep'

    def wait(
        self,
        timeout: Optional[int] = None,
        channel: StreamMsgChannel = StreamMsgChannel.REQ_REP,
        condition: Optional[Callable] = None,
    ) -> CmdRepType:
        """Дождаться сообщения с командой."""
        log_msg_wait_cmd = '(dev id: {0}, module: {1}) Wait cmd {2} with timeout {3}'.format(
            self.device_address, self.broker.get_active_module(), self.name, timeout,
        )
        logger.log(RuntimeAction.COMMAND, log_msg_wait_cmd)
        wait_cmd = wait_message(
            broker=self.broker,
            device_address=self.device_address,
            message_id=self.msg_id,
            message_name=self.name,
            return_types=ReturnTypes(successful_type=self.req_type),
            timeout=timeout or self.wait_timeout,
            channel=channel,
            condition=condition,
            is_from_device=False,
        )
        log_msg_recieve_cmd = '(dev id: {0}, module: {1}) Received msg command {2}: {3}'.format(
            self.device_address, self.broker.get_active_module(), self.name, wait_cmd,
        )
        logger.log(RuntimeAction.COMMAND, log_msg_recieve_cmd)
        return wait_cmd

    def wait_rep(
        self,
        timeout: Optional[int] = None,
        condition: Optional[Callable] = None,
    ) -> CmdRepType:
        """Дождаться сообщения с ответом на команду."""
        log_msg_wait_rep = '(dev id: {0}, module: {1}) Wait rep of cmd {2} with timeout {3}'.format(
            self.device_address, self.broker.get_active_module(), self.name, timeout,
        )
        logger.log(RuntimeAction.COMMAND, log_msg_wait_rep)
        wait_rep_cmd = wait_message(
            broker=self.broker,
            device_address=self.device_address,
            message_id=self.rep_id,
            message_name=self.rep_name,
            return_types=self.rep_type.return_types,
            timeout=timeout or self.wait_timeout,
            channel=StreamMsgChannel.REQ_REP,
            condition=condition,
        )
        log_recv_cmd = '(dev id: {0}, module: {1}) Received rep on cmd {2}: {3}'.format(
            self.device_address, self.broker.get_active_module(), self.name, wait_rep_cmd,
        )
        logger.log(RuntimeAction.COMMAND, log_recv_cmd)
        return wait_rep_cmd

    def subscribe_req(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на req команды, вызывает callback когда была запрошена соответствующая команда."""
        def internal_cb(transport_msg):
            req_message, _ = self.req_type.from_bin(transport_msg.data)
            callback(req_message)

        predicate = self.broker.predicate_class(
            message_id=self.msg_id,
            device_id=self.device_address.node_id,
            channel=StreamMsgChannel.REQ_REP,
            ip_address=self.device_address.endpoint,
            is_from_device=False,
        )
        return self.broker.subscribe_to_tm(
            predicate=predicate,
            callback=internal_cb,
            use_single=use_single,
        )

    def subscribe_rep(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на rep команды, возвращает в callback десериализованный объект."""
        def internal_cb(transport_msg):
            rep_message, _ = self.rep_type.from_bin(transport_msg.data)
            callback(rep_message.value)

        predicate = self.broker.predicate_class(
            message_id=self.rep_id,
            device_id=self.device_address.node_id,
            channel=StreamMsgChannel.REQ_REP,
            ip_address=self.device_address.endpoint,
            is_from_device=True,
        )
        return self.broker.subscribe_to_tm(
            predicate=predicate,
            callback=internal_cb,
            use_single=use_single,
        )


def prepare_command_args(req_type: Type[ReqMessage], *args, **kwargs) -> dict:
    """Преобразовать аргументы команд в конечные типы.

    В args могут содержаться аргументы команды, переданные в неименованном виде.
    В kwargs могут содержаться именованные аргументы и дополнительные, не имеющие отношения к прошивке.
    """
    firmware_args = {}

    for idx, (arg_name, arg_type) in enumerate(req_type.name_and_type_of_args()):
        arg_value = kwargs[arg_name] if arg_name in kwargs else args[idx]
        new_value = ensure_instance(arg_value, arg_type)
        firmware_args[arg_name] = new_value

    kwargs.update(firmware_args)
    return kwargs
