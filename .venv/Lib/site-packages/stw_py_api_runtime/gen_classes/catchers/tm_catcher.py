"""Вспомогательный класс для получения ТМИ.

При создании принимает device_id: int и broker: SredaBroker.
"""
import copy
import time
from enum import Enum
from typing import Callable, Generic, TypeVar, Union
from uuid import UUID

from loguru import logger
from stw_py_api_runtime.gen_classes.catchers.catcher import BaseCatcher
from stw_py_api_runtime.gen_classes.catchers.statistic import Stats
from stw_py_api_runtime.gen_classes.cmd_helpers import average_tm_messages
from stw_py_api_runtime.gen_classes.gen_device import GenDevice, GenTm
from stw_py_api_runtime.gen_classes.telemetry.parse import ReqMessage
from stw_py_api_runtime.gen_classes.telemetry.predicates import StreamMsgChannel
from stw_py_api_runtime.gen_classes.types.returned_types import ReturnTypes
from stw_py_api_runtime.logger_utils import RuntimeAction
from stw_py_api_runtime.sdk.brokers.broker_api import BrokerAPI, CatcherAPI, TmCatcherAPI

TmType = TypeVar('TmType')


class TmCatcher(BaseCatcher, TmCatcherAPI, Generic[TmType]):  # noqa: WPS338
    """Получение телеметрии."""

    _wait_map = {}

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._req_name = f'{self.name}.req'
        self._rep_name = f'{self.name}.rep'
        self.tm_message_id = _get_tm_message_id(self, self.pygen_device)

    def start(self):
        """Запустить получение ТМ сообщений."""
        log_msg = '(dev id: {0}, module: {1}) Start monitoring {2}, by {3} channel'.format(
            self.device_address, self.broker.get_active_module(), self.name, StreamMsgChannel.TM,
        )
        logger.log(RuntimeAction.STATS, log_msg)
        self.stats = Stats()  # noqa: WPS601
        self._run_getting(StreamMsgChannel.TM)

    def copy(self):
        """Создает копию экземпляра класса."""
        return copy.copy(self)

    def get_once(self, timeout: int | None = None) -> TmType:
        """Получить разово синхронно."""
        tm = self.broker.send_command_raw(
            device_address=self.device_address,
            command=self._req_name,
            message_id=self.req_id,
            return_types=ReturnTypes(successful_type=self.msg_type),
            extra_timeout=timeout,
        )
        log_str = '(dev id: {0}, module: {1}) Received TM {2} by req-rep with data: {3}'.format(
            self.device_address, self.broker.get_active_module(), self.name, str(tm),
        )

        logger.log(RuntimeAction.TM, log_str)  # noqa: WPS221, WPS237, E501

        return tm

    def get_mean(self, duration: float) -> TmType | None:
        """Собрать ТМ сообщения и вернуть усредненное."""
        messages = []
        start_time = time.time()
        end_time = start_time + duration

        while time.time() < end_time:
            remaining_time = end_time - time.time()
            if remaining_time <= 0:
                break
            try:
                msg = self.wait(timeout=int(remaining_time))
            except TimeoutError:
                logger.warning('В ходе .get_mean был получен TimeoutError')
                break
            messages.append(msg)

        if not messages:
            logger.warning('В ходе .get_mean не было получено ТМ сообщений.')
            return None

        return average_tm_messages(messages)

    def wait(
        self,
        timeout: int = None,
        condition: Callable = None,
    ):
        """Вернуть первое полученное ТМ сообщение."""
        tm = self._wait(timeout=timeout, channel=StreamMsgChannel.TM, condition=condition)
        log_str = '(dev id: {0}, module: {1}) Received {2} {3} with data: {4}'.format(
            self.device_address, self.broker.get_active_module(), StreamMsgChannel.TM, self.name, str(tm),
        )
        logger.log(RuntimeAction.TM, log_str)  # noqa: WPS221, WPS237, E501
        return tm

    def subscribe(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на телеметрию, кладет в callback десериализованный объект телеметрии типа Message."""
        def internal_cb(transport_msg):
            data, _ = self.msg_type.from_bin(transport_msg.data)
            callback(data)

        predicate = self.broker.predicate_class(
            message_id=self.msg_id,
            device_id=self.device_address.node_id,
            channel=StreamMsgChannel.TM,
            ip_address=self.device_address.endpoint,
            is_from_device=True,
        )
        return self.broker.subscribe_to_tm(
            predicate=predicate,
            callback=internal_cb,
            use_single=use_single,
        )

    def subscribe_req(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на телеметрию, кладет в callback десериализованный объект телеметрии типа Message."""
        def internal_cb(transport_msg):
            data, _ = ReqMessage.from_bin(transport_msg.data)
            callback(data)

        predicate = self.broker.predicate_class(
            message_id=self.req_id,
            device_id=self.device_address.node_id,
            channel=StreamMsgChannel.REQ_REP,
            ip_address=self.device_address.endpoint,
            is_from_device=False,
        )
        return self.broker.subscribe_to_tm(
            predicate=predicate,
            callback=internal_cb,
            use_single=use_single,
        )

    def subscribe_rep(
        self,
        callback: Callable,
        use_single: bool = False,
    ) -> UUID:
        """Подписаться на телеметрию, кладет в callback десериализованный объект телеметрии типа Message."""
        def internal_cb(transport_msg):
            data, _ = self.msg_type.from_bin(transport_msg.data)
            callback(data)

        predicate = self.broker.predicate_class(
            message_id=self.rep_id,
            device_id=self.device_address.node_id,
            channel=StreamMsgChannel.REQ_REP,
            ip_address=self.device_address.endpoint,
            is_from_device=True,
        )
        return self.broker.subscribe_to_tm(
            predicate=predicate,
            callback=internal_cb,
            use_single=use_single,
        )

    def enable(self, frequency: Union[Enum, str]):
        """Включить ТМ сообщение и задать ему частоту выдачи."""
        self.pygen_device.cmds.core.tm.enableMsg(self.tm_message_id, frequency)
        log_str = '(dev id: {0}, module: {1}) Tm {2} enabled with frequency: {3}'.format(
            self.device_address, self.broker.get_active_module(), self.name, frequency,
        )
        logger.log(RuntimeAction.TM, log_str)

    def disable(self):
        """Выключить ТМ сообщение."""
        self.pygen_device.cmds.core.tm.disableMsg(self.tm_message_id)
        log_str = '(dev id: {0}, module: {1}) Tm {2} disabled'.format(
            self.device_address, self.broker.get_active_module(), self.name,
        )
        logger.log(RuntimeAction.TM, log_str)


def _get_tm_message_id(tm_catcher: CatcherAPI, device: GenDevice) -> int:
    """Выбрать message id телеметрии в зависимости от содержания прошивки."""
    core_module = getattr(device.cmds, 'core', None)
    if core_module and getattr(core_module, 'rmtx', None):
        return tm_catcher.req_id
    return tm_catcher.msg_id


def get_tm_module(tm, to_json: bool = False, with_meta: bool = True):  # noqa: WPS231, C901
    """Получить TM указанного модуля.

    Args:
        tm: Объект телеметрии (TmCatcher или GenTm).
        to_json (bool): Если True, сериализовать данные в JSON.
        with_meta (bool): Если False, исключить ключи 'meta' из результатов.

    Returns:
        dict или объект телеметрии.
    """
    module_dict = {}
    if isinstance(tm, TmCatcher):
        tm_data = tm.get_once()
        if not with_meta:
            tm_data.pop('meta', None)
        return tm_data

    for key, val in tm.__dict__.items():
        if not with_meta and key == 'meta':
            continue

        if isinstance(val, TmCatcher):
            tm_data = get_tm(val, to_json)
            if not with_meta:
                tm_data.pop('meta', None)
            module_dict[key] = tm_data
        elif isinstance(val, (int, str, BrokerAPI)):
            # Обход атрибутов класса ТМ и исключение ненужных
            continue
        else:
            if hasattr(val, '__dict__') and isinstance(val, GenTm):  # noqa: WPS421
                module_dict[key] = get_tm_module(val, to_json, with_meta=with_meta)
            else:
                module_dict[key] = val
    return module_dict


def enable_tm_module(tm_obj, frequency):
    """Рекурсивно включить все TmCatcher в модуле с заданной частотой."""
    if isinstance(tm_obj, TmCatcher):
        tm_obj.enable(frequency)
        return

    for _key, val in tm_obj.__dict__.items():
        if isinstance(val, TmCatcher):
            val.enable(frequency)
        elif isinstance(val, GenTm):
            enable_tm_module(val, frequency)


def disable_tm_module(tm_obj):
    """Рекурсивно выключить все TmCatcher в модуле."""
    if isinstance(tm_obj, TmCatcher):
        tm_obj.disable()
        return

    for _key, val in tm_obj.__dict__.items():
        if isinstance(val, TmCatcher):
            val.disable()
        elif isinstance(val, GenTm):
            disable_tm_module(val)


def fetch_telemetry(tm_obj):
    """Получение телеметрии из объекта."""
    try:
        return tm_obj.get_once()
    except Exception as get_exc:
        logger.error(f'Failed recieve TM {tm_obj}, {get_exc}')
        return None


def get_tm_json(tm) -> dict | None:
    """Получить json телеметририи."""
    try:
        return tm if isinstance(tm, dict) else tm.to_json()
    except Exception as des_exc:
        logger.error(f'Failed unpack TM {tm}, {des_exc}')
        return None


def process_telemetry(telemetry, to_json):
    """Обработка телеметрии: сериализация в JSON, если требуется."""
    if to_json:
        return get_tm_json(telemetry)
    return telemetry


def get_tm(tm_obj, to_json):
    """Объединение операций получения и обработки телеметрии."""
    telemetry = fetch_telemetry(tm_obj)
    return process_telemetry(telemetry, to_json)
