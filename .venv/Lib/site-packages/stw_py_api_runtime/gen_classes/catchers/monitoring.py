"""Все для мониторинга сообщений."""
from dataclasses import dataclass
from time import sleep
from typing import Dict, Iterable, List

from loguru import logger
from stw_py_api_runtime.gen_classes.catchers.statistic import Stats
from stw_py_api_runtime.sdk.brokers.broker_api import BrokerAPI, CatcherAPI
from tqdm import tqdm


def reduce_stats_from_catchers(tm_catchers: Iterable[CatcherAPI]) -> Stats:
    """Объединить в один объект статистику каждого ТМ."""
    general_stats = Stats()
    tms_stats = [tm_catcher.stats for tm_catcher in tm_catchers]

    for stats in tms_stats:
        general_stats.count += stats.count
        general_stats.times.extend(stats.times)
        general_stats.events.update(stats.events)
        general_stats.rps += stats.rps
        general_stats.std_dev.extend(stats.std_dev)
        general_stats.median += stats.median

    return general_stats


def monitor(
    *tms: CatcherAPI,
    duration: int,
) -> Stats:
    """Получение ТМ или событий в течение указанного времени и вывод статистики."""
    with Monitor(*tms) as mon:
        progress_bar(duration)
    return mon.stats  # noqa: WPS441


class Monitor:
    """Контекстный менеджер для получения нескольких ТМ типов сообщений и сбора статистики."""

    def __init__(self, *tm_catchers: CatcherAPI):
        self.tm_catchers = tm_catchers
        self.stats = None
        self.types_str = ', '.join(str(tm_catcher.msg_type) for tm_catcher in self.tm_catchers)

    def __enter__(self):
        """Для каждого ТМ типа запустить получение сообщений."""
        for tm_catcher in self.tm_catchers:
            tm_catcher.start()
        logger.log('STATS', f'Sync catcher for {self.types_str} started!')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Для каждого ТМ типа прекратить получение сообщений."""
        for tm_catcher in self.tm_catchers:
            tm_catcher.stop()
        logger.log('STATS', f'Sync catcher for {self.types_str} stopped!')
        self.stats = reduce_stats_from_catchers(self.tm_catchers)


def progress_bar(duration):
    """
    Display a progress bar for the given duration in seconds.

    :param duration: The total time in seconds for which the progress bar should run.
    """
    updates_per_second = 10
    total_updates = duration * updates_per_second
    update_interval = 1 / updates_per_second

    with tqdm(total=duration, desc='Осталось времени', ncols=75, bar_format='{l_bar}{bar} | {n:.1f}/{total} s') as pbar:
        for _ in range(total_updates):
            sleep(update_interval)
            pbar.update(update_interval)


@dataclass
class MonitorPredicate(object):
    """Предикат для работы со всей шиной."""

    broker: BrokerAPI
    device_ids: List[int] = None
    msg_ids: List[int] = None


def predicate_monitor(duration: int, predicate: MonitorPredicate):
    """Получение сырых сообщений по предикату."""
    msg_pull = []

    def collect_msgs(message):
        msg_pull.append(message)
    broker_predicate = predicate.broker.predicate_class(
        device_id=predicate.device_ids,
        message_id=predicate.msg_ids,
    )
    sub_id = predicate.broker.subscribe_to_tm(
        predicate=broker_predicate,
        use_single=False,
        callback=collect_msgs,
    )
    sleep(duration)
    predicate.broker.unsubscribe_from_tm(sub_id)
    return msg_pull


def parse_raw_msgs(raw_msgs, devices: List) -> Dict:
    """Парсинг сырых сообщений."""
    parsed_msgs = {}
    for msg in raw_msgs:
        for device in devices:
            if msg.device_id == device.device_id:
                _, cmd_req_type = device.messages[msg.header.message_id]
                obj, _ = cmd_req_type.from_bin(msg.data)
                parsed_msgs[msg.header.timestamp] = obj
    return parsed_msgs
