"""Обработка ТМ сообщений."""
from dataclasses import dataclass
from threading import Thread
from time import sleep
from typing import Callable, Optional, Type
from uuid import UUID

from loguru import logger
from stw_py_api_runtime.gen_classes.catchers.statistic import Stats, update_stats
from stw_py_api_runtime.gen_classes.gen_device import GenDevice
from stw_py_api_runtime.gen_classes.telemetry.predicates import StreamMsgChannel
from stw_py_api_runtime.gen_classes.types.returned_types import ReturnTypes
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.logger_utils import RuntimeAction
from stw_py_api_runtime.sdk.brokers.broker_api import BrokerAPI
from stw_py_api_runtime.sdk.brokers.fragments.unpacking import unpack_message
from stw_py_api_runtime.sdk.brokers.message import DeviceAddress


@dataclass
class BaseCatcher(object):  # noqa: WPS230
    """Получение ТМ сообщений определенного имени."""

    _wait_map = {}

    device_address: DeviceAddress
    broker: BrokerAPI
    pygen_device: GenDevice
    name: str
    msg_type: Type[Serializable]
    msg_id: int
    req_id: Optional[int] = None
    rep_id: Optional[int] = None
    timeout: int = 3
    stats: Optional[Stats] = None
    _consumer_id: Optional[UUID] = None

    def stop(self):
        """Остановить получение сообщений."""
        self.broker.unsubscribe_from_tm(self._consumer_id)
        log_msg = '(dev id: {0}, module: {1}) Finish monitoring {2}.'.format(
            self.device_address, self.broker.get_active_module(), self.name,
        )
        logger.log(RuntimeAction.STATS, log_msg)

    def _wait(
        self,
        channel: StreamMsgChannel,
        timeout: int = None,
        condition: Callable = None,
    ):
        """Вернуть первое полученное сообщение."""
        timeout = timeout or self.timeout
        waiting = Thread(target=self._get_first, args=(channel, condition), daemon=True)
        waiting.start()
        waiting.join(timeout)

        wait_map_key = (self.device_address, self.msg_id, channel)
        tm = self._wait_map.pop(wait_map_key, None)
        if not tm:
            raise TimeoutError(f'Не удалось получить {self.name} сообщение за {timeout} сек.')
        return tm

    def _get_first(self, channel: StreamMsgChannel, receipt_condition: Callable = None):
        tm = None
        tm_received = False
        return_types = ReturnTypes(successful_type=self.msg_type)

        def tm_handler(captured_message):
            """Обработчик, вызывается в loop при получении ТМ сообщения."""
            nonlocal tm
            nonlocal tm_received
            tm = unpack_message(self.broker, captured_message, self.name, channel, return_types)
            tm_received = receipt_condition(tm) if receipt_condition else True

        subscriber_id = self.broker.subscribe_to_tm(
            predicate=self.broker.predicate_class(
                device_id=self.device_address.node_id,
                ip_address=self.device_address.endpoint,
                message_id=self.msg_id,
                channel=channel,
            ),
            callback=tm_handler,
            use_single=False,
        )

        while not tm_received:
            sleep(0.1)

        self.broker.unsubscribe_from_tm(subscriber_id)

        wait_map_key = (self.device_address, self.msg_id, channel)
        self._wait_map[wait_map_key] = tm
        return tm

    def _run_getting(self, channel: StreamMsgChannel):
        """Подписаться на ТМ сообщения в брокере."""
        return_types = ReturnTypes(successful_type=self.msg_type)

        def tm_handler(captured_message):
            """Обработчик, вызывается в loop при получении ТМ сообщения."""
            tm_object = unpack_message(self.broker, captured_message, self.name, channel, return_types)
            update_stats(self.stats, tm_object)

        self._consumer_id = self.broker.subscribe_to_tm(  # noqa: WPS601
            predicate=self.broker.predicate_class(
                device_id=self.device_address.node_id,
                ip_address=self.device_address.endpoint,
                message_id=self.msg_id,
                channel=channel,
            ),
            callback=tm_handler,
            use_single=False,
        )
