"""Преобразователь объектов. Позволяет использовать несколько видов значений в командах."""
import copy
from dataclasses import fields, is_dataclass
from enum import Enum
from time import sleep
from types import NoneType
from typing import Any, Counter, List, Set, TypeVar, Union

from loguru import logger
from stw_py_api_runtime.gen_classes.catchers.monitoring import Monitor
from stw_py_api_runtime.gen_classes.gen_device import GenDevice
from stw_py_api_runtime.gen_classes.telemetry.parse import Message
from stw_py_api_runtime.gen_classes.types.bits_base import BitsBase
from stw_py_api_runtime.gen_classes.types.none_type import NoneType as GenNoneType
from stw_py_api_runtime.gen_classes.types.number import Number
from stw_py_api_runtime.sdk.brokers.broker_api import TmCatcherAPI
from stw_py_api_runtime.sdk.exceptions import (
    AmbiguityError, InvalidDeviceConfigError, InvalidFirmwareError, ResetDeviceError, SendCommandError,
    VerifyModuleError,
)

TmType = TypeVar('TmType')


def _bits_instance(value, target_type):
    """Конструирование объекта bits типа."""
    if isinstance(value, dict):
        return target_type(**value)
    return target_type(*value)


def _none_instance(value: NoneType | GenNoneType):
    """Конструирование объекта None типа."""
    return value if value is None else None


def _enum_instance(name_or_value, target_type):
    """Получить enum.item по имени или значению."""
    enum_names = {item.name for item in target_type}
    enum_values = {item.value for item in target_type}

    is_name = name_or_value in enum_names
    is_value = name_or_value in enum_values

    if is_name and not is_value:
        return target_type[name_or_value]

    if is_value and not is_name:
        return target_type(name_or_value)

    if is_value and is_name:
        item_by_name = target_type[name_or_value]
        item_by_value = target_type(name_or_value)

        if item_by_name == item_by_value:
            return item_by_name
        raise AmbiguityError(
            f'"{name_or_value}" является именем и значением enum-а "{target_type}".',
        )

    raise AmbiguityError(
        f'"{name_or_value}" не является ни именем, ни значением enum-а "{target_type}".',
    )


def ensure_instance(value, target_type, allow_none=False):  # noqa: WPS212
    """Функция возвращает объект класса target_type.

    Если тип уже требуемый - ничего не происходит.
    Если тип - enum, то конструируется по name или value.
    Если тип - bits, то конструруется в зависимости от типа значения.
    Если любой другой класс - используется конструктор.
    """
    if allow_none and isinstance(value, (NoneType, GenNoneType)):
        return _none_instance(value)
    if isinstance(value, target_type):
        return value
    if issubclass(target_type, Enum):
        return _enum_instance(value, target_type)
    if issubclass(target_type, BitsBase):
        return _bits_instance(value, target_type)
    if isinstance(value, dict):
        return target_type(**value)
    return target_type(value)


def reboot_prepare(device: GenDevice) -> tuple:
    """Подготовка всякого для перезагрузки."""
    hex_device_id = hex(device.device_id)
    orig_retry_sending = device.broker.commander.retry_sending
    try:
        boot_event = device.events.core.sw.bootReport
        boot_cmd = device.cmds.core.sw.reset
    except AttributeError:
        raise InvalidFirmwareError('Reboot error. Has not command "core.sw.reset", event "core.sw.bootReport".')
    return boot_event, boot_cmd, hex_device_id, orig_retry_sending


def sync_reboot(device: GenDevice, timeout: int = 12):
    """Синхронно перезагрузить прибор и проверить это по событиям."""
    boot_event, boot_cmd, hex_device_id, orig_retry_sending = reboot_prepare(device)
    with Monitor(boot_event) as mon:
        boot_cmd(extra_wait_rep=False)
        sleep(timeout)
    if not mon.stats.count:  # noqa: WPS441
        raise ResetDeviceError(f'Device {hex_device_id} did not push events for boot report.')

    logger.info(f'Device {hex_device_id} rebooted. Amount of events is {mon.stats.count}')  # noqa: WPS237, WPS441


def _check_module_synchronization(device: GenDevice, real_module: str, expected_module: str):
    """Сравнение указанного CAN с реальным."""
    if expected_module.upper() != real_module.upper():  # noqa: WPS531
        raise InvalidDeviceConfigError(
            f'Активный модуль устройства ({device.device_id}) {real_module}, '
            f'а брокер подключен к {expected_module}.',  # noqa: WPS326
        )
    logger.debug(f'Брокер подключен к активному модулю устройства ({device.device_id}) {real_module}')


def verify_module(device: GenDevice):
    """Проверить, что активный модуль брокера соответствует активному у прибора."""
    try:
        can_stats = device.tms.core.can.canStats.get_once()
        real_module = can_stats.can.activeCan
    except (SendCommandError, AttributeError) as exp:
        raise VerifyModuleError(f'Не удалось запросить активный модуль у прибора: {exp}.')

    _check_module_synchronization(device, real_module.name, device.broker.active_module)


FieldType = TypeVar('FieldType')


def average_tm_messages(
    messages: List[Message],
    visited_types: Set[type] = None,
) -> Message:
    """Получение среднего по значениям ТМ сообщения из списка одинаковых по типу ТМ сообщений."""
    if not messages:
        raise ValueError('No messages to average.')

    first_type = type(messages[0])
    if not all(isinstance(msg, first_type) for msg in messages):
        raise TypeError('All messages must be of the same type.')

    if visited_types is None:
        visited_types = set()
    if first_type in visited_types:
        # Мера предосторожности во имя избежания бесконечной рекурсии
        return None
    visited_types.add(first_type)

    averaged_msg = copy.deepcopy(messages[0])

    for field in fields(first_type):
        values = [getattr(msg, field.name) for msg in messages]
        averaged_value = average_field(values, visited_types)
        setattr(averaged_msg, field.name, averaged_value)

    visited_types.remove(first_type)
    return averaged_msg


def average_most_common(values: List[Union[Enum, bool, Number]]) -> Union[Enum, bool]:
    """Возвращает наиболее часто встречающееся значение из списка."""
    return Counter(values).most_common(1)[0][0]


def average_list_of_numbers(
    values: List[List[Number]] | List[Number],
    visited_types: Set[type],
) -> List[Number]:
    """Усредняет список числовых значений поэлементно."""
    list_lengths = [len(lst) for lst in values]
    if len(set(list_lengths)) != 1:
        raise ValueError('Списки должны быть одинакового размера чтобы вывести среднее.')

    averaged_list = []
    for index in range(list_lengths[0]):
        ith_elements = [lst[index] for lst in values]
        averaged_element = average_field(ith_elements, visited_types)
        averaged_list.append(averaged_element)
    return averaged_list


def average_field(  # noqa: WPS231, C901, WPS212
    values: List[Any],
    visited_types: Set[type],
) -> Union[Number, list, None]:
    """
    Обработка поля в зависимости от его типа.

    Поддерживаемые типы:
    - Number: вычисляется среднее значение.
    - Enum и bool: выбирается наиболее часто встречающееся значение.
    - List[Number]: усредняется поэлементно.
    - Вложенные датаклассы: рекурсивно усредняются.
    - Другие типы: возвращается значение из первого сообщения.

    Параметры:
    - values: список значений поля из сообщений.
    - visited_types: множество уже посещённых типов для предотвращения рекурсии.

    Возвращает:
    - Усреднённое значение поля.
    """
    first_value = values[0]

    if isinstance(first_value, (Enum, bool)):  # noqa: WPS223
        # Enum или bool: выбираем наиболее часто встречающееся значение
        return average_most_common(values)
    elif all(isinstance(value, int) for value in values):
        # Числовое значение: считаем среднее
        return int(sum(values) / len(values))
    elif all(isinstance(value, (Number, float)) for value in values):
        # Числовое значение: считаем среднее
        return sum(values) / len(values)
    elif isinstance(first_value, list):
        is_all_numbers = all(isinstance(item, Number) for value in values for item in value)
        if is_all_numbers:
            # Список числовых значений: усредняем поэлементно
            return average_list_of_numbers(values, visited_types)
    elif is_dataclass(first_value) and first_value is not None:
        # Вложенный датакласс: рекурсивно усредняем
        return average_tm_messages(values, visited_types)
    # Неподдерживаемый тип: выдаём предупреждение и возвращаем первое значение
    logger.warning(
        f"Неподдерживаемый тип поля '{type(first_value)}'. Используем значение из первого сообщения.",  # noqa: WPS237
    )
    return first_value


def enable_tm(*tm_catchers: TmCatcherAPI, frequency: Enum):
    """Включить одну или несколько ТМ сообщений и задать им частоту выдачи."""
    for tm_catcher in tm_catchers:
        tm_catcher.enable(frequency)


def disable_tm(*tm_catchers: TmCatcherAPI):
    """Выключить одну или несколько ТМ сообщений."""
    for tm_catcher in tm_catchers:
        tm_catcher.disable()
