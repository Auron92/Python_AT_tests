"""Классы для создания уникального слушателя ТМ сообщений в брокере."""
import copy
from dataclasses import asdict, dataclass, fields
from types import UnionType
from typing import Any, ItemsView, Iterable, Mapping, Union

from stw_py_api_runtime.gen_classes.types.bits_base import BitsBase
from stw_py_api_runtime.gen_classes.types.none_type import NoneType
from stw_py_api_runtime.gen_classes.types.optional_type import OptionalBase
from stw_py_api_runtime.gen_classes.types.returned_types import ReturnTypes
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.sdk.exceptions import InitializationError, NotSupportedError


@dataclass
class Message(Serializable, Mapping):
    """Сущность для описания и сериалиазции/десериализации сообщения.

    Под сообщением имеется в виду телеметрия, событие и т.п.
    """

    allow_none = False

    def __post_init__(self, *args, **kwargs):
        from stw_py_api_runtime.gen_classes.cmd_helpers import ensure_instance  # noqa: WPS433
        try:
            for field in fields(self):
                val = ensure_instance(getattr(self, field.name), field.type, self.allow_none)
                setattr(self, field.name, val)
        except Exception as exc:
            raise InitializationError(
                f'\nНе удалось создать объект класса {self.__class__}.'
                f'\nПереданное значение: {self}'  # noqa: WPS326
                f'\nОшибка: {exc}',  # noqa: WPS326
            ) from exc

    def copy(self):
        """Создает копию экземпляра класса."""
        return copy.copy(self)

    def get_items(self) -> ItemsView:
        """Представление TM как итерируемого объекта."""
        for msg_name in asdict(self):
            if msg_name == 'meta':
                continue
            yield msg_name, getattr(self, msg_name)

    @classmethod
    def from_json(cls, json_data: dict):
        """Десериализация из json данных."""
        kwargs = get_kwargs_from_json(json_data, cls)
        return cls(**kwargs)

    def to_json(self) -> dict:
        """Сериализация."""
        json_dict = {}
        for field_name, field_value in self.__dict__.items():
            field_type = type(field_value)
            if issubclass(field_type, Serializable):
                json_dict[field_name] = field_value.to_json()
            else:
                json_dict[field_name] = str(field_value)
        return json_dict

    @classmethod
    def from_bin(cls, bin_data: Union[bytes, Iterable]) -> tuple:
        """Десериализация из байтов.

        bin_data: массив байт, содержаший данные сообщения
        """
        if not isinstance(bin_data, bytes) and isinstance(bin_data, Iterable):
            bin_data = bytes(bin_data)
        kwargs, new_bin_data = get_kwargs_from_bin(bin_data, cls)
        return cls(**kwargs), new_bin_data

    def to_bin(self) -> bytes:
        """Сериализация в байты."""
        bin_data = bytearray()
        for field in fields(self):
            val = getattr(self, field.name)
            if val is None and self.allow_none:
                val = NoneType()
            bin_data.extend(val.to_bin())
        return bytes(bin_data)

    def to_str(self) -> str:
        """Строковое представление."""
        json_dict = {}
        for field_name, field_value in self.__dict__.items():
            field_type = type(field_value)
            if issubclass(field_type, Serializable):
                try:
                    json_value = field_value.to_json()
                except NotSupportedError:
                    json_value = str(field_value)
            else:
                json_value = str(field_value)
            json_dict[field_name] = json_value

        return str(json_dict)

    def __repr__(self, *args):
        return self.to_str()

    def __str__(self):
        return self.to_str()

    def __getitem__(self, key):
        return self.__dict__[key]

    def __iter__(self):
        return iter(list(self.__dict__.keys()))

    def __len__(self):
        return len(self.__dict__.keys())


@dataclass
class ReqMessage(Message):
    """Сущность для описания аргументов команды."""

    @classmethod
    def name_and_type_of_args(cls) -> tuple:
        """Вернуть массив из пар: имя аргумента и его тип."""
        return tuple((field.name, field.type) for field in fields(cls))


class RepMessage(Message):
    """Сущность для описания ответа на команду.

    У команды может быть несколько типов ответа.
    """

    type_annotation: UnionType
    return_types: ReturnTypes

    def __init__(self, value):
        self.value = value

    @classmethod
    def from_bin(cls, bin_data: bytes) -> tuple:
        """Десериализация из байтов.

        В данных первый байт - индекс типа из массива всех возможных.
        """
        type_index = bin_data[0]
        real_bin_data = bin_data[1:]

        real_type = cls.return_types[type_index]
        value, other_bytes = real_type.from_bin(real_bin_data)
        return cls(value=value), other_bytes

    def to_bin(self) -> bytes:
        """Сериализация в байты.

        Первый байт - индекс типа данных.
        """
        bin_data = self.value.to_bin()
        current_type = type(self.value)
        type_idx = self.return_types.index(current_type)
        type_idx_byte = type_idx.to_bytes(1, 'little')
        return_data = bytearray(type_idx_byte)
        return_data.extend(bin_data)
        return bytes(return_data)

    @classmethod
    def from_json(cls, json_data: dict):
        """Десериализация из json."""
        raise NotImplementedError

    def to_json(self) -> dict:
        """Сериализация в json."""
        raise NotImplementedError


class EventMessage(Message):
    """Сущность для описания события.

    Согласно timbrel 2.0 у пришедшего события может не быть полей, описанных в yaml.
    Поэтому только для него разрешается None значение.
    """

    allow_none = True

    @classmethod
    def from_bin(cls, bin_data: bytes) -> tuple:
        """Десериализация из байтов."""
        try:
            return super().from_bin(bin_data)
        except Exception:
            # у пришедшего события может не быть полей по timbrel 2.0
            none_attrs = get_kwargs_with_none(cls)
            return cls(**none_attrs), b''


def get_kwargs_from_json(json_data, message_type):
    """Конструирование kwarg-ов для конструктора dataclass-a."""
    result = {}
    for field in fields(message_type):
        json_value = json_data[field.name]
        result[field.name] = construct_from_json(field.type, json_value)
    return result


def construct_from_json(field_type, json_value):
    """Конструирование объекта из json представления."""
    if issubclass(field_type, BitsBase):
        # BitsBase хранится в словаре
        return field_type.from_json(json_value)
    elif issubclass(field_type, OptionalBase):
        # optional тоже представлен как словарь, но на основе вложенного типа
        return field_type.from_json(json_value)
    elif isinstance(json_value, dict):
        # В других случаях мы считаем, что словарь - это представление
        # Какого-то более сложного вида
        field_value = get_kwargs_from_json(json_value, field_type)
        return field_type(**field_value)
    return field_type.from_json(json_value)


def get_kwargs_from_bin(bin_data, message_type) -> tuple[dict, Union[bytes, Any]]:
    """Получить именованные значения из байтов согласно типу сообщения.

    Необходимы для конструктора dataclass-a.
    Алгоритм обработки: читаем переданный массив байт слева направо по N байт, уменьшая его
    и убирая прочитанные байты, пока не дойдем до конца.

    bin_data: массив байт, содержаший данные сообщения
    message_type: класс, описывающий тип данных на основе прошивки
    """
    result = {}
    new_bin_data = bin_data
    for field in fields(message_type):
        cls_object, new_bin_data = field.type.from_bin(bin_data)
        result[field.name] = cls_object
        bin_data = new_bin_data
    return result, new_bin_data


def get_kwargs_with_none(object_type) -> dict:
    """Получить словарь атрибутов с None значениями."""
    result = {}
    for field in fields(object_type):
        result[field.name] = None
    return result
