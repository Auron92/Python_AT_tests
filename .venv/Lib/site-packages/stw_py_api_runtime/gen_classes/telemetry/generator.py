"""Создание телеметрии."""
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, Optional, Tuple

from loguru import logger
from stw_py_api_runtime.gen_classes.message_params import MessageHandler
from stw_py_api_runtime.gen_classes.telemetry.predicates import StreamMsgChannel
from stw_py_api_runtime.sdk.brokers.broker_api import MessageCreatorAPI, SerializerAPI
from stw_py_api_runtime.sdk.brokers.fragments.commanding import Counter
from stw_py_api_runtime.sdk.brokers.message import DeviceAddress
from stw_py_api_runtime.sdk.device_clock_api import DeviceClockAPI


class TmFrequency(Enum):
    """Частота отправки ТМ."""

    Rare = 1  # Редко
    Ordinary = 2  # Обычно
    Often = 3  # Часто
    Heartbeat = 4  # Heartbeat 2Hz


def get_tm_frequency(pygen_freq: Enum) -> TmFrequency:
    """Получить частоту генератора по значению из прошивки."""
    try:
        return TmFrequency[pygen_freq.name]
    except KeyError:
        raise KeyError(f'Freq {pygen_freq} not known for TM generator.')


@dataclass
class TelemetryGenerator:
    """Генерация потоковой телеметрии с заданными частотами.

    Создает сообщения только по запросу. В фоне ничего не генерирует.
    """

    device_address: DeviceAddress
    receiver_address: DeviceAddress
    message_creator: MessageCreatorAPI
    serializer: SerializerAPI
    clock: Optional[DeviceClockAPI] = None
    _freq_period_ms_map: Dict[TmFrequency, float] = field(default_factory=lambda: {
        TmFrequency.Rare: 10000.0,
        TmFrequency.Ordinary: 1000.0,
        TmFrequency.Often: 100.0,
        TmFrequency.Heartbeat: 500.0,
    })
    _tm_counter: Counter = field(default_factory=Counter)

    def __post_init__(self):
        self._freq_handlers_map = {freq: {} for freq in self._freq_period_ms_map.keys()}
        self._freq_last_gen_timestamps_ms = dict.fromkeys(self._freq_period_ms_map.keys(), 0)

    def set_period_for_frequency(self, frequency: TmFrequency, period_ms: float):
        """Установить новый период для заданной частоты в миллисекундах."""
        self._freq_period_ms_map[frequency] = period_ms
        self._freq_last_gen_timestamps_ms[frequency] = 0
        logger.debug(f'Set period for {frequency} to {period_ms} ms')

    def set_periods(self, periods_ms: Dict[TmFrequency, float]):
        """Установить новые периоды для нескольких частот в миллисекундах."""
        for freq, period_ms in periods_ms.items():
            if not isinstance(freq, (TmFrequency, int, float)):
                raise ValueError(
                    f'Invalid period type: {type(freq)}, expected TmFrequency, int or float',  # noqa: WPS237
                )
            self.set_period_for_frequency(freq, period_ms)

    def enable_message(
        self,
        message_handler: MessageHandler,
        frequency: TmFrequency,
    ):
        """Включить генерацию сообщения."""
        self._freq_handlers_map[frequency][message_handler.name] = message_handler
        logger.debug(f'Tm {message_handler.name} enabled with frequency {frequency}')

    def disable_message(self, message_handler: MessageHandler):
        """Выключить генерацию сообщения."""
        for freq, handlers_map in self._freq_handlers_map.items():
            handlers_map.pop(message_handler.name, None)
            self._freq_last_gen_timestamps_ms[freq] = 0
            logger.debug(f'Tm {message_handler.name} disabled')

    def generate(self) -> list:  # noqa: WPS210
        """Сгенерировать сообщения за время от последней генерации."""
        return self._generate_tm()

    def _generate_tm(self):
        """Сгенерировать TM сообщения за время от последней генерации."""
        messages = []

        for freq, messages_handlers_map in self._freq_handlers_map.items():
            if not messages_handlers_map:
                # нет включенных TM сообщений с этой частотой
                continue

            freq_messages, last_gen_timestamp_ms = self._generate_by_channel(
                handlers=messages_handlers_map.values(),
                period_ms=self._freq_period_ms_map[freq],
                channel=StreamMsgChannel.TM,
                last_gen_timestamp_ms=self._freq_last_gen_timestamps_ms[freq],
            )
            self._freq_last_gen_timestamps_ms[freq] = last_gen_timestamp_ms
            messages.extend(freq_messages)

        return messages

    def _generate_by_channel(
        self,
        handlers: list[MessageHandler],
        channel: StreamMsgChannel,
        period_ms: int | float,
        last_gen_timestamp_ms: int,
    ):
        """Сгенерировать N сообщений для заданного канала.

        Количество N определяется из времени, прошедшего от последней генерации, поделенного на период.
        """
        messages = []

        handlers_messages, last_gen_timestamp_ms = self._generate_for_period(
            last_gen_timestamp_ms=last_gen_timestamp_ms,
            period_ms=period_ms,
            handlers=handlers,
            channel=channel,
        )
        if handlers_messages:
            messages.extend(handlers_messages)

        return messages, last_gen_timestamp_ms

    def _generate_for_period(
        self,
        handlers: list[MessageHandler],
        channel: StreamMsgChannel,
        period_ms: int | float,
        last_gen_timestamp_ms: int,
    ) -> Tuple[list, int | float]:
        """Сгенерировать N сообщений за время, прошедшее от последней генерации.

        Если прошло меньше, чем период, то возвращается 0 сообщений.
        Если больше, то количество N определяется этим временем, деленным на период.
        """
        messages = []
        now_timestamp_ms = time.perf_counter() * 1000
        time_after_last_gen_ms = (
            now_timestamp_ms - last_gen_timestamp_ms if last_gen_timestamp_ms else period_ms
        )

        if time_after_last_gen_ms >= period_ms:
            count = int(time_after_last_gen_ms // period_ms)
            messages = self._create_handlers_messages(count, handlers, channel)
            last_gen_timestamp_ms = now_timestamp_ms

        return messages, last_gen_timestamp_ms

    def _create_handlers_messages(self, count: int, handlers: list, channel: StreamMsgChannel) -> list:
        """Создать массив сообщений по N штук для каждого ТМ обработчика."""
        messages = []
        channel_create_method_map = {
            StreamMsgChannel.TM: self._create_message,
        }
        create_method = channel_create_method_map.get(channel, None)
        if create_method is None:
            raise ValueError(f'Not supported channel {channel} for message creating')

        for handler in handlers:
            tm_messages = [create_method(handler) for _ in range(count)]
            messages.extend(tm_messages)

        return messages

    def _create_message(self, handler: MessageHandler):
        """Создать транспортное ТМ сообщение."""
        timestamp = self.clock.get_system_time() if self.clock else None
        tm_object = handler.response_getter()
        tm_data = self.serializer.serialize_tm(tm_object)

        return self.message_creator.create_tm_message(
            sender_address=self.device_address,
            receiver_address=self.receiver_address,
            message_id=handler.params.out_msg_id,
            data=tm_data,
            counter=self._tm_counter.next(),
            timestamp=timestamp,
            priority=handler.params.priority,
        )
