"""Модуль работы с конфигом на устройстве."""
import base64
import json
import struct
from abc import ABCMeta
from pathlib import Path
from typing import Dict

from loguru import logger
from stw_py_api_runtime.gen_classes.file_handler.file_handler import FileHandler
from stw_py_api_runtime.gen_shared_types import SharedTypesDevice
from stw_py_api_runtime.gen_shared_types.basic_types import uint16_t
from stw_py_api_runtime.gen_shared_types.types.core.fs.file_info_type import FileInfo
from stw_py_api_runtime.gen_shared_types.types.core.fs.files_list_type import FilesList
from stw_py_api_runtime.sdk.brokers.broker_api import BrokerAPI
from stw_py_api_runtime.sdk.brokers.message import DeviceAddress
from stw_py_api_runtime.sdk.exceptions import DownloadFileError
from typing_extensions import deprecated


class CfgInterface:
    """Класс работы с конфигом на устройстве."""

    def __init__(
        self,
        device_address: DeviceAddress,
        broker: BrokerAPI,
        messages_map: dict,
        file_id: int = 2,
    ):
        self._device_address = device_address
        self._broker = broker
        self.messages_map: Dict[int, tuple[str, ABCMeta]] = messages_map
        self.file_id = file_id

        self.shared_device = SharedTypesDevice(
            device_id=device_address.node_id,
            ip_address=device_address.endpoint,
            broker=self._broker,
        )
        self.files: DeviceFiles[str, CfgInterface] = DeviceFiles(
            self.shared_device,
            self._device_address,
            self.messages_map,
            self._broker,
        )
        self.file_handler = FileHandler(
            file_id=self.file_id,
            broker=self._broker,
            device_address=self._device_address,
        )

        # костыль для загрузки json
        self.messages_map_by_name = self._fill_messages_map_by_name()

    def set_file_id(self, file_id: int):  # noqa: WPS615
        """Установка file id."""
        self.file_handler.file_id = file_id

    def download_bin(self) -> bytearray:
        """Загрузить файл с устройства."""
        return self.file_handler.download_file()

    def download_bin_file(self, bin_file_path: Path):
        """Загрузить файл с устройства в файл."""
        with bin_file_path.open('wb') as file:
            file.write(self.file_handler.download_file())

    def download_json(self) -> dict[int, bytes]:
        """Загрузить файл с устройства в виде JSON."""
        json_data = {}
        bin_data = self.file_handler.download_file()

        offset = 0
        while offset < len(bin_data):
            msg_id, value_length = struct.unpack_from('<LH', bin_data, offset=offset)
            offset += 6

            data = struct.unpack_from(f'{value_length}s', bin_data, offset=offset)[0]
            offset += value_length

            json_data[msg_id] = data

        return self._deserialize_json_messages(json_data)

    def download_json_file(self, json_file_path: Path):  # noqa: WPS210
        """Загрузить файл с устройства в файл."""
        try:
            json_data = self.download_json()
        except Exception as exp:
            raise DownloadFileError(f'Failed to getting json from device: {exp}') from exp

        with open(json_file_path, 'w', encoding='utf-8') as file:
            json_str = json.dumps(json_data, indent=4)
            file.write(json_str)

        logger.info(
            f'Downloaded json file (id: {self.file_id}) '  # noqa: WPS237
            f'from device {self._device_address} to {json_file_path}',  # noqa: WPS326
        )

    def upload_bin(self, bin_data):
        """Отгрузить файл на устройство."""
        self.file_handler.upload_file(bin_data)

    def upload_bin_file(self, bin_file_path: Path):
        """Отгрузить файл из файла на устройство."""
        with bin_file_path.open('rb') as file:
            self.file_handler.upload_file(file.read())

    def upload_json(self, json_data: Path):
        """Отгрузить JSON данные на устройство."""
        bin_data = self.serialize_json_data(json_data)
        self.upload_bin(bin_data)

    def upload_json_file(self, json_file_path: Path):
        """Отгрузить JSON файл на устройство."""
        with open(json_file_path, 'r', encoding='utf-8') as file:
            json_data = json.load(file)
        bin_data = self.serialize_json_data(json_data)
        self.upload_bin(bin_data)

    def serialize_json_data(self, json_data: dict) -> bytes:  # noqa: WPS210
        """Сериализовать данные JSON в бинарный формат."""
        bin_data = bytearray()
        for message_id_str, base64_content in json_data.items():
            message_id, data_type = self.get_message_name_and_type(message_id_str)

            if data_type:
                obj = data_type.from_json(base64_content)
                bin_content = obj.to_bin()
            else:
                bin_content = base64.b64decode(base64_content)

            bin_data += struct.pack('<LH', message_id, len(bin_content)) + bin_content
        return bin_data

    def get_message_name_and_type(self, message_id_str: str) -> tuple:
        """Получить имя сообщения и тип данных по идентификатору."""
        msg_desc = self.messages_map_by_name.get(message_id_str, None)
        if msg_desc is None:
            logger.debug(f'Message ID {message_id_str} not found in messages map.')
            return None, None
        return msg_desc

    def _deserialize_json_messages(self, json_data: Dict) -> Dict:
        """Десериализация json."""
        new_json_data = {}
        for message_id, bin_data in json_data.items():
            message_name, new_data = self._get_deserialized_message_data(message_id, bin_data)
            new_json_data[message_name] = new_data
        return new_json_data

    def _fill_messages_map_by_name(self):
        """Заполнение messages_map_by_name."""
        return {
            data[0]: (message_id, data[1]) for message_id, data in self.messages_map.items()
        }

    def _get_deserialized_message_data(self, message_id: int, bin_data: bytes) -> tuple:
        """Десериализация одного поля в json."""
        new_data = base64.b64encode(bin_data).decode('utf-8')
        msg_desc = self.messages_map.get(message_id, None)

        if msg_desc is None:
            logger.debug(f'Message {message_id} not found in device messages map: bin data not deserialized')
            return message_id, new_data

        message_name, data_type = msg_desc
        try:
            obj, _ = data_type.from_bin(bin_data)
        except Exception as exp:
            logger.debug(
                f'Failed deserialize message {message_id} type {data_type}. Saved original bin data. Exp: {exp}',
            )
        else:
            new_data = obj.to_json()
        return message_name, new_data


class DeviceFiles(dict):  # noqa: WPS600
    """Класс для предоставления интерфейса работы с файлов по имени файла."""

    def __init__(
        self,
        shared_device: SharedTypesDevice,
        device_address: DeviceAddress,
        message_map,
        broker,
    ):
        super().__init__()
        self.device = shared_device
        self.device_address = device_address
        self.message_map = message_map
        self.broker = broker

    def get_files_list(self) -> FilesList:
        """Получение информации о файле."""
        return self.device.cmds.core.fs.getFilesList()

    def get_files_info(self, file_id: uint16_t) -> FileInfo:
        """Получение информации о файле."""
        return self.device.cmds.core.fs.getFileInfo(file_id)

    def get_filenames(self) -> list:
        """Список имен файлов которые были найдены на устройстве."""
        return list(self.keys())

    def fill(self):
        """Запрос файлов с устройства."""
        files_on_device: FilesList = self.get_files_list()
        files_id_list: set = {file_id.value for file_id in files_on_device.filesId}
        for file_id in files_id_list:
            interface = CfgInterface(
                file_id=file_id,
                device_address=self.device_address,
                broker=self.broker,
                messages_map=self.message_map,
            )
            try:
                file_info = interface.file_handler.get_file_info()
            except Exception as exc:
                logger.error(
                    f'Something went wrong when fill config file with id={file_id} from device. '
                    f'Original exception is: {exc}',  # noqa: WPS326
                )
                continue
            filename = ''.join(
                chr(symbol.value) for symbol in file_info.name if symbol and symbol != 0
            )
            self[filename] = interface


class CfgHandler(CfgInterface):
    """OLD: Класс работы с конфигом на устройстве."""

    @deprecated('This method will be deleted in future versions.')
    def set_file_id(self, file_id: int):
        """Установка file id."""
        super().set_file_id(file_id)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].download_file()',
    )
    def download_bin(self) -> bytearray:
        """Загрузить файл с устройства."""
        return super().download_bin()

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].download_bin_into_file()',
    )
    def download_bin_file(self, bin_file_path: Path):
        """Загрузить файл с устройства в файл."""
        super().download_bin_file(bin_file_path)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].download_json()',
    )
    def download_json(self) -> dict[int, bytes]:
        """Загрузить файл с устройства в виде JSON."""
        return super().download_json()

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].download_into_json()',
    )
    def download_json_file(self, json_file_path: Path):  # noqa: WPS210
        """Загрузить файл с устройства в файл."""
        super().download_json_file(json_file_path)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].upload_bin()',
    )
    def upload_bin(self, bin_data):
        """Отгрузить файл на устройство."""
        super().upload_bin(bin_data)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].upload_bin_file()',
    )
    def upload_bin_file(self, bin_file_path: Path):
        """Отгрузить файл из файла на устройство."""
        super().upload_bin_file(bin_file_path)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].upload_json()',
    )
    def upload_json(self, json_data: Path):
        """Отгрузить JSON данные на устройство."""
        super().upload_json(json_data)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].upload_json_file()',
    )
    def upload_json_file(self, json_file_path: Path):
        """Отгрузить JSON файл на устройство."""
        super().upload_json_file(json_file_path)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].serialize_json_data()',
    )
    def serialize_json_data(self, json_data: dict) -> bytes:  # noqa: WPS210
        """Сериализовать данные JSON в бинарный формат."""
        return super().serialize_json_data(json_data)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg].get_message_name_and_type()',
    )
    def get_message_name_and_type(self, message_id: str) -> tuple:
        """Получить имя сообщения и тип данных по идентификатору."""
        return super().get_message_name_and_type(message_id)

    @deprecated(
        'This method will be deleted in future versions. Use cfg.files[file-name.cfg]._deserialize_json_messages()',
    )
    def _deserialize_json_messages(self, json_data: Dict) -> Dict:
        return super()._deserialize_json_messages(json_data)

    @deprecated(
        'This method will be deleted in future versions. ' +  # noqa: W504
        'Use cfg.files[file-name.cfg]._get_deserialized_message_data()',
    )
    def _get_deserialized_message_data(self, message_id: int, bin_data: bytes) -> tuple:
        return super()._get_deserialized_message_data(message_id, bin_data)
