"""Инструменты для работы имитатора прибора."""
import abc
import datetime
import hashlib
import inspect
import pickle  # noqa: S403
import time
from dataclasses import asdict, dataclass, field
from enum import Enum
from queue import SimpleQueue
from typing import ClassVar, Dict, List, Optional

from loguru import logger
from stw_py_api_runtime.gen_classes.message_params import (
    EntityParams, FirmwareEntityType, MessageHandler, MessageHandlerStorage,
)
from stw_py_api_runtime.gen_classes.telemetry.generator import TelemetryGenerator, TmFrequency, get_tm_frequency
from stw_py_api_runtime.gen_classes.telemetry.parse import Message, RepMessage
from stw_py_api_runtime.gen_classes.telemetry.predicates import StreamMsgChannel
from stw_py_api_runtime.gen_classes.types.params_covert import convert_to_int
from stw_py_api_runtime.gen_classes.types.returned_types import ReturnTypes
from stw_py_api_runtime.gen_shared_types.basic_types import uint16_t, uint32_t
from stw_py_api_runtime.gen_shared_types.tms.next_level.core_module.next_level.heartbeat import StatusTm
from stw_py_api_runtime.gen_shared_types.types.core.dtc.active_event_type import ActiveEvent
from stw_py_api_runtime.gen_shared_types.types.core.dtc.active_events_type import ActiveEvents
from stw_py_api_runtime.sdk.brokers.broker_api import BrokerAPI, SerializerAPI
from stw_py_api_runtime.sdk.brokers.fragments.commanding import Counter
from stw_py_api_runtime.sdk.brokers.fragments.subscribe import subscribe_to_device
from stw_py_api_runtime.sdk.brokers.message import DeviceAddress, Priority
from stw_py_api_runtime.sdk.device_clock_api import DeviceClockAPI
from stw_py_api_runtime.sdk.exceptions import MessageNotFoundError
from stw_py_api_runtime.serialization.message_data import BinSerializer, convert_rep_to_target_type

from stw_py_api_generator.naming import dotted_to_snake, upper_to_snake


class DtcTypes(Enum):
    """Типы DTC."""

    INFO = 0
    WARNING = 1
    ERROR = 2


def _get_device_methods(device_cls) -> list:
    return [
        cls_attr for cls_attr in inspect.getmembers(device_cls)  # noqa: WPS361
        if callable(cls_attr[1]) and not cls_attr[0].startswith('__')
    ]


def normalize_pygen_args(func):
    """Привести аргументы из пайгена к ожидаемым: msgId -> msg_id."""
    def wrapper(*args, **kwargs):
        new_kwargs = {upper_to_snake(name): value for name, value in kwargs.items()}
        return func(*args, **new_kwargs)
    return wrapper


class CoreHeartbeat:
    """Модуль core.heartbeat."""

    _status_handler_name = 'core.heartbeat.status'

    def disable_heartbeat(self) -> None:
        """Выключение heartbeat."""
        handler = self._message_handlers.get(self._status_handler_name)
        self._tm_generator.disable_message(handler)
        logger.info('Hearbeat is disabled')

    def enable_heartbeat(self) -> None:
        """Включение heartbeat."""
        handler = self._message_handlers.get(self._status_handler_name)
        if not handler:
            logger.warning('core.heartbeat.status not enabled, because not found in enabled out messages.')
            return

        self._tm_generator.enable_message(handler, TmFrequency.Heartbeat)
        logger.info('Hearbeat enabled')

    def set_heartbeat_state(self, state: StatusTm.State) -> None:
        """Простановка состояния в heartbeat."""
        self.heartbeat_status.state = state

    @normalize_pygen_args
    def _core_heartbeat_status(self, **kwargs) -> StatusTm:
        """TM: core.heartbeat.status."""
        return StatusTm(
            state=self.heartbeat_status.state,
            warnCnt=self.heartbeat_status.warnCnt,
            errCnt=self.heartbeat_status.errCnt,
        )

    def _handler_is_heartbeat(self, handler: MessageHandler) -> bool:
        """Проверка что handler является core.heartbeat.status."""
        return handler.name == self._status_handler_name


@dataclass
class DtcInfo:
    """Объект DTC для внутреннего вектора событий."""

    __slots__ = 'dtc_timestamp', 'dtc_expired_timestamp'
    dtc_timestamp: int
    dtc_expired_timestamp: int


@dataclass
class HistoryEvent:
    """Объект события для истории."""

    __slots__ = 'handler', 'datetime_timestamp'
    handler: MessageHandler
    datetime_timestamp: int


class CoreDtc(CoreHeartbeat):
    """Модуль core.dtc."""

    def clear_expired_dtc(self) -> None:
        """Очистка вектора активных событий по таймауту dtc."""
        if not self.vector_active_events:
            return
        events_to_remove = set()
        for dtc_event_msg_id, dtc_data in self.vector_active_events.items():
            expired_timestamp = dtc_data.dtc_expired_timestamp
            now_timestamp = datetime.datetime.now().timestamp()
            if expired_timestamp < now_timestamp:
                events_to_remove.add(dtc_event_msg_id)

        for event_msg_id in events_to_remove:
            self._remove_from_vector_events(event_msg_id)
            logger.info(f'DTC with msg_id: {event_msg_id} removed from activeEvents by timeout.')

    def deactivate_dtc(self, msg_name: str) -> None:
        """Деактивация DTC."""
        handler = self._get_hanlder(msg_name)
        if not handler:
            logger.warning('DTC not deactivated, because not found in enabled out messages.')
            return
        if handler.params.out_msg_id in self.vector_active_events:
            self._remove_from_vector_events(handler.params.out_msg_id)
            logger.info(f'DTC with name/msg_id: {handler.name}/{handler.params.out_msg_id} removed from activeEvents.')
        else:
            logger.info(f'DTC with name/msg_id: {handler.name}/{handler.params.out_msg_id} no longer in activeEvents.')

        self._check_vector_events()

    def dtc_flush(self) -> None:
        """Запись лога событий в файл, будет реализовано позже."""
        raise NotImplementedError

    def trigger_dtc(  # noqa: WPS211, WPS213, C901
        self,
        dtc_type: DtcTypes,
        dtc: object,
        msg_name: str = None,
        dtc_timestamp: Optional[float] = None,
        timeout: float = 0,
        **kwargs,
    ) -> None:
        """
        Активация DTC.

        :param dtc_type: Тип dtc. Ошибка или предупреждение
        :param dtc: Объект события/dtc
        :param msg_name: Имя dtc
        :param dtc_timestamp: Таймстамп dtc
        :param timeout: Таймаут (с). Время спустя которое dtc будет автоматически убран из вектора активных событий
        :param kwargs:
        :return:
        """
        if not msg_name:
            raise ValueError('Need msg_id or msg_name for trigger_dtc')

        if timeout < 0:
            raise ValueError('Timeout need to be greatest or equal 0')

        if not dtc_timestamp:
            dtc_timestamp = datetime.datetime.now().timestamp()

        handler = self._get_hanlder(msg_name)
        if not handler:
            logger.warning('DTC not triggered, because not found in enabled out messages.')
            return

        self._add_to_history(handler, dtc_timestamp)
        self._increase_heartbeat_status(dtc_type=dtc_type)
        if timeout:
            expired = self._calculate_dtc_expired(dtc_timestamp, timeout)
            self._add_to_vector_events(handler, dtc_timestamp, expired)
            self._check_vector_events()

        self._event_handler(msg_name, dtc)
        logger.info(f'DTC with name/msg_id: {handler.name}/{handler.params.out_msg_id} triggered')
        if timeout:
            logger.info(
                f'DTC with name/msg_id: {handler.name}/{handler.params.out_msg_id}.'
                f' Timeout = {timeout}s. '
                f'Expires on {datetime.datetime.fromtimestamp(int(dtc_timestamp) + int(timeout))}',
            )
        else:
            logger.info(
                f'DTC with name/msg_id: {handler.name}/{handler.params.out_msg_id}. '
                f'Timeout = 0s. Dtc will not be added to activeEvents',
            )

    def _add_to_history(self, handler: MessageHandler, dtc_timestamp: int) -> None:
        """Добавление в историю событий."""
        self.history_of_events.append(HistoryEvent(
            handler=handler,
            datetime_timestamp=dtc_timestamp,
        ))

    def _add_to_vector_events(self, handler: MessageHandler, dtc_timestamp: int, dtc_time_expired: int) -> None:
        """Добавление в вектор активных событий."""
        self.vector_active_events[
            handler.params.out_msg_id
        ] = DtcInfo(
            dtc_timestamp=dtc_timestamp,
            dtc_expired_timestamp=dtc_time_expired,
        )

    def _calculate_dtc_expired(self, dtc_timestamp: int, dtc_timeout: float) -> float:
        """Вычисление таймстампа по которому из вектора активных событий будет удален DTC."""
        return dtc_timestamp + dtc_timeout

    def _check_vector_events(self):
        """Проверка вектора активных событий."""
        if self.vector_active_events:
            self.set_heartbeat_state(StatusTm.State.Fail)
        else:
            self.set_heartbeat_state(StatusTm.State.Ok)

    def _core_dtc_activeEvents(self) -> ActiveEvents:
        """Возвращает вектор активных событий."""
        list_of_events = [
            ActiveEvent(
                msgid=event_msg_id,
                ts=dtc_info.dtc_timestamp,
                count=self._events_counter.next(),
            ) for event_msg_id, dtc_info in self.vector_active_events.items()
        ]
        return ActiveEvents(list_of_events)

    def _increase_heartbeat_status(self, dtc_type: DtcTypes) -> None:
        """Увеличение счетчика событий hearbeat."""
        if dtc_type.value == DtcTypes.ERROR.value:
            self.heartbeat_status.errCnt += 1
        elif dtc_type.value == DtcTypes.WARNING.value:
            self.heartbeat_status.warnCnt += 1

    def _get_hanlder(self, msg_name: str = None) -> MessageHandler:
        """Получение хэндлера DTC."""
        getter_param = msg_name
        return self._message_handlers.get(getter_param)

    def _remove_from_vector_events(self, handler_msg_id) -> None:
        """Удаление из вектора активных событий."""
        self.vector_active_events.pop(handler_msg_id)


class CoreTmModule:
    """Модуль core.tm."""

    @normalize_pygen_args
    def _core_tm_set_periods(self, return_types: ReturnTypes, often, ordinary, rare):
        """CMD: Задать периоды отправки тм-сообщений."""
        logger.trace('Received core.tm.setPeriodics command for setting telemetry periods')
        periods_ms = {
            TmFrequency.Often: often,
            TmFrequency.Ordinary: ordinary,
            TmFrequency.Rare: rare,
        }
        try:
            self.set_telemetry_periods(periods_ms)
        except Exception as exp:
            logger.error(f'Failed to set telemetry periods: {exp}')
            return return_types.error_type.CmdBadArg
        return return_types.successful_type.Ok

    @normalize_pygen_args
    def _core_tm_enable_msg(self, return_types: ReturnTypes, msg_id, freq, **kwargs):
        """CMD: Задать частоту отправки тм-сообщения."""
        logger.trace('Received core.tm.enableMsg command for periodic message enabling')
        try:
            self.enable_tm_stream(msg_id, freq)
        except Exception as exp:
            logger.error(f'Failed to enable tm {msg_id} with freq {freq}. Details: {exp}')
            return return_types.error_type.CmdBadArg
        return return_types.successful_type.Ok

    @normalize_pygen_args
    def _core_tm_disable_msg(self, return_types: ReturnTypes, msg_id):
        """CMD: Прекратить отправку тм-сообщения."""
        logger.trace('Received core.tm.disableMsg command for periodic message disabling')
        try:
            self.disable_tm_stream(msg_id)
        except Exception as exp:
            logger.error(f'Failed to disable tm {msg_id}: {exp}')
            return return_types.error_type.CmdBadArg
        return return_types.successful_type.Ok


class CorePgkModule:
    """Модуль core.pkg."""

    @normalize_pygen_args
    def _core_pkg_get_meta(self, return_types: ReturnTypes):
        """CMD: Запрос метаинформации."""
        try:
            return return_types.successful_type(
                size=len(self.zpaq_firmware_data),
                hash=hashlib.sha3_512(self.zpaq_firmware_data).digest()[:12],
            )
        except Exception as exp:
            logger.error(f'Failed to return core.pkg.PackageMeta: {exp}')
            return return_types.error_type.CmdBadContext

    @normalize_pygen_args
    def _core_pkg_get_chunk(self, return_types: ReturnTypes, offset: int, size: int):
        """CMD: Выгрузить часть описания интерфейса."""
        try:
            chunk = self.zpaq_firmware_data[offset:offset + size]
            return return_types.successful_type(
                offset=offset,
                size=size,
                data=chunk + b'\x00' * (100 - size),
            )
        except Exception as exp:
            logger.error(f'Failed to return core.pkg.FixedChunk: {exp}')
            return return_types.error_type.CmdBadContext


@dataclass
class DeviceSim(CoreTmModule, CorePgkModule, CoreDtc):
    """Базовый класс для имитатора прибора."""

    broker: BrokerAPI
    clock: Optional[DeviceClockAPI] = None
    device_id: Optional[int] = None
    ip_address: Optional[str] = None

    _device_address: DeviceAddress = None
    _broadcast_id: int = 0x0
    _messages_gen_params: ClassVar[Dict[str, EntityParams]]
    _message_handlers: MessageHandlerStorage = field(default_factory=MessageHandlerStorage)
    _serializer: BinSerializer = BinSerializer()
    _in_messages: SimpleQueue = field(default_factory=SimpleQueue)
    _tick_out_messages: list = field(default_factory=list)
    _events_counter: Counter = field(default_factory=Counter)

    vector_active_events: Dict[int, DtcInfo] = field(default_factory=dict)
    history_of_events: List[HistoryEvent] = field(default_factory=list)

    heartbeat_status: StatusTm = field(
        default_factory=lambda: StatusTm(
            state=StatusTm.State.Ok,
            warnCnt=uint32_t(0),
            errCnt=uint32_t(0),
        ),
    )

    def __post_init__(self):
        self._device_address = DeviceAddress(node_id=self.device_id, endpoint=self.ip_address)  # noqa: WPS601
        self._init_message_handlers()

        self._start_in_messages_receiving()
        self._message_creator = self.broker.message_creator
        self._tm_generator = TelemetryGenerator(
            device_address=self._device_address,
            receiver_address=self.broker._address,
            message_creator=self._message_creator,
            serializer=self._serializer,
            clock=self.clock,
        )
        self.enable_heartbeat()
        logger.debug(f'Device simulator ({self._device_address}) started')

    @property
    @abc.abstractmethod
    def yml_firmware_data(self) -> bytes:
        """YML прошивка."""
        raise NotImplementedError

    @property
    @abc.abstractmethod
    def zpaq_firmware_data(self) -> bytes:
        """ZPAQ прошивка."""
        raise NotImplementedError

    def get_incoming_messages(self):
        """Получить накопленные входящие сообщения для прибора."""
        accumulated_msgs_count = self._in_messages.qsize()
        return [self._in_messages.get() for _ in range(accumulated_msgs_count)]

    def process(self, in_messages=None):
        """Обработка входящих сообщений и сохранение ответных в буфер."""
        if in_messages is None:
            in_messages = self.get_incoming_messages()

        for in_message in in_messages:
            self._process_message(in_message)

    def flush(self, delay: float = 0.001):
        """Отправка всех накопленных за тик сообщений, очистка буфера сообщений."""
        if not self._tick_out_messages:
            time.sleep(delay)
            return
        logger.trace(f'Sent {len(self._tick_out_messages)} msgs')
        self.broker.send_transport_messages(self._tick_out_messages)
        self._tick_out_messages.clear()

    def tick(self):
        """Пользовательский код, выполняющийся на каждый тик."""

    def generate_tm(self):
        """Генерация статусной ТМ."""
        messages = self._tm_generator.generate()
        self._tick_out_messages.extend(messages)

    def set_telemetry_periods(self, periods_ms: Dict[TmFrequency, uint16_t]):
        """Устанавливает периоды для разных типов частот (Rare, Ordinary, Often)."""
        self._tm_generator.set_periods(periods_ms)

    def set_message_priority(self, priority: Priority, message_name: str = None, message_id: int = None):
        """Простановка приоритета для сообщения."""
        if not message_id and not message_name:
            raise ValueError('Need message_id or message_name')

        message_handler = self._message_handlers.get(message_name) if message_name \
            else self._message_handlers.get(message_id)  # noqa: N400
        if not message_handler:
            logger.warning(f'Priority for tm {message_id} not set, because not found in message storage')
            return

        message_handler.priority = priority

    def enable_tm_stream(self, message_id: int, pygen_freq: Enum):
        """Включить поток ТМ с заданной частотой."""
        handler = self._message_handlers.get(message_id, None)
        if not handler:
            logger.warning(f'Tm {message_id} not enabled, because not found in enabled out messages')
            return

        freq = get_tm_frequency(pygen_freq)
        self._tm_generator.enable_message(handler, freq)

    def disable_tm_stream(self, message_id: int):
        """Выключить поток ТМ."""
        handler = self._message_handlers.get(message_id, None)
        if not handler:
            logger.warning(f'Tm {message_id} not disabled, because not found in enabled out messages.')
            return
        if self._handler_is_heartbeat(handler):
            logger.warning('Can not disable heartbeat from external source. Use .disable_hearbeat()')
            return
        self._tm_generator.disable_message(handler)

    def stop(self):
        """Остановить обработку сообщений в симуляторе."""
        subscribers = (
            self._device_msg_sub_id,
            self._broadcast_msg_sub_id,
        )
        for subscriber_id in subscribers:
            self.broker.unsubscribe_from_tm(subscriber_id)

        logger.debug(f'Device simulator (node id: {hex(self.device_id)}) stopped')

    @property
    def _entity_message_map(self):
        raise NotImplementedError

    def _process_message(self, in_message):
        """Обработать одно сообщение."""
        message_id = self._message_creator.get_message_id(in_message)
        handler = self._message_handlers.get(message_id, None)
        if not handler:
            # сообщение не включено и никак не обрабатывается
            return

        req_args = self._deserialize_req_data(in_message.data, handler)
        logger.trace(f'Received command {handler.name}: args {req_args}')
        response = self._run_handler(handler, convert_to_int(req_args))

        if self._message_creator.get_device_id(in_message) == self._broadcast_id:
            # по broadcast адресу прибор команду выполняет, но не отвечает
            logger.trace(f'Broadcast command {handler.name} executed: args {req_args}, rep {response}')
            return

        rep_data = self._serialize_rep_data(response, handler)
        out_message = self._create_rep_message(rep_data, in_message, handler)
        self._tick_out_messages.append(out_message)
        logger.trace(f'Generated response to command {handler.name}: {response}')

    def _get_handler(self, in_message, channel):
        channel_in_msg_handlers_map = {
            StreamMsgChannel.REQ_REP: self._message_handlers,
        }
        message_id = self._message_creator.get_message_id(in_message)
        handlers_map = channel_in_msg_handlers_map[channel]
        return handlers_map.get(message_id, None)

    def _run_handler(self, handler, req_args):
        """Запускаем хендлер."""
        return handler.response_getter(**req_args)

    def _start_in_messages_receiving(self):
        """Запустить сбор всех сообщений для прибора и broadcast."""

        def _add_to_queue(message, attr_name):
            if getattr(message, attr_name, False):
                return
            self._in_messages.put(message)

        def _add_to_rep_queue(message):
            _add_to_queue(message, 'is_rep')

        self._device_msg_sub_id = subscribe_to_device(
            broker=self.broker,
            device_id=self.device_id,
            ip_address=self.ip_address,
            channel=StreamMsgChannel.REQ_REP,
            call=_add_to_rep_queue,
        )
        self._broadcast_msg_sub_id = subscribe_to_device(
            broker=self.broker,
            device_id=self._broadcast_id,
            ip_address=self.ip_address,
            channel=StreamMsgChannel.REQ_REP,
            call=_add_to_rep_queue,
        )

    def _deserialize_req_data(self, req_data: Message, handler: MessageHandler) -> dict:
        if handler.entity_type == FirmwareEntityType.CMD:
            raw_req = self._serializer.deserialize_cmd_args(req_data, handler.params.req_data_type)
            req_object = raw_req[0]
            return asdict(req_object)
        return {}

    def _serialize_rep_data(self, response: Message, handler: MessageHandler) -> bytes:
        try:
            return _serialize_rep_by_entity(
                entity_type=handler.entity_type,
                serializer=self._serializer,
                rep_data=response,
                rep_type=handler.params.out_data_type,
            )
        except Exception as exp:
            logger.error(
                f'Failed to serialize {handler.name} rep to correct yaml type. Data will be sent raw. Details: {exp}',
            )
            return pickle.dumps(response)

    def _create_rep_message(self, rep_message_data, in_message, handler: MessageHandler):
        """Сформировать транспортное сообщение-ответ."""
        timestamp = self.clock.get_system_time() if self.clock else None

        return self._message_creator.create_command_message_rep(
            receiver_address=self.broker._address,
            sender_address=self._device_address,
            message_id=handler.params.rep_msg_id,
            timestamp=timestamp,
            counter=in_message.header.cti,
            rep_data=rep_message_data,
            priority=Priority(in_message.header.priority),
        )

    @normalize_pygen_args
    def _event_handler(
        self,
        message_name: str,
        event: object,
        priority: Optional[Priority] = Priority.LOW,
    ):
        """
        Общий метод для обработки EVENT-сообщений.

        :param message_name: имя сообщения (фиксируется partialmethod'ом)
        :param event: объект эвента который будет отправлен.
        """
        msg_id = self._message_handlers.get(message_name).params.out_msg_id
        serialized_data = self._serializer.serialize_tm(event)
        timestamp = self.clock.get_system_time() if self.clock else None

        out_message = self._message_creator.create_event_message(
            sender_address=self._device_address,
            receiver_address=self.broker._address,
            message_id=msg_id,
            data=serialized_data,
            counter=self._events_counter.next(),
            priority=priority,
            timestamp=timestamp,
        )
        self._tick_out_messages.append(out_message)

    def _init_message_handlers(self):
        for message_name, message in self._entity_message_map.items():
            method_call = getattr(self, dotted_to_snake(message_name), None)
            if method_call is None and message.type != FirmwareEntityType.CFG:
                raise MessageNotFoundError(
                    f'Device {self.__class__.__name__} does not have message "{message_name}". Check firmware.',
                )

            handler = MessageHandler(
                entity_type=message.type,
                name=message_name,
                response_getter=method_call,
                params=message.get_msg_params(),
            )
            self._message_handlers.add(handler=handler)


def _serialize_rep_by_entity(
    entity_type: FirmwareEntityType,
    serializer: SerializerAPI,
    rep_data: Message,
    rep_type: RepMessage,
):
    """Сериализовать ответ в зависимости от того, команда это или ТМ."""
    if entity_type == FirmwareEntityType.TM:
        return serializer.serialize_tm_rep(rep_data)
    elif entity_type == FirmwareEntityType.CMD:
        rep_data = convert_rep_to_target_type(rep_data, rep_type.return_types)
        return serializer.serialize_cmd_rep(rep_data, rep_type.return_types)
    raise ValueError(f'Data of firmware type {entity_type} can not be serialized like rep.')
