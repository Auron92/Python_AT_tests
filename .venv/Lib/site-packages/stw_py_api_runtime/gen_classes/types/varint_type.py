"""Базовый класс для varint типов из yaml."""
# flake8: noqa WPS341
import struct
from decimal import Decimal
from typing import Tuple

from stw_py_api_runtime.gen_classes.types.number import FloatInt, get_int_min_max


def varint_decoder(mask, result_type):  # noqa: C901, WPS231
    """Декодер varuint честно взятый из репозитория protobuf. Файл: protobuf.internal.decoder."""
    def decode_varint(buffer, pos: int = None):  # noqa: WPS231
        """Декодер."""
        result = 0
        shift = 0
        while True:
            one_byte = buffer[pos]
            pos += 1
            result |= ((one_byte & 0x7f) << shift)
            if not (one_byte & 0x80):
                result &= mask
                result = result_type(result)
                return result if pos is None else (result, pos)
            shift += 7
            if shift >= 64:
                raise ValueError('Too many bytes when decoding varint.')

    return decode_varint


def signed_varint_decoder(bits, result_type):
    """Декодер varint честно взятый из репозитория protobuf. Файл: protobuf.internal.decoder."""
    signbit = 1 << (bits - 1)
    mask = (1 << bits) - 1

    def decode_varint(buffer, pos):
        """Декодер."""
        result = 0
        shift = 0
        while True:
            one_byte = buffer[pos]
            result |= ((one_byte & 0x7f) << shift)
            pos += 1
            if not (one_byte & 0x80):
                result &= mask
                result = (result ^ signbit) - signbit
                result = result_type(result)
                return (result, pos)
            shift += 7
            if shift >= 64:
                raise ValueError('Too many bytes when decoding varint.')

    return decode_varint


def varint_encoder():
    """Энкодер varuint честно взятый из репозитория protobuf. Файл: protobuf.internal.encoder."""
    local_int2byte = struct.Struct('>B').pack

    def encode_varint(write, value, unused_deterministic=None):
        """Энкодер."""
        bits = value & 0x7f
        value >>= 7
        while value:
            write(local_int2byte(0x80 | bits))
            bits = value & 0x7f
            value >>= 7
        return write(local_int2byte(bits))

    return encode_varint


def signed_varint_encoder():
    """Энкодер varint честно взятый из репозитория protobuf. Файл: protobuf.internal.encoder."""
    local_int2byte = struct.Struct('>B').pack

    def encode_varint(write, value, unused_deterministic=None):
        """Энкодер."""
        if value < 0:
            value += (1 << 64)
        bits = value & 0x7f
        value >>= 7
        while value:
            write(local_int2byte(0x80 | bits))
            bits = value & 0x7f
            value >>= 7
        return write(local_int2byte(bits))

    return encode_varint


class VarIntBase:
    """Базовый класс для описания varint."""

    bit_size: int
    is_signed: bool

    def __init__(self, value):
        if isinstance(value, int):
            self.value = value
        else:
            raise TypeError('Value must be an int or a float')

    def __repr__(self):
        return f'Varint:{self.value.__repr__()}'

    def __str__(self):
        return self.value.__str__()

    @classmethod
    def from_bin(cls, bin_data: bytes) -> Tuple['VarIntBase', bytes]:
        """Конструирование из байтов."""
        instance = cls()
        decoder = instance.get_decoder()
        data, position = decoder(bin_data, 0)
        instance = cls(cls.zigzag_from(data) if instance.is_signed else data)
        return instance, bin_data[position:]

    @classmethod
    def from_json(cls, json_data: int):
        """Десериализация."""
        instance = cls()
        if isinstance(json_data, int):
            bit_size = instance.bit_size
            min_val, max_val = get_int_min_max(instance.is_signed, bit_size)

            if json_data < min_val or json_data > max_val:
                raise ValueError(f'Value {json_data} is out of range for {cls.__name__}, bit size {bit_size}.')
            instance = cls(json_data)
        else:
            raise TypeError(f'Unsupported type for deserialization: {type(json_data)}.')
        return instance

    def get_decoder(self):
        """Геттер декодера в зависимости от наличия знака."""
        decoder = varint_decoder((1 << self.bit_size) - 1, int)
        if self.is_signed:
            decoder = signed_varint_decoder(self.bit_size, int)
        return decoder

    def get_encoder(self):
        """Геттер энкодера в зависимости от наличия знака."""
        return signed_varint_encoder() if self.is_signed else varint_encoder()

    def to_bin(self) -> bytes:
        """Преобразование в байты."""
        value = self.zigzag_to(self.value) if self.is_signed else self.value
        pieces = []
        encoder = self.get_encoder()
        encoder(pieces.append, value)
        return b''.join(pieces)

    def to_json(self) -> int:
        """Сериализация."""
        return self.value

    @staticmethod
    def zigzag_to(value) -> int:  # noqa: WPS602
        """Метод кодирования ZigZag для знаковых чисел."""
        if value >= 0:
            outgoing_value = value * 2
        else:
            outgoing_value = (-value * 2) - 1

        return outgoing_value

    @staticmethod
    def zigzag_from(value) -> int:  # noqa: WPS602
        """Метод декодирования ZigZag для знаковых чисел."""
        if value % 2 == 0:
            outgoing_value = Decimal(value) / 2
        else:
            outgoing_value = -(Decimal(value) + 1) / 2
        return int(outgoing_value)
