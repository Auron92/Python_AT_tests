"""Базовый класс для array типов из yaml."""
from collections.abc import Iterable
from typing import Any, List, Tuple

from stw_py_api_runtime.gen_classes.cmd_helpers import ensure_instance
from stw_py_api_runtime.gen_classes.telemetry.parse import construct_from_json
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable


class ArrayBase(Serializable):
    """Базовый класс для того, что в yml файле называется array.

    Для каждого array указывается count (кол-во элеметов);
    Тип элемента (kind)
    """

    element_type: type
    count: int

    def __init__(self, items: list = None):
        self._storage: List[Any] = []
        # fill storage with default elements
        if items is None:
            elements = [self.element_type()] * self.count  # noqa: WPS435
        else:
            elements = [ensure_instance(item, self.element_type) for item in items]
        self._storage.extend(elements)

    def __getitem__(self, array_item):
        return self._storage[array_item]

    def __setitem__(self, key, array_value):
        self._storage[key] = array_value

    def __eq__(self, other):
        if isinstance(other, Iterable):
            other_list = list(other)
        elif getattr(other, '_storage', None):
            other_list = other._storage  # noqa: WPS437
        else:
            other_list = other.value
        return self._storage == other_list  # noqa: WPS437

    def __repr__(self) -> str:
        return f'Array: {self.__class__.__name__}[{self.element_type.__name__}]: {self._storage}'

    def __len__(self) -> int:
        return len(self._storage)

    @classmethod
    def from_json(cls, json_data: list):
        """Конструирование из json данных."""
        storage = []
        for idx, element in enumerate(json_data):
            new_item = construct_from_json(cls.element_type, element)
            storage.insert(idx, new_item)
        return cls(items=storage)

    def to_json(self) -> List[str]:
        """Сериализация в json.dumps compatible формат."""
        json_data = []
        for item in self._storage:
            if issubclass(type(item), Serializable):
                json_data.append(item.to_json())
                continue
            json_data.append(str(item))
        return json_data

    def to_bin(self) -> bytes:
        """Сериализация в байтики массива."""
        bin_repr = bytearray()
        for item in self._storage:
            bin_repr.extend(item.to_bin())
        return bytes(bin_repr)

    @classmethod
    def from_bin(cls, bin_data: bytes) -> Tuple['ArrayBase', bytes]:
        """Конструирование объекта из байтиков."""
        storage_content = []
        for _ in range(cls.count):
            new_item, bin_data = cls.element_type.from_bin(bin_data)
            storage_content.append(new_item)
        return cls(storage_content), bin_data
