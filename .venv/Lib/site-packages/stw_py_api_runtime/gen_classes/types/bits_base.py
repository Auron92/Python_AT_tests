"""Базовый класс для array bits из yaml."""
import struct
from dataclasses import dataclass, fields
from math import ceil
from typing import Dict, Tuple

from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.general import bytes_count, enough_bytes_count
from stw_py_api_runtime.sdk.exceptions import BitsDeserializeError, BytesDecodeError, BytesEncodeError

little_endian = '<'


class BitsBase(Serializable):
    """Класс для типа bits.

    Содержит N-е количество бит полей - BitsField, каждое из которых имеет значение и размер.
    """

    bytes_size = 0

    def __init__(self, *args, **kwargs):
        if args:
            self._set_from_array(args)
        elif kwargs:
            self._set_from_named_args(kwargs)
        else:
            # empty init for further bin-constructor
            self.bit_order = little_endian

    def __repr__(self) -> str:
        content = {
            field.name: getattr(self, field.name)
            for field in fields(self)  # noqa: WPS204
        }
        return f'<{self.__class__.__name__}: {content}>'

    def __getitem__(self, key):
        return self.__dict__[key]

    def keys(self):
        """Получение ключей из аттрибутов класса."""
        return [key for key in self.__dict__.keys() if key != 'base_type']

    def values(self):
        """Получение всех значений."""
        return self.items().values()

    def items(self):
        """Получить все объекты класса-словаря."""
        return {key: value for key, value in self.__dict__.items() if key != 'base_type'}

    def get(self, key, default=None):
        """Получение объекта по имени."""
        return self.__dict__.get(key, default)

    @classmethod
    def from_json(cls, json_data: dict):
        """Десериализация из json формата."""
        storage = []
        for field in fields(cls):
            attribute = json_data[field.name]
            storage.append(attribute)
        return cls(*storage)

    def to_json(self) -> Dict:
        """Сериализация в json формат."""
        return {
            field.name: getattr(self, field.name).to_json()
            for field in fields(self)
        }

    @classmethod
    def from_bin(cls, bin_data: bytes) -> Tuple['BitsBase', bytes]:
        """Десериализация из байтов."""
        instance = cls()
        cls.bytes_size = get_enough_bytes_size(instance)
        type_data = bin_data[:cls.bytes_size]
        try:
            instance.set_instance_from_bits(type_data)
        except Exception as exp:
            raise BytesDecodeError(f'Failed to set bits instance {cls.__name__} from bytes {type_data}') from exp
        return instance, bin_data[cls.bytes_size:]

    def set_instance_from_bits(self, data: bytes):  # noqa: WPS210
        """Установка значений полей объекта из их битового представления.

        Описание, как упакованы битовые поля в байтах в зависимости от базового типа (блок Bits):
        https://c.1440.space/pages/viewpage.action?pageId=107919238
        """
        base_type = get_and_check_base_type(self)
        buffer_limit = base_type.bit_size
        cur_buffer = 0

        elements = get_sequence_by_base_type(data, self.bytes_size, base_type)
        element_idx = 0

        for field in fields(self):
            field_value = getattr(self, field.name)
            if field_value.size > (buffer_limit - cur_buffer):
                element_idx += 1
                cur_buffer = 0

            cur_base_data = elements[element_idx]
            field_value, cur_buffer = get_field_value_from_data(field_value, cur_buffer, cur_base_data)

    def to_bin(self) -> bytes:
        """Сериализация в байты."""
        try:
            bytes_data = self.set_data_from_instance()
        except Exception as exp:
            raise BytesEncodeError(f'Failed to set bytes from bits instance {self}') from exp

        return bytes_data

    def set_data_from_instance(self) -> bytes:  # noqa: WPS231, WPS210, C901
        """Сборка объекта в байты.

        Описание, как упакованы битовые поля в байтах в зависимости от базового типа (блок Bits):
        https://c.1440.space/pages/viewpage.action?pageId=107919238
        """
        fields_count = len(fields(self))
        base_type = get_and_check_base_type(self)
        bits_limit = base_type.bit_size
        cur_buffer = 0
        cur_base_data = 0
        elements = []

        for field_idx, field in enumerate(fields(self)):
            field_value = getattr(self, field.name)
            field_size_remaining = field_value.size

            while field_size_remaining > 0:
                available_bits = bits_limit - cur_buffer
                bits_count_to_write = min(field_size_remaining, available_bits)

                cur_base_data, cur_buffer = add_field_value_to_data(
                    field_value,
                    cur_buffer,
                    cur_base_data,
                    bits_count_to_write,
                )

                field_size_remaining -= bits_count_to_write

                if cur_buffer == bits_limit or field_size_remaining > 0:
                    # Запаковываем текущие базовые данные в байты и добавляем в список элементов
                    try:
                        current_base_bytes = pack_bytes(base_type.fmt_char, cur_base_data)  # noqa: WPS220
                    except struct.error as exc:
                        raise BytesEncodeError(  # noqa: WPS220
                            f'Failed to pack to bytes with format {base_type.fmt_char}. Error: {exc}',
                        )
                    elements.append(current_base_bytes)
                    cur_base_data = 0
                    cur_buffer = 0

                if not _write_buffer_forward(field_idx, fields_count, cur_buffer, bits_limit):
                    break

        # Добавление последнего элемента, если есть оставшиеся биты
        if cur_buffer > 0:
            try:
                elements.append(pack_bytes(base_type.fmt_char, cur_base_data))
            except struct.error as exc:  # noqa: WPS440
                raise BytesEncodeError(f'Failed to pack to bytes with format {base_type.fmt_char}. Error: {exc}')

        return b''.join(elements)

    def _cast_int_to_bits_field(self):
        for field in fields(self):
            if isinstance(field.type, type) and issubclass(field.type, BitsField):
                field_value = getattr(self, field.name, None)
                if isinstance(field_value, int):
                    field_value = field.type(size=field.default_factory().size, value=field_value)
                    setattr(self, field.name, field_value)

    def _set_from_array(self, orig_data: tuple):
        """Сконструировать bits объект из массива значений."""
        for idx, field in enumerate(fields(self)):
            value = orig_data[idx]
            self._set_attr(field.name, field.type, value)

    def _set_from_named_args(self, orig_data: dict):
        """Сконструировать bits объект из именнованых значений."""
        for field in fields(self):
            value = orig_data[field.name]
            self._set_attr(field.name, field.type, value)

    def _set_attr(self, name, obj_type, value):
        """Собрать bits значение с размером size из прошивки."""
        size = value.bit_length()
        max_size = getattr(self, name).size
        if size > max_size:
            raise BytesEncodeError(
                f'Bits field is oversized. {name=} {value=} {size=} > {max_size} max size',
            )

        pre_value = obj_type(value=value, size=max_size)
        setattr(self, name, pre_value)


@dataclass
class BitsField(Serializable):
    """Одно поле в структуре Bits.

    value: значение
    size: количество выделенных на него бит
    """

    value: int = 0
    size: int = 1

    def to_json(self):
        """Сериализация в json формат."""
        return self.value

    def __repr__(self) -> str:
        return f'<{self.__class__.__name__}: {self.value}[{self.size}]>'

    def __and__(self, other):
        if isinstance(other, BitsField):
            return BitsField(self.value & other.value)
        return BitsField(self.value & other)

    def __or__(self, other):
        if isinstance(other, BitsField):
            return BitsField(self.value | other.value)
        return BitsField(self.value | other)

    def __invert__(self):
        return BitsField(not self.value)

    def __rshift__(self, other):
        return BitsField(self.value << other)

    def __lshift__(self, other):
        return BitsField(self.value >> other)

    def __xor__(self, other):
        if isinstance(other, BitsField):
            return BitsField(self.value ^ other.value)
        return BitsField(self.value ^ other)


def _bit_mask(bit_size: int) -> int:
    return (1 << bit_size) - 1


def unpack_bytes(fmt: str, bytes_data: bytes, bit_order=little_endian) -> int:
    """Распаковать байты в little-endian порядке."""
    return struct.unpack(f'{bit_order}{fmt}', bytes_data)[0]


def pack_bytes(fmt: str, data: int, bit_order=little_endian) -> bytes:
    """Запаковать в байты в little-endian порядке."""
    return struct.pack(f'{bit_order}{fmt}', data)


def get_and_check_base_type(original_type):
    """Проверить, что у типа есть базовый."""
    base_type = getattr(original_type, 'base_type', None)
    has_size = hasattr(base_type, 'bit_size')  # noqa: WPS421
    has_fmt = hasattr(base_type, 'fmt_char')  # noqa: WPS421

    if base_type is None or not all([has_size, has_fmt]):
        raise BitsDeserializeError('Impossible (de)serialize bits type: required base type with bit size and fmt.')
    return base_type


def get_enough_bytes_size(instance: BitsBase):
    """Получить достаточный размер в байтах для хранения всех битовых полей типа."""
    bits_count = 0
    for attr in fields(instance):
        attr_value = getattr(instance, attr.name)
        bits_count += attr_value.size

    bytes_enough_size = enough_bytes_count(bits_count)
    base_bytes_size = bytes_count(instance.base_type.bit_size)
    if base_bytes_size >= bytes_enough_size:
        return base_bytes_size

    base_sample_count = ceil(bytes_enough_size / base_bytes_size)
    return base_sample_count * base_bytes_size


def get_sequence_by_base_type(data: bytes, data_size: int, base_type) -> list:
    """Разбить последовательность байт на куски по базовому типу и преобразовать в значения.

    xff x07 xff xff xff xff -> при K=2 -> [xff x07,  xff xff,  xff xff] -> [val1, val2, val3]
    Длина последовательности всегда кратна K.

    Args:
        data: исходная последовательность байт
        data_size: размер последовательности в байтах
        base_type: базовый тип, у которого берем размер и символ формата для десериализации

    Returns:
        список преобразованных элементов
    """
    base_type_size = bytes_count(base_type.bit_size)
    elements = []
    for idx in range(0, data_size, base_type_size):
        value = data[idx:(idx + base_type_size)]
        cur_base_data = unpack_bytes(base_type.fmt_char, value)
        elements.append(cur_base_data)
    return elements


def get_field_value_from_data(field: BitsField, bits_shift: int, raw_data: int) -> Tuple[BitsField, int]:
    """Взять значение поля из сэмпла байтов и установить в объект.

    Пример:
    Чтение происходит справа налево. Исходные данные (raw_data) 0b011001110.
    Сначала сдвигаем на K бит (bits_shift=2) слева направо, чтобы справа у нас были биты нужного поля.
    * bits_shift - это количество бит, которое мы уже считали раннее от этих же данных.
    Получаем 0b000110011.
    Потом берем справа L бит по размеру поля (field.size=3), сохраняем и увеличиваем величину сдвига bits_shift
    на размер считанного поля field.size (bits_shift теперь равен 5).
    Значение поля из 3 бит от 0b000110011 равно 011.

    Args:
        field: экземпляр битового поля
        bits_shift: K - количество бит, на которое надо сместиться перед чтением
        raw_data: число, из которого надо взять значение битового поля

    Returns:
        обновленный field со считанным значением и новый сдвиг
    """
    mask = _bit_mask(field.size)
    field_value = (raw_data >> bits_shift) & mask
    field.value = field_value
    bits_shift += field.size
    return field, bits_shift


def add_field_value_to_data(
    field: BitsField,
    bits_shift: int,
    set_data: int,
    bits_count_to_write: int,
) -> Tuple[int, int]:
    """Добавить часть значения поля к числу слева.

    Args:
        field: экземпляр битового поля.
        bits_shift: количество бит, на которое надо сместиться перед добавлением.
        set_data: число, к битовому представлению которого добавляется часть поля слева.
        bits_count_to_write: количество бит из значения поля для добавления.

    Returns:
        обновленное число с добавленной частью значения и новый сдвиг.
    """
    # Определяем, какую часть значения поля нужно использовать
    # Если bits_count_to_write меньше размера поля, используем только требуемую часть
    value_to_write = (field.value >> (field.size - bits_count_to_write)) & ((1 << bits_count_to_write) - 1)

    # Добавляем значение к set_data
    set_data |= (value_to_write << bits_shift)
    bits_shift += bits_count_to_write

    return set_data, bits_shift


def _write_buffer_forward(field_idx: int, fields_count: int, cur_buffer: int, bits_limit: int) -> bool:
    return field_idx == (fields_count - 1) or cur_buffer == bits_limit
