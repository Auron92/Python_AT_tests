"""Тип Bytes."""
import struct
from typing import Tuple

from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.sdk.exceptions import BytesDecodeError


class Bytes(Serializable):
    """Тип под bytes в yml-e."""

    def __init__(self, value: bytes = b''):
        self.value = value

    def from_json(self, json_data: str):
        """Десериализация из JSON."""
        try:
            hex_str = json_data.replace(' ', '')
            self.value = bytes.fromhex(hex_str)
        except ValueError as error:
            raise BytesDecodeError(f'Error decoding hex data: {error}')

    def to_json(self) -> str:
        """Сериализация в JSON формат."""
        return ' '.join(f'{byte:02x}' for byte in self.value)

    @classmethod
    def from_bin(cls, bin_data: bytes) -> Tuple['Bytes', bytes]:
        """Десериализация из bytes."""
        instance = cls()
        size_bytes = 2  # количество байт, в которых хранится длина данных
        raw_data_size = bin_data[:size_bytes]
        try:
            data_size = struct.unpack('<H', raw_data_size)[0]
        except struct.error as exc:
            raise BytesDecodeError(
                f'Failed getting of bytes data size. Must be in {size_bytes} bytes. '
                f'{size_bytes=}, {bin_data=}. Error: {exc}',  # noqa: WPS326
            )

        data_end_idx = size_bytes + data_size
        instance.value = bin_data[size_bytes:data_end_idx]
        return instance, bin_data[data_end_idx:]

    def to_bin(self) -> bytes:
        """Двоичное представление."""
        size = len(self.value)
        size_little_endian = struct.pack('<H', size)
        return size_little_endian + self.value

    def __repr__(self) -> str:
        return f'<{self.__class__.__name__}: {self.value}>'

    def __eq__(self, other):
        return self.value == other
