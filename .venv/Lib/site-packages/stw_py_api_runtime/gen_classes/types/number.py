"""Класс общий для всех числовх типов. Разной разрядности и знаковости."""
import struct
from numbers import Complex
from typing import Tuple, Union
from warnings import warn

from loguru import logger

from ...general import bytes_count
from ...sdk.exceptions import BytesDecodeError
from .serializable_base import Serializable


class MathIntOperations:
    """Math operations for int."""

    def __add__(self, other):
        val = self._get_value()
        return self.__class__(val + number_value(other))

    def __radd__(self, other):
        return self.__add__(other)

    def __sub__(self, other):
        val = self._get_value()
        return self.__class__(val - number_value(other))

    def __rsub__(self, other):
        return self.__class__(number_value(other) - self._get_value())

    def __mul__(self, other):
        return self.__class__(self._get_value() * number_value(other))

    def __rmul__(self, other):
        return self.__mul__(other)

    def __truediv__(self, other):
        return float(self._get_value() / number_value(other))

    def __rtruediv__(self, other):
        return float(number_value(other) / self._get_value())

    def __floordiv__(self, other):
        return float(self._get_value() // number_value(other))

    def __rfloordiv__(self, other):
        return float(number_value(other) // self._get_value())

    def __mod__(self, other):
        return self.__class__(self._get_value() % number_value(other))

    def __rmod__(self, other):
        return self.__class__(number_value(other) % self._get_value())

    def __pow__(self, other):
        return self.__class__(self._get_value() ** number_value(other))

    def __rpow__(self, other):
        return self.__class__(number_value(other) ** self._get_value())

    def __eq__(self, other):
        return self._get_value() == number_value(other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __lt__(self, other):
        return self._get_value() < number_value(other)

    def __le__(self, other):
        return self._get_value() <= number_value(other)

    def __gt__(self, other):
        return self._get_value() > number_value(other)

    def __ge__(self, other):
        return self._get_value() >= number_value(other)

    def __float__(self):
        return self

    def __abs__(self):
        return self.__class__(abs(self._get_value()))

    def __neg__(self):
        return self.__class__(-self._get_value())

    def __pos__(self):
        return self.__class__(+self._get_value())

    def __and__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__and__(number_value(other)))

    def __or__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__or__(number_value(other)))

    def __xor__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__xor__(number_value(other)))

    def __invert__(self):
        if isinstance(self._get_value(), float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__invert__())

    def __lshift__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__lshift__(number_value(other)))

    def __rshift__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__rshift__(number_value(other)))

    def __rand__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__rand__(number_value(other)))

    def __ror__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__ror__(number_value(other)))

    def __rxor__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__rxor__(number_value(other)))

    def __rlshift__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__rlshift__(number_value(other)))

    def __rrshift__(self, other):
        if isinstance(self._get_value(), float) or isinstance(other, float):
            raise TypeError('unsupported operand type')
        return self.__class__(int(self._get_value()).__rrshift__(number_value(other)))

    def _get_value(self):
        return int(self)


class MathFloatOperations(MathIntOperations):
    """Math operations for float."""

    def _get_value(self):
        return float(self)


class IntSerializer(MathIntOperations, Serializable):
    """Класс сериализации int-like типов."""

    def to_bin(self):
        """Преобразование в байты."""
        try:
            return struct.pack(f'<{self.fmt_char}', self)
        except struct.error as exc:
            py_object = self.value
            py_cls = type(self)
            msg = f'{py_object=}, {self.fmt_char=}, {self.fmt_char=}, {py_cls=}'
            logger.error(f'Bin Serialization Error: {msg}')
            raise exc

    @classmethod
    def from_bin(cls, bin_data: bytes) -> Tuple['Number', bytes]:
        """Конструирование из байтов."""
        instance = cls()
        bytes_size = bytes_count(instance.bit_size)
        my_bytes = bin_data[:bytes_size]
        try:
            unpacked = struct.unpack(f'<{instance.fmt_char}', my_bytes)
        except struct.error as exc:
            raise BytesDecodeError(
                f'Failed unpack bytes with fmt: {instance.fmt_char} bin_data: {my_bytes=}. Error: {exc}',
            )
        instance = cls(unpacked[0])
        return instance, bin_data[bytes_size:]

    def to_json(self) -> Union[int, float]:
        """Сериализация."""
        return self.value

    @classmethod
    def from_json(cls, json_data: float):
        """Десериализация."""
        instance = cls()
        if isinstance(json_data, (int, float)):
            bit_size = instance.bit_size
            min_val, max_val = min_max_values(instance.is_signed, bit_size, instance.is_float)

            if json_data < min_val or json_data > max_val:
                raise ValueError(f'Value {json_data} is out of range for {cls.__name__}, bit size {bit_size}.')
            instance = cls(int(json_data))
        else:
            raise TypeError(f'Unsupported type for deserialization: {type(json_data)}.')
        return instance


class FloatSerializer(MathFloatOperations, IntSerializer):
    """Класс сериализации float-like типов."""

    @classmethod
    def from_json(cls, json_data: float):
        """Десериализация."""
        instance = cls()
        if isinstance(json_data, (int, float)):
            bit_size = instance.bit_size
            min_val, max_val = min_max_values(instance.is_signed, bit_size, instance.is_float)

            if json_data < min_val or json_data > max_val:
                raise ValueError(f'Value {json_data} is out of range for {cls.__name__}, bit size {bit_size}.')
            instance = cls(float(json_data))
        else:
            raise TypeError(f'Unsupported type for deserialization: {type(json_data)}.')
        return instance


class BaseComplex(Complex):
    """Базовый класс для комплексных чисел."""

    def __init__(self):
        self.value = 0

    def __repr__(self):
        return str(repr(self.value))

    def __str__(self):
        return str(self.value)

    def __complex__(self):
        return self.value + 0j  # noqa: WPS345

    def __format__(self, format_spec):
        return f'{{:{format_spec}}}'.format(self.value)

    def real(self):
        """Определение real части like Complex объекта.."""
        return self.value

    def imag(self):
        """Определение imag части like Complex объекта.."""
        return 0.0  # noqa: WPS358

    def conjugate(self):
        """Определение метода conjugate like Complex объекта."""
        return self.value


class BaseInt(IntSerializer, int):  # noqa: WPS600
    """Базовый класс для int-like типов."""


class BaseFloat(FloatSerializer, float):  # noqa: WPS600
    """Базовый класс для float-like типов."""


def get_int_min_max(is_signed: bool, bit_size: int) -> Tuple[int, int]:
    """Определение минимального и максимального значений для типа int."""
    if is_signed:
        min_val = -(2 ** (bit_size - 1))
        max_val = (2 ** (bit_size - 1)) - 1
    else:
        min_val = 0
        max_val = (2 ** bit_size) - 1
    return min_val, max_val


def get_float_min_max(is_signed: bool, bit_size: int) -> Tuple[float, float]:
    """Определение минимального и максимального значений для типа float."""
    max_float_values = {
        16: 65504.0,
        32: 3.4028235e+38,  # noqa: WPS340
        64: 1.7976931348623157e+308,  # noqa: WPS340
        128: float('inf'),
    }

    try:
        max_val = max_float_values[bit_size]
    except KeyError:
        raise ValueError(f'Unsupported float bit size: {bit_size}')

    min_val = -max_val if is_signed else 0
    return min_val, max_val


def min_max_values(is_signed: bool, bit_size: int, is_float: bool = False) -> Tuple[float, float]:
    """Определение минимального и максимального значений для числового типа."""
    if is_float:
        return get_float_min_max(is_signed, bit_size)
    return get_int_min_max(is_signed, bit_size)


class FloatInt(Serializable, BaseComplex):
    """OLD: Тип заглушка для Number."""

    def __init__(self, value):
        warn('Attribute ".value" wil be delete in future versions. Please use this type as built-in.')
        if isinstance(value, (float, int, FloatInt)):
            self.value = number_value(value)
        else:
            raise TypeError('Value must be an int or a float')

    def __complex__(self):
        return self.value + 0j  # noqa: WPS345

    def __format__(self, format_spec):
        return f'{{:{format_spec}}}'.format(self.value)

    def real(self):
        """Определение real части like Complex объекта.."""
        return self.value

    def imag(self):
        """Определение imag части like Complex объекта.."""
        return 0.0  # noqa: WPS358

    def conjugate(self):
        """Определение метода conjugate like Complex объекта."""
        return self.value


class Number(FloatInt):
    """OLD: Uint 8/16/32/64 бита."""

    is_float: bool
    is_signed: bool
    bit_size: int

    def __init__(self, value: float = 0):
        """Вычисление подходящего под тип переменной символа в struct."""
        if self.is_float:
            char_map = {32: 'f', 64: 'd'}
        else:
            if self.is_signed:
                char_map = {8: 'b', 16: 'h', 32: 'i', 64: 'q'}
            else:
                char_map = {8: 'B', 16: 'H', 32: 'I', 64: 'Q'}

        self.fmt_char = 'unknown'
        try:
            self.fmt_char = char_map[self.bit_size]
        except KeyError:
            raise ValueError(f'size {self.bit_size} not supported.')
        super().__init__(value)

    def __round__(self, n=0):  # noqa: WPS111
        return round(self.value, n)


def number_value(val):
    """Для Number вернёт val.value, для других случаев - вернёт само значение."""
    if isinstance(val, FloatInt):
        return val.value
    return val
