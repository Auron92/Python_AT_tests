"""Базовый класс для vector типов из yaml."""
import struct
from typing import Any, Iterable, List, Union

from stw_py_api_runtime.gen_classes.cmd_helpers import ensure_instance
from stw_py_api_runtime.gen_classes.telemetry.parse import construct_from_json
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable


class VectorBase(Serializable):
    """Базовый класс для описания vector.

    Имеет произвольный размер из одинаковых по типу элементов. В yml прошивке это kind: vector.
    count - максимальное количество элементов (поле count в прошивке)
    element_type - тип элементов (поле base)

    В бинарном виде:
        первые 2 байта: количество элементов
        остальные байты: сами элементы
    """

    element_type: type
    count: int
    count_bytes: int = 2  # кол-во байт, в которых записано количество элементов

    def __init__(self, items: list = None):
        self._storage: List[Any] = []
        if items is None:
            elements = [self.element_type()] * self.count  # noqa: WPS435
        else:
            elements = [ensure_instance(item, self.element_type) for item in items]
        self._storage.extend(elements)

    def __repr__(self) -> str:
        return f'Vector:{self.__class__.__name__}[{self.element_type.__name__}]: {self._storage}'

    def __len__(self) -> int:
        return len(self._storage)

    def __getitem__(self, array_item):
        return self._storage[array_item]

    def __setitem__(self, key, array_value):
        self._storage[key] = array_value

    def __eq__(self, other):
        if isinstance(other, Iterable):
            other_list = list(other)
        elif getattr(other, '_storage', None):
            other_list = other._storage  # noqa: WPS437
        else:
            other_list = other.value
        return self._storage == other_list  # noqa: WPS437

    @classmethod
    def from_json(cls, json_data):
        """Конструирование из json данных."""
        storage = []
        for idx, element in enumerate(json_data):
            new_item = construct_from_json(cls.element_type, element)
            storage.insert(idx, new_item)
        return cls(items=storage)

    def to_json(self) -> List[str]:
        """Сериализация в json.dumps compatible формат."""
        json_data = []
        for item in self._storage:
            if issubclass(type(item), Serializable):
                json_data.append(item.to_json())
                continue
            json_data.append(str(item))
        return json_data

    @classmethod
    def from_bin(cls, bin_data: bytes) -> tuple:
        """Конструирование из байтов."""
        elements_count = cls.elements_count_from_bytes(bin_data)
        elements_bytes = bin_data[cls.count_bytes:]

        elements = []
        for _ in range(elements_count):
            element, elements_bytes = cls.element_type.from_bin(elements_bytes)
            elements.append(element)
        return cls(elements), elements_bytes

    def to_bin(self) -> bytes:
        """Сериализация в байты."""
        bin_count = self.elements_count_from_value(self._storage)
        bin_repr = bytearray()
        for item in self._storage:
            bin_repr.extend(item.to_bin())
        return bin_count + bytes(bin_repr)

    @classmethod
    def elements_count_from_value(cls, elements: Union[str, Iterable]) -> bytes:
        """Получить количество элементов из значения в байтах."""
        elements_count = len(elements)
        return elements_count.to_bytes(cls.count_bytes, byteorder='little')

    @classmethod
    def elements_count_from_bytes(cls, bin_data) -> int:
        """Получить количество элементов из бинарных данных."""
        elements_count_bytes = bin_data[:cls.count_bytes]
        return struct.unpack('<H', elements_count_bytes)[0]
