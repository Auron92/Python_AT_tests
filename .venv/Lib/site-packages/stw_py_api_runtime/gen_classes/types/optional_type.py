"""Базовый класс для optional типов из yaml."""
from stw_py_api_runtime.gen_classes.types.none_type import NoneType
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.sdk.exceptions import OptionalTypeError


class OptionalBase(Serializable):
    """Базовый класс для описания optional.

    Значение может быть как экземпляром element_type - вложенного типа, так и None.
    В yml прошивке это kind: optional, base: some.type.

    В бинарном виде:
        1-й байт: индекс типа
            0 - NULL
            1 - вложенный (base) тип

        остальные байты: само значение

    """

    element_type: Serializable

    def __init__(self, value):
        """Создание объекта в зависимости от переданного типа значения."""
        if value is None:
            self.value = NoneType()
        elif isinstance(value, (self.element_type, NoneType)):
            self.value = value
        else:
            try:
                self.value = self.element_type(value)
            except Exception as exp:
                raise OptionalTypeError(
                    'Optional value was not inited. ',
                    f'Received value: {value}, type: {type(value)}. Expected base type: {self.element_type}.',
                    f'Details: {exp}',
                )

    def __repr__(self):
        return f'Optional:{self.value.__repr__()}'

    def __str__(self):
        return self.value.__str__()

    def __eq__(self, other):
        if isinstance(other, OptionalBase):
            return self.value == other.value
        return self.value == other

    def __format__(self, format_spec):
        return f'{{:{format_spec}}}'.format(self.value)

    @classmethod
    def from_bin(cls, bin_data: bytes) -> tuple:
        """Конструирование из байтов."""
        type_idx = int(bin_data[0])
        data_bytes = bin_data[1:]
        current_element_type = NoneType if type_idx == 0 else cls.element_type
        element, data = current_element_type.from_bin(data_bytes)
        return cls(value=element), data

    def to_bin(self) -> bytes:
        """Сериализация в байты."""
        none_type_idx, element_type_idx = b'\x00', b'\x01'
        element_type_idx = none_type_idx if self.value == NoneType() else element_type_idx
        element_bytes = self.value.to_bin()
        return element_type_idx + element_bytes

    @classmethod
    def from_json(cls, json_data):
        """Конструирование из json данных."""
        if json_data is None:
            return NoneType.from_json(json_data)
        return cls.element_type.from_json(json_data)

    def to_json(self) -> str:
        """Сериализация в json."""
        if self.value is None:
            return 'null'
        return self.value.to_json()
