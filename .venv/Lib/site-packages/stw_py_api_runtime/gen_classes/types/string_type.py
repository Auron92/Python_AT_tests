"""Базовый класс для типов строки."""
from typing import Tuple, Union

from stw_py_api_runtime.gen_classes.types.array_base import ArrayBase
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.gen_classes.types.vector_type import VectorBase


class StringBase(Serializable):
    """Базовый класс для описания строки.

    В yml прошивке это не отдельный kind, а тип array или vector на базе char.
    У него есть размер в байтах (поле count в yaml), который определяется в классе потомке.
    В случае vector - это максимальный возможный размер, а фактический определяется в runtime.
    """

    bytes_size: int
    base: Union[VectorBase, ArrayBase]

    def __init__(self, value: str):
        self.value = value

    def __repr__(self):
        return self.value

    def __str__(self):
        return self.value

    def __eq__(self, other):
        if isinstance(other, str):
            return self.value == other
        return self.value == other.value

    def __format__(self, format_spec):
        return f'{{:{format_spec}}}'.format(self.value)

    def to_bin(self) -> bytes:
        """Сериализация в байты.

        Либо как vector, либо как array, определяется атрибутом base в pygen.
        """
        content_bytes = self.value.encode('utf-8')

        if self.base == VectorBase:
            count_bytes = VectorBase.elements_count_from_value(self.value)
            return count_bytes + content_bytes

        # дополнить нулями до полного массива
        extra_bytes_count = self.bytes_size - len(content_bytes)
        extra_bytes = (extra_bytes_count * '\x00').encode('utf-8')
        return content_bytes + extra_bytes

    @classmethod
    def from_bin(cls, bin_data: bytes) -> Tuple['StringBase', bytes]:
        """Конструирование объекта из байтов.

        Либо в vector, либо в array, определяется атрибутом base в pygen.
        """
        if cls.base == VectorBase:
            elements_count = VectorBase.elements_count_from_bytes(bin_data)
            data_end_byte_idx = VectorBase.count_bytes + elements_count
            bytes_data = bin_data[VectorBase.count_bytes:data_end_byte_idx]
            remaining_bin_data = bin_data[data_end_byte_idx:]
        else:
            bytes_data = bin_data[:cls.bytes_size]
            remaining_bin_data = bin_data[cls.bytes_size:]

        decoded = bytes_data.decode()
        # убираем лишние нулевые байты только справа
        data = decoded.rstrip('\x00')
        return cls(data), remaining_bin_data

    def to_json(self) -> str:
        """Сериализация в json формат."""
        return self.value

    @classmethod
    def from_json(cls, json_data: str):
        """Конструирование объекта из json данных."""
        data = json_data.rstrip('\x00')
        return cls(data)
