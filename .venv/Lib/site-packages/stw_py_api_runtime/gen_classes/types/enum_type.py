"""Enum, который поддерживает сериализацию."""
from abc import abstractmethod
from enum import Enum
from typing import Tuple, Type

from stw_py_api_runtime.gen_classes.types.number import Number
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable


class EnumType(Serializable, Enum):
    """Сериализуемый Enum."""

    def to_json(self) -> str:
        """Преобразование в json формат для SREDA-client-a."""
        return self.name

    @classmethod
    def from_json(cls, json_data):
        """Конструирование из json, где исходные данные - поле name в enum."""
        return cls[json_data]

    def to_bin(self) -> bytes:
        """Сериализовать в байтики."""
        base_type = self._base_type()
        base_obj = base_type(self.value)
        return base_obj.to_bin()

    @classmethod
    def from_bin(cls, bin_data: bytes) -> Tuple['EnumType', bytes]:
        """Десериализация из байтов."""
        base_type = cls._base_type()
        base_obj, exc_bytes = base_type.from_bin(bin_data)
        if issubclass(base_type, Number):
            enum_obj = cls(base_obj.value)
        else:
            enum_obj = cls(base_obj)
        return enum_obj, exc_bytes

    @classmethod
    def names_and_values(cls):
        """Имена и значения из поля класса."""
        return {
            field.name: field.value
            for field in cls
        }

    def __hash__(self):
        return hash(self.value)

    def __eq__(self, other):
        if getattr(other, 'value', None):
            return self.value == other.value
        return self.value == other

    def __repr__(self) -> str:
        return f'<{self.__class__.__name__}.{self.name}: {self.value}>'

    @classmethod
    @abstractmethod
    def _base_type(cls) -> Type[Number]:
        """Базовый тип значений из прошивки."""
        raise NotImplementedError
