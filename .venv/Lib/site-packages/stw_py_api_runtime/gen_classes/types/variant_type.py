"""Базовый класс для variant типов из yaml."""
from stw_py_api_runtime.gen_classes.types.serializable_base import Serializable
from stw_py_api_runtime.sdk.exceptions import DeserializeError, NotSupportedError, VariantTypeError


class VariantBase(Serializable):
    """Базовый класс для описания variant.

    Значение может быть одного из типов в variable_types.
    В yml прошивке это kind: variant, а его возможные типы перечислены в fields.
    Порядок типов в variable_types повторяет порядок fields.

    В бинарном виде:
        1-й байт: индекс типа
            0 - 1-й тип в fields
            1 - 2-й тип
            ..
            N - последний тип

        остальные байты: само значение
    """

    variable_types: tuple

    def __init__(self, value: Serializable):
        """Создание объекта в зависимости от переданного типа значения."""
        element_type = type(value)
        if element_type not in self.variable_types:
            raise VariantTypeError(
                f'Received value has unexpected type by variant {self.__class__.__name__}. ',
                f'Current type: {element_type}. Variables: {self.variable_types}.',
            )
        self.value = value

    def __repr__(self):
        return f'Variant:{self.value.__repr__()}'

    def __str__(self):
        return self.value.__str__()

    def __eq__(self, other):
        return self.value == other

    @classmethod
    def from_bin(cls, bin_data: bytes) -> tuple:
        """Конструирование из байтов."""
        element_type_idx = int(bin_data[0])
        try:
            element_type = cls.variable_types[element_type_idx]
        except IndexError:
            raise VariantTypeError(
                f'Type index {element_type_idx} from bin data not found in variant {cls}. ',
                f'Variable types count: {len(cls.variable_types)}.',
            )
        data_bytes = bin_data[1:]
        try:
            element, rest_data = element_type.from_bin(data_bytes)
        except Exception as exp:
            raise DeserializeError(
                f'Variant type not deserialized. Expected base type - {element_type} by index {element_type_idx}. ',
                f'Details: {exp}.',
            )
        return cls(value=element), rest_data

    def to_bin(self) -> bytes:
        """Сериализация в байты."""
        element_type_idx = self.variable_types.index(type(self.value))
        idx_bytes = element_type_idx.to_bytes(1, byteorder='little')
        return idx_bytes + self.value.to_bin()

    @classmethod
    def from_json(cls, json_data):
        """Конструирование из json данных."""
        # SREDA-2193 ждем поддержки со стороны SREDA
        raise NotSupportedError('Variant type is not supported by SREDA client. Use bin broker.')

    def to_json(self) -> str:
        """Сериализация в json."""
        # SREDA-2193 ждем поддержки со стороны SREDA
        raise NotSupportedError('Variant type is not supported by SREDA client. Use bin broker.')
