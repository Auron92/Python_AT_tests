"""Загрузка и выгрузка данных на прибор."""
import enum
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List

from rich.progress import track
from stw_py_api_runtime.gen_classes.custom_types import Command
from stw_py_api_runtime.gen_shared_types.basic_types import uint32_t
from stw_py_api_runtime.gen_shared_types.types.core.fs.file_id_type import FileId
from stw_py_api_runtime.gen_shared_types.types.core.fs.fixed_data_arr_type import FixedDataArr
from stw_py_api_runtime.gen_shared_types.types.repstub.error_type import Error
from stw_py_api_runtime.sdk.brokers.broker_api import BrokerAPI, CmdCatcherAPI


class LoadMode(enum.Enum):
    """Режим - алгоритм загрузки."""

    SEQUENTIAL = 'SEQUENTIAL'  # noqa: WPS115
    BATCH = 'BATCH'  # noqa: WPS115


@dataclass
class DataLoader(ABC):
    """Загрузка данных на прибор.

    Скачивание и загрузка разделены в разные потомки, т.к. есть необходимость вовне использовать только один режим.
    Например, перепрошивка прибора: там предусмотрена только загрузка данных.
    """

    broker: BrokerAPI
    device_id: int
    chunk_size: int
    file_id: int
    command: CmdCatcherAPI


@dataclass
class DataUploader(DataLoader):
    """Загрузка данных на прибор."""

    @abstractmethod
    def upload(self, data: bytes, size: int, crc: int):
        """Загрузить данные на прибор.

        data: загружаемые данные (байты)
        size: размер данных (количество байт)
        crc: контрольная сумма

        Разбивает байты на чанки, формирует команды с оффсетами, отправляет, проверяет crc и т.д.
        """
        raise NotImplementedError


@dataclass
class DataDownloader(DataLoader):
    """Скачивание данных с прибора."""

    @abstractmethod
    def download(self, size: int, crc: int) -> bytes:
        """Скачать данные с прибора.

        size: ожидаемые размер данных (количество байт)
        crc: ожидаемаея контрольная сумма

        Скачивает байты чанками, собирает в один массив, сверяет с size и crc и т.д..
        """
        raise NotImplementedError


class SeqDataUploader(DataUploader):
    """Последовательная загрузка данных на прибор.

    Команды для получения чанков данных отправляются друг за другом.
    Следующая отправится только после получения успешного ответа на предыдущую.
    """

    def upload(self, data, size, crc):
        """Загрузить данные с проверкой размера и crc."""


class SeqDataDownloader(DataDownloader):
    """Последовательное скачивание данных с прибора.

    Команды с чанками данных отправляются друг за другом.
    Следующая отправится только после получения успешного ответа на предыдущую.
    """

    def download(self, size, crc):
        """Скачать данные с проверкой размера и crc."""


class BatchDataUploader(DataUploader):
    """Параллельная (пакетная) загрузка данных нв прибор."""

    def __init__(self, *args, **kwargs):
        self.batch_size = 5
        super().__init__(*args, **kwargs)

    def upload(self, data: bytes, size: int, crc: int):
        """Загрузить данные с проверкой размера и crc."""
        cmds = self._get_upload_cmds(data)
        self._execute_upload_cmds(cmds)

    def _get_upload_cmds(self, bin_data: bytes) -> list:
        cmds = []

        for offset in range(0, len(bin_data), self.chunk_size):
            chunk = bytearray(bin_data[offset:offset + self.chunk_size])
            chunk_size = len(chunk)
            chunk.extend([0] * (self.chunk_size - len(chunk)))  # noqa: WPS435

            cmds.append(
                Command(
                    name=self.command.name,
                    message_id=self.command.msg_id,
                    args={
                        'file_id': FileId(self.file_id),
                        'offset': uint32_t(offset),
                        'size': uint32_t(chunk_size),
                        'arr': FixedDataArr(chunk),
                    },
                    types=self.command.rep_type.return_types,
                ),
            )
        return cmds

    def _execute_upload_cmds(self, cmds: list):
        tracker = track(
            range(0, len(cmds), self.batch_size),
            description=f'Отправка файла (device_id={self.device_id}, file_id={self.file_id}).',
            total=int(len(cmds) / self.batch_size) + 1,
        )
        for batch_i in tracker:
            responses = self.broker.send_command_batch(
                self.device_id,
                cmds[batch_i:batch_i + self.batch_size],
            )
            for rep in responses:
                if isinstance(rep, Error):
                    raise IOError('Попытка отправить данные произошла с ошибкой.')


class BatchDataDownloader(DataDownloader):
    """Параллельное (пакетное) скачивание данных с прибора."""

    def __init__(self, *args, **kwargs):
        self.batch_size = 5
        super().__init__(*args, **kwargs)

    def download(self, size, crc):
        """Скачать данные с проверкой размера и crc."""
        cmds = self._get_download_cmds(size)
        return self._execute_download_cmds(cmds)

    def _get_download_cmds(self, size: int) -> List[Command]:
        cmds = []

        for offset in range(0, size, self.chunk_size):
            # Если offset + chunk_size переваливает за размер файла, chunk_overflow становится больше 0
            chunk_overflow = max(offset + self.chunk_size - size, 0)
            load_size = self.chunk_size - chunk_overflow
            cmds.append(
                Command(
                    name=self.command.name,
                    message_id=self.command.msg_id,
                    args={
                        'file_id': FileId(self.file_id),
                        'offset': uint32_t(offset),
                        'size': uint32_t(load_size),
                    },
                    types=self.command.rep_type.return_types,
                ),
            )
        return cmds

    def _execute_download_cmds(self, cmds: List[Command]) -> bytes:
        bin_data = bytearray()

        # TODO В рамках PLATSWRIG-2214 сделать нормальный обобщенный прогрессбар на уровне DataLoader
        tracker = track(
            range(0, len(cmds), self.batch_size),
            description=f'Скачивание файла (device_id={self.device_id}, file_id={self.file_id})',
            total=int(len(cmds) / self.batch_size) + 1,
        )
        for batch_i in tracker:
            responses = self.broker.send_command_batch(
                self.device_id,
                cmds[batch_i:batch_i + self.batch_size],
            )
            for rep in responses:
                bin_data.extend([int(element) for element in rep.data])

        return bytes(bin_data)


# TODO PLATSWRIG-2214 Обобщить создание, сделать фабрику

def create_uploader(load_mode, *args, **kwargs) -> DataUploader:
    """Создать инстанс для загрузки."""
    if load_mode == LoadMode.SEQUENTIAL:
        loader_cls = SeqDataUploader
    elif load_mode == LoadMode.BATCH:
        loader_cls = BatchDataUploader
    else:
        raise NotImplementedError

    return loader_cls(*args, **kwargs)


def create_downloader(load_mode, *args, **kwargs) -> DataDownloader:
    """Создать инстанс для скачивания."""
    if load_mode == LoadMode.SEQUENTIAL:
        loader_cls = SeqDataDownloader
    elif load_mode == LoadMode.BATCH:
        loader_cls = BatchDataDownloader
    else:
        raise NotImplementedError

    return loader_cls(*args, **kwargs)
